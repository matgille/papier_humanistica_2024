<html>
                      <head>
                      <title>Alignement final</title>
                        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
                        </head>
                      <body>
                      <table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Lesson Goals</th>
      <th>Objetivo de la lección</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>This lesson builds on Keywords in Context ( Using N-grams ) , where n-grams were extracted from a text .</td>
      <td>Esta lección se basa en Palabras clave en contexto ( usando n-grams ) , en la que se extrajeron n-gramas de un texto .</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Here , you will learn how to output all of the n-grams of a given keyword in a document downloaded from the Internet , and display them clearly in your browser window .</td>
      <td>Aquí aprenderás cómo generar una salidad de todos los n-gramas de una palabra clave dada en un documento descargado de Internet , y visualizarlos claramente en la ventana de tu navegador .</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Files Needed For This Lesson</td>
      <td>Archivos necesarios para esta lección</td>
    </tr>
    <tr>
      <th>3</th>
      <td>If you do not have these files from the previous lesson , you can download a zip file from the previous lesson</td>
      <td>Si no tienes estos archivos de las lecciones anteriores , puedes descargar un archivo zip de las lecciones anteriores .</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Making an N-Gram Dictionary</td>
      <td>Crear un diccionario de n-gramas</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Our n-grams have an odd number of words in them for a reason .</td>
      <td>Nuestros n-gramas tienen un número impar de palabras por una razón .</td>
    </tr>
    <tr>
      <th>6</th>
      <td>At this point , our n-grams don '' t actually have a keyword ; they 're just a list of words .</td>
      <td>En este punto , los n-gramas no contienen en realidad una palabra clave ; son solamente una lista de palabras .</td>
    </tr>
    <tr>
      <th>7</th>
      <td>However , if we have an odd numbered n-gram the middle word will always have an equal number of words to the left and to the right .</td>
      <td>Sin embargo , si tenemos un n-grama impar , la palabra central siempre tendrá el mismo número de palabras a la izquierda y a la derecha .</td>
    </tr>
    <tr>
      <th>8</th>
      <td>We can then use that middle word as our keyword .</td>
      <td>Entonces , podemos utilizar esa palabra del medio como nuestra palabra clave .</td>
    </tr>
    <tr>
      <th>9</th>
      <td>For instance , [ `` it '' , '' was '' , `` the '' , `` best '' , `` of '' , `` times '' , `` it '' ] is a 7-gram of the keyword '' best '' .</td>
      <td>Por ejemplo , [ `` it '' , `` was '' , `` the '' , `` best '' , `` of '' , `` times '' , `` it '' ] es un 7-grama de la palabra clave `` best '' .</td>
    </tr>
    <tr>
      <th>10</th>
      <td>Since we have a long text , we want to be able to output all n-grams for our keyword .</td>
      <td>Ya que tenemos un texto largo , quisieramos ser capaces de generar una salida para todos los n-gramas de nuestra palabra clave .</td>
    </tr>
    <tr>
      <th>11</th>
      <td>To do this we will put each n-gram into a dictionary , using the middle word as the key .</td>
      <td>Para ello , vamos a poner cada n-grama en un diccionario utilizando la palabra de en medio como clave .</td>
    </tr>
    <tr>
      <th>12</th>
      <td>To figure out the keyword for each n-gram we can use the index positions of the list .</td>
      <td>Para averiguar la palabra clave de cada n-grama podemos utilizar la posición de índice de la lista .</td>
    </tr>
    <tr>
      <th>13</th>
      <td>If we are working with 5-grams , for example , the left context will consist of terms indexed by 0 , 1 , the keyword will be indexed by 2 , and the right context terms indexed by 3 , 4 .</td>
      <td>Si estamos trabajando con 5-gramas , por ejemplo , el contexto izquierdo consistirá en términos indexados en 0 , 1 ; la palabra clave en 2 y los términos del contexto derecho en 3 , 4 .</td>
    </tr>
    <tr>
      <th>14</th>
      <td>Since Python indexes start at 0 , a 5-gram 's keyword will always be at index position 2 .</td>
      <td>Dado que los índices en Python comienzan en 0 , la palabra clave de un 5-grama siempre estará en la posición de índice 2 .</td>
    </tr>
    <tr>
      <th>15</th>
      <td>That 's fine for 5-grams , but to make the code a bit more robust , we want to make sure it will work for any length n-gram , assuming its length is an odd number .</td>
      <td>Eso está bien para 5-gramas ; pero para hacer el código un poco más robusto queremos asegurarnos de que funcionará para cualquier longitud de n-gramas , asumiendo que su longitud será un número impar .</td>
    </tr>
    <tr>
      <th>16</th>
      <td>To do this we 'll take the length of the n-gram , divide it by 2 and drop the remainder .</td>
      <td>Para ello , vamos a tomar la longitud del n-grama , dividirla entre 2 y dejar aparte el resto .</td>
    </tr>
    <tr>
      <th>17</th>
      <td>We can achieve this using Python 's floor division operator , represented by two slashes , which divides and then returns an answer to the nearest whole number , always rounding down – hence the term `` floor '' .</td>
      <td>Podemos lograrlo usando un operador de división de piso representado por dos barras , que divide y da como resultado el número entero más cercano , siempre redondeando hacia abajo -de ahí el término piso .</td>
    </tr>
    <tr>
      <th>18</th>
      <td>Let 's build a function that can identify the index position of the keyword when given an n-gram with an odd number of words .</td>
      <td>Construyamos una función que pueda identificar la posición de índice de la palabra clave cuando se le de un n-grama con un número impar de palabras .</td>
    </tr>
    <tr>
      <th>19</th>
      <td>Save the following to obo.py .</td>
      <td>Guarda lo siguiente en obo.py</td>
    </tr>
    <tr>
      <th>20</th>
      <td>To determine the index of the keyword , we have used the len property to tell us how many items are in the first n-gram , then used floor division to isolate the middle index position .</td>
      <td>Para determinar el índice de la palabra clave hemos utilizado la propiedad len para decirnos cuántos elementos hay en el primer n-grama , a continuación hacemos una división de piso para aislar la posición de índice media .</td>
    </tr>
    <tr>
      <th>21</th>
      <td>You can see if this worked by creating a new program , get-keyword.py and running it .</td>
      <td>Puedes ver si esto funciona mediante la creación de un nuevo programa obten-palabraClave.py y ejecutarlo .</td>
    </tr>
    <tr>
      <th>22</th>
      <td>If all goes well , since we are dealing with a 5-gram , you should get 2 as the index position of the keyword as we determined above .</td>
      <td>Si todo va bien y ya que estamos tratando con un 5-grama , debes obtener 2 como la posición de índice de la palabra clave tal y como se determinó anteriormente .</td>
    </tr>
    <tr>
      <th>23</th>
      <td>Now that we know the location of the keywords , let 's add everything to a dictionary that can be used to output all KWIC n-grams of a particular keyword .</td>
      <td>Ahora que sabemos la ubicación de las palabras clave , vamos a añadir todo en un diccionario que pueda utilizarse para generar la salida de todos los n-gramas KWIC para una palabra clave determinada .</td>
    </tr>
    <tr>
      <th>24</th>
      <td>Study this code and then replace your nGramsToKWICDict with the following in your obo.py module .</td>
      <td>Estudia este código y luego remplaza tu nGramasAdicKWIC con lo que sigue en tu módulo obo.py .</td>
    </tr>
    <tr>
      <th>25</th>
      <td>A for loop and if statement checks each n-gram to see if its keyword is already stored in the dictionary .</td>
      <td>Un bucle for y una declaración if comprueban cada n-grama para ver si su palabra clave está ya almacenada en el diccionario .</td>
    </tr>
    <tr>
      <th>26</th>
      <td>If it is n't , it 's added as a new entry .</td>
      <td>Si no es así , se añade una nueva entrada .</td>
    </tr>
    <tr>
      <th>27</th>
      <td>If it is , it 's appended to the previous entry .</td>
      <td>Si lo es , añade a una entrada anterior .</td>
    </tr>
    <tr>
      <th>28</th>
      <td>We now have a dictionary named kwicdict that contains all the n-grams , sortable by keyword and we can turn to the task of outputting the information in a more useful format as we did in Output Data as HTML File .</td>
      <td>Ahora tenemos un diccionario llamado kwicdicc que contiene todos los n-gramas , clasificables por palabra clave y podemos regresar a la tarea de dar salida a la información en un formato más útil como lo hicimos en Salida de datos como archivo HTML .</td>
    </tr>
    <tr>
      <th>29</th>
      <td>Try rerunning the get-keyword.py program and you should now see what's in your KWIC dictionary .</td>
      <td>Prueba volver a ejecutar el programa obten-palabraClave.py y ahora podrás ver qué es lo que hay en tu diccionario KWIC .</td>
    </tr>
    <tr>
      <th>30</th>
      <td>Outputting to HTML</td>
      <td>Salida de datos a HTML</td>
    </tr>
    <tr>
      <th>31</th>
      <td>Pretty Printing a KWIC</td>
      <td>Pretty Printing de una KWIC</td>
    </tr>
    <tr>
      <th>32</th>
      <td>`` Pretty printing '' is the process of formatting output so that it can be easily read by human beings .</td>
      <td>`` Pretty Printing `` es un proceso de formateo de salida que puede ser leído fácilmente por seres humanos .</td>
    </tr>
    <tr>
      <th>33</th>
      <td>In the case of our keywords in context , we want to have the keywords lined up in a column , with the terms in the left-hand context right justified , and the terms in the right-hand context left justified .</td>
      <td>En el caso de nuestras palabras clave en contexto , las queremos tener alineadas en una columna con los términos del contexto de la izquierda alineados a la derecha y los términos del contexto de la derecha alineados a la izquierda .</td>
    </tr>
    <tr>
      <th>34</th>
      <td>In other words , we want our KWIC display to look something like this :</td>
      <td>En otras palabras , queremos que la visualización de nuestro KWIC se vea parecido a esto :</td>
    </tr>
    <tr>
      <th>35</th>
      <td>This technique is not the best way to format text from a web designer's perspective .</td>
      <td>Esta técnica no es la mejor manera de formatear texto desde la perspectiva de un diseñador de páginas Web .</td>
    </tr>
    <tr>
      <th>36</th>
      <td>If you have some experience with HTML we encourage you to use another method that will create a standards compliant HTML file , but for new learners , we just ca n't resist the ease of the technique we're about to describe .</td>
      <td>Si tienes experiencia con HTML te animamos a que utilices otro método que permita crear un archivo HTML compatible con los estándares , pero para los nuevos estudiantes , simplemente no podemos resistirnos a la facilidad de la técnica que vamos a describir .</td>
    </tr>
    <tr>
      <th>37</th>
      <td>After all , the point is to integrate programming principles quickly into your research .</td>
      <td>Después de todo , el objetivo es integrar los principios de programación rápidamente en nuestra investigación .</td>
    </tr>
    <tr>
      <th>38</th>
      <td>To get this effect , we are going to need to do a number of list and string manipulations .</td>
      <td>Para conseguir este efecto , vamos a tener que hacer un número de manipulaciones de listas y cadenas .</td>
    </tr>
    <tr>
      <th>39</th>
      <td>Let 's start by figuring out what our dictionary output will look like as it currently stands .</td>
      <td>Empecemos por averiguar cómo se ve nuestro diccionario de salida en su estado actual .</td>
    </tr>
    <tr>
      <th>40</th>
      <td>Then we can work on refining it into what we want .</td>
      <td>Entonces podremos trabajar en perfeccionarlo para lo que queremos .</td>
    </tr>
    <tr>
      <th>41</th>
      <td>As you can see when you run the above program , the output is not very readable yet .</td>
      <td>Como puedes observar al ejecutar el programa anterior , la salida de datos aún no es muy legible .</td>
    </tr>
    <tr>
      <th>42</th>
      <td>What we need to do is split the n-gram into three parts : before the keyword , the keyword , and after the keyword .</td>
      <td>Lo que tenemos que hacer es dividir el n-grama en tres partes : antes de la palabra clave , la palabra clave y después de la palabra clave .</td>
    </tr>
    <tr>
      <th>43</th>
      <td>We can then use the techniques learned in the previous chapters to wrap everything in HTML so that it is easy to read .</td>
      <td>Podemos utilizar las técnicas aprendidas en los capítulos anteriores para encerrar todo en HTML para que sea fácil de leer .</td>
    </tr>
    <tr>
      <th>44</th>
      <td>Using the same slice method as above , we will create our three parts .</td>
      <td>Utilizando el mismo método anterior de slice , vamos a crear nuestras tres partes .</td>
    </tr>
    <tr>
      <th>45</th>
      <td>Open a Python shell and try the following examples .</td>
      <td>Abre un intérprete de Python para ensayar los siguiente ejemplos .</td>
    </tr>
    <tr>
      <th>46</th>
      <td>Pay close attention to what appears before and after the colon in each case .</td>
      <td>Pon especial atención a lo que aparece antes y después de los dos puntos en cada caso .</td>
    </tr>
    <tr>
      <th>47</th>
      <td>Knowing how to manipulate the slice method is a powerful skill for a new programming historian .</td>
      <td>Saber cómo manipular el método de slice es una poderosa habilidad para un nuevo historiador programador .</td>
    </tr>
    <tr>
      <th>48</th>
      <td>Now that we know how to find each of the three segments , we need to format each to one of three columns in our display .</td>
      <td>Ahora que sabemos cómo encontrar cada uno de los tres segmentos , necesitamos dar formato a cada uno en cada una de las columnas de nuestra pantalla .</td>
    </tr>
    <tr>
      <th>49</th>
      <td>The right-hand context is simply going to consist of a string of terms separated by blank spaces .</td>
      <td>El contexto de la derecha consistirá simplemente en una cadena de términos separados por espacios en blanco .</td>
    </tr>
    <tr>
      <th>50</th>
      <td>We ’ ll use the join method to turn the list entries into a string .</td>
      <td>Utilizaremos el método join para convertir las entradas de la lista en una cadena .</td>
    </tr>
    <tr>
      <th>51</th>
      <td>We want the keywords to have a bit of whitespace padding around them .</td>
      <td>Queremos que las palabras clave tengan un poco de espacio blanco de relleno a su alrededor .</td>
    </tr>
    <tr>
      <th>52</th>
      <td>We can achieve this by using a string method called center , which will align the text to the middle of the screen .</td>
      <td>Podemos lograr esto mediante el uso de un método de cadena llamado center que servirá para adaptar el texto a la mitad de la pantalla .</td>
    </tr>
    <tr>
      <th>53</th>
      <td>We can add padding by making the overall string be longer than the keyword itself .</td>
      <td>Podemos agregar relleno al hacer la longitud de la cadena más larga que la palabra clave .</td>
    </tr>
    <tr>
      <th>54</th>
      <td>The expression below adds three blank spaces ( 6/2 ) to either side of the keyword .</td>
      <td>La expresión que sige añade tres espacios en blanco ( 6/2 ) a cada lado de la palabra clave .</td>
    </tr>
    <tr>
      <th>55</th>
      <td>We've added hash marks at the beginning and end of the expression so you can see the leading and trailing blanks .</td>
      <td>Hemos añadido marcas de almohadilla al principio y al final de la expresión para que puedas ver los espacios en blanco inciales y finales .</td>
    </tr>
    <tr>
      <th>56</th>
      <td>Finally , we want the left-hand context to be right justified .</td>
      <td>Por último , queremos que el contexto de la izquierda esté alineado a la derecha .</td>
    </tr>
    <tr>
      <th>57</th>
      <td>Depending on how large n is , we are going to need the overall length of this column to increase .</td>
      <td>Dependiendo de qué tan grande sea n , vamos a necesitar incrementar la longitud total de esta columna .</td>
    </tr>
    <tr>
      <th>58</th>
      <td>We do this by defining a variable called width and then making the column length a multiple of this variable ( we used a width of 10 characters , but you can make it larger or smaller as desired ) .</td>
      <td>Haremos esto mediante la definición de una variable llamada width ( ancho ) y luego hacer que la longitud de la columna sea un múltiplo de esa variable ( se utilizó un ancho de 10 caracteres , pero se puede hacer más grande o más pequeña según se desee ) .</td>
    </tr>
    <tr>
      <th>59</th>
      <td>The rjust method handles right justification .</td>
      <td>El método rjust se encarga de alinear a la derecha .</td>
    </tr>
    <tr>
      <th>60</th>
      <td>Once again , we 've added hash marks so you can see the leading blanks .</td>
      <td>Una vez más , hemos añadido marcas de almohadilla para que puedas ver los espacios en blanco .</td>
    </tr>
    <tr>
      <th>61</th>
      <td>We can now combine these into a function that takes a KWIC and returns a pretty-printed string .</td>
      <td>Ahora podemos combinar esto en una función que tome una KWIC y nos regrese una cadena `` pretty-printed `` .</td>
    </tr>
    <tr>
      <th>62</th>
      <td>Add this to the obo.py module .</td>
      <td>Añade esto al módulo obo.py .</td>
    </tr>
    <tr>
      <th>63</th>
      <td>Study the code to make sure you understand it before moving on .</td>
      <td>Estudia el código para asegurarte que lo entiendes antes de seguir adelante .</td>
    </tr>
    <tr>
      <th>64</th>
      <td>Putting it All Together</td>
      <td>Ensamblando todo</td>
    </tr>
    <tr>
      <th>65</th>
      <td>We can now create a program that , given a URL and a keyword , wraps a KWIC display in HTML and outputs it in Firefox .</td>
      <td>Ahora podemos crear un programa que , dado un URL y una palabra clave , envuelve en HTML la visualización de una KWIC y genera su salida en Firefox .</td>
    </tr>
    <tr>
      <th>66</th>
      <td>This program begins and ends in a similar fashion as the program that computed word frequencies .</td>
      <td>Este programa empieza y termina de una manera similar como el programa que calcula la frecuencia de palabras .</td>
    </tr>
    <tr>
      <th>67</th>
      <td>Type or copy the code into your text editor , save it as html-to-kwic.py , and execute it .</td>
      <td>Escribe o copia el código en tu editor de texto , guárdalo como html-a-kwic.py y ejecútalo .</td>
    </tr>
    <tr>
      <th>68</th>
      <td>You will need to choose either obo.wrapStringInHTMLMac ( ) or obo.wrapStringInHTMLWindows ( ) as appropriate for your system , as done before .</td>
      <td>Deberás elegir entre obo.envuelveCadenaenHTMLMac ( ) u obo.envuelveCadenaenHTMLWindows ( ) según corresponda a tu sistema , como hicimos antes .</td>
    </tr>
    <tr>
      <th>69</th>
      <td>The first part is the same as above .</td>
      <td>La primera parte del programa es igual que en el caso anterior .</td>
    </tr>
    <tr>
      <th>70</th>
      <td>In the second half of the program , we 've wrapped everything in the HTML pre tag ( pre-formatted ) , which tells the browser not to monkey with any of the spacing we 've added .</td>
      <td>En la segunda parte del programa hemos encerrado todo en una etiqueta HTML pre ( pre-formateada ) , lo cual le indica al navegador que no se confunda con los espacios que hemos agregado .</td>
    </tr>
    <tr>
      <th>71</th>
      <td>Also , notice that we use the has_key dictionary method to make sure that the keyword actually occurs in our text .</td>
      <td>Además , observa que hemos utilizado el método has_key en el diccionario para asegurarnos que la palabra clave realmente se encuentra en nuestro texto .</td>
    </tr>
    <tr>
      <th>72</th>
      <td>If it does n't , we can print a message for the user before sending the output to Firefox .</td>
      <td>Si no es así , podemos imprimir un mensaje para el usuario antes de enviar la salida a Firefox .</td>
    </tr>
    <tr>
      <th>73</th>
      <td>Try changing the target variable to a few other keywords .</td>
      <td>Prueba cambiar la variable objetivo a algunas otras palabras clave .</td>
    </tr>
    <tr>
      <th>74</th>
      <td>Try one you know is n't there to make sure your program does n't output something when it should n't .</td>
      <td>Intenta con alguna que tú sepas que no se encuentra en el texto para asegurarte que tu programa no genere salida de datos cuando no deba .</td>
    </tr>
    <tr>
      <th>75</th>
      <td>We have now created a program that looks for a keyword in a dictionary created from an HTML page on the web , and then outputs the n-grams of that keyword to a new HTML file for display on the web .</td>
      <td>Ahora hemos creado un programa que busca una palabra clave en un diccionario creado a partir de una página HTML de la Web , y luego produce una salida de datos con n-gramas de esa palabra clave en otro archivo HTML para visualizar en la Web .</td>
    </tr>
    <tr>
      <th>76</th>
      <td>All of the lessons up to this point have included parts of Python vocabulary and methods needed to create this final program .</td>
      <td>Todas las lecciones hasta este punto han incluido partes del vocabulario de Python y métodos necesarios para crear este programa final .</td>
    </tr>
    <tr>
      <th>77</th>
      <td>By referring to those lessons , you can now experiment with Python to create programs that accomplish specific tasks that will help in your research process .</td>
      <td>Al referirte a esas lecciones , ahora puedes experimentar con Python para crear programas que realicen tareas específicas que te ayudarán en tu proceso de investigación .</td>
    </tr>
    <tr>
      <th>78</th>
      <td>Code Syncing</td>
      <td>Sincronía de código</td>
    </tr>
    <tr>
      <th>79</th>
      <td>This marks the end of this series of original lessons on python .</td>
      <td>Esta lección marca el final de la serie de lecciones originales sobre Python .</td>
    </tr>
    <tr>
      <th>80</th>
      <td>The finished code for the series can be downloaded as a zip file .</td>
      <td>El código terminado de la serie puede descargarse como un archivo zip .</td>
    </tr>
    <tr>
      <th>81</th>
      <td>If you are following along with the Mac / Linux version you may have to open the obo.py file and change `` file : ///Users/username/Desktop/programming-historian/ '' to the path to the directory on your own computer .</td>
      <td>Si las estás siguiendo con Mac o Linux deberás abrir el archivo obo.py y cambiar `` file : ///Users/username/Desktop/programming-historian/ '' a la ruta del archivo en el directorio de tu propia computadora .</td>
    </tr>
    <tr>
      <th>82</th>
      <td>python-lessons9.zip zip sync</td>
      <td>python-es-lecciones9.zip zip sync</td>
    </tr>
    <tr>
      <th>83</th>
      <td>There is an additional lesson on using Python to download multiple records using Query Strings , marked as the next lesson .</td>
      <td>Nota : Ahora puedes ir a la siguiente lección ( en inglés ) para aprender a Descargar registros múltiples</td>
    </tr>
  </tbody>
</table>
                      </body>
                </html>