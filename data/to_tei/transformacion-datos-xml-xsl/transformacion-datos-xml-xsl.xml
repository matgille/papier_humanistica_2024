<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:id="transformacion-datos-xml-xsl">
  <teiHeader>
 <fileDesc>
  <titleStmt>
   <title>Transformaci&#243;n de datos con XML y XSL para su reutilizaci&#243;n</title>
  <author role="original_author">M. H. Beals</author><editor role="reviewers"><persName>Jonathan Blaney</persName><persName>Tessa C Hauswedell</persName></editor><author role="translators">Antonio Rojas Castro</author><editor role="translation-reviewers"><persName>Pedro Carrillo</persName><persName>Jos&#233; Antonio Motilla</persName></editor><editor role="editors">Adam Crymble</editor></titleStmt>
  <publicationStmt>
   <idno type="doi">10.46430/phes0057</idno><date type="published">07/07/2016</date><date type="translated">08/02/2018</date><p>Lesson reviewed and published in Programming Historian.</p>
  </publicationStmt>
  <sourceDesc>
  <p>Born digital, in a markdown format. Original file: <ref type="original_file" target="#transforming-xml-with-xsl"/>.</p><p>There are other translations: <ref target=""/></p></sourceDesc>
 </fileDesc>
 <profileDesc><abstract><p>Con este tutorial aprender&#225;s a convertir un conjunto de datos hist&#243;ricos procedentes de una base de datos XML (ya sea un solo documento o varios documentos interconectados) en otros formatos m&#225;s adecuados para presentar (tablas, listas) o exponer informaci&#243;n (p&#225;rrafos).</p></abstract><textClass><keywords><term xml:lang="en">data-manipulation</term><term xml:lang="en">data-visualization</term></keywords></textClass></profileDesc>
</teiHeader>
  <text xml:lang="es">
    <body><p style="alert alert-info">
Debido a cambios recientes en las pol&#237;ticas de seguridad de los navegadores web, los cuales ya no pueden ejecutar c&#243;digo XSL de archivos locales, la aproximaci&#243;n original de esta lecci&#243;n ha tenido que ser replanteada. 
Esta lecci&#243;n fue actualizada en marzo de 2022 por Nicol&#225;s Vaughan.
</p>
<div type="2"><head>Introducci&#243;n</head>
<p>Imagina que, con un d&#237;a de antelaci&#243;n, un compa&#241;ero de trabajo te llama por tel&#233;fono pidi&#233;ndote que lo sustituyas en un seminario centrado en <emph>Relaciones de esclavos en el Nuevo Mundo</emph>. Decides recopilar una selecci&#243;n de fuentes primarias para trabajar en clase, encuentras algunas p&#225;ginas web y algunos libros con buenos materiales, pero escanearlo todo o copiar y pegar la informaci&#243;n en un documento nuevo conlleva demasiado tiempo; adem&#225;s, el estilo de la bibliograf&#237;a difiere y las citas son inconsistentes, as&#237; que empiezas a preguntarte si reunir todo este material tiene sentido. Una p&#225;gina web te permite descargar una versi&#243;n <ref target="https://es.wikipedia.org/wiki/Extensible_Markup_Language">XML</ref> de todo el material, pero son tantos los registros y hay tantos <ref target="https://es.wikipedia.org/wiki/Metadatos">metadatos</ref> que no es f&#225;cil encontrar r&#225;pidamente la informaci&#243;n que deseas.</p>
<p>O quiz&#225;s... has encontrado una edici&#243;n antigua de <emph>Inscriptions of Roman Tripolitania</emph> (1952) y te gustar&#237;a hacer un an&#225;lisis estad&#237;stico de la aparici&#243;n de ciertas frases en determinados contextos. Por suerte, King's College London ha publicado una <ref target="https://irt.kcl.ac.uk/irt2009/">versi&#243;n digital del texto</ref> con im&#225;genes, traducciones e informaci&#243;n sobre la localizaci&#243;n de las inscripciones. Puedes explorar el material con la funci&#243;n "Buscar en la p&#225;gina" en tu navegador, pero editar la informaci&#243;n en el formato necesario para el an&#225;lisis requiere tiempo.</p>
<p>Imagina ahora que est&#225;s empezando un proyecto nuevo consistente en el estudio de un cat&#225;logo de subastas de libros del siglo XVII; empiezas registrando los detalles de publicaci&#243;n y la lista de subastas en un documento Word o Excel. Un mes m&#225;s tarde el vicerrector de tu universidad te invita a dar una charla. El decano de tu facultad sugiere que hagas unas diapositivas o notas para facilitar la comprensi&#243;n del proyecto. Tienes ya algunas conclusiones preliminares, pero los datos est&#225;n dispersos en varios lugares y unificar el formato de la informaci&#243;n precisa m&#225;s tiempo del que dispones.</p>
<p>En las tres situaciones descritas, conocer c&#243;mo funciona XML y <ref target="https://es.wikipedia.org/wiki/Extensible_Stylesheet_Language">XSL</ref> te habr&#237;a ahorrado tiempo y esfuerzo.
En este tutorial aprender&#225;s a convertir un conjunto de datos hist&#243;ricos procedentes de una base de datos XML<ref type="footnotemark" target="#note_1"/> (ya sea un solo documento o varios documentos interconectados) en otros formatos m&#225;s adecuados para presentar (tablas, listas) o exponer informaci&#243;n (p&#225;rrafos). Tanto si quieres filtrar informaci&#243;n contenida en una base de datos como si quieres a&#241;adir encabezados o paginaci&#243;n, XSL ofrece a los historiadores la posibilidad de reconfigurar datos a fin de acomodarlos a los cambios de la investigaci&#243;n o a las necesidades de la publicaci&#243;n.</p>
<p>Este tutorial cubre los siguientes aspectos:</p>
<list type="unordered">
<item><hi rend="bold">Editores</hi>: herramientas necesarias para crear hojas de estilo XSL</item>
<item><hi rend="bold">Procesadores</hi>: herramientas necesarias para aplicar las instrucciones de la hoja de estilo XSL a los archivos XML</item>
<item><hi rend="bold">Elecci&#243;n y preparaci&#243;n de datos XML</hi>: c&#243;mo conectar la base de datos con las instrucciones de transformaci&#243;n XSL</item>
</list>
<p>El tutorial tambi&#233;n sirve como gu&#237;a para crear las transformaciones m&#225;s comunes:</p>
<list type="unordered">
<item><hi rend="bold">Imprimir valores</hi>: c&#243;mo imprimir o presentar los datos</item>
<item><hi rend="bold">repeticiones <code rend="inline">for-each</code> (en bucle)</hi>: c&#243;mo presentar datos concretos en cada uno de los objetos o registros existentes</item>
<item><hi rend="bold">Ordenar resultados</hi>: c&#243;mo presentar los datos en un determinado orden</item>
<item><hi rend="bold">Filtrar resultados</hi>: c&#243;mo seleccionar qu&#233; objetos o registros se quieren presentar</item>
</list>
</div><div type="2"><head>&#191;Qu&#233; es XML?</head>
<p>El Lenguaje de Marco Extensible (<emph>eXtensible Markup Language</emph>, abreviado generalmente como "XML") es un m&#233;todo muy flexible de codificaci&#243;n y estructuraci&#243;n de datos. Al contrario que el Lenguaje de Marcado de Hipertexto (<ref target="https://es.wikipedia.org/wiki/HTML">Hypertext Markup Language</ref>, abreviado como "HTML"), que tiene un vocabulario predeterminado, XML es extensible; es decir, puede expandirse para incluir las etiquetas necesarias para, por ejemplo, identificar tantas secciones y subsecciones como quieras.</p>
<p>Una base de datos puede componerse de uno o m&#225;s documentos XML con una estructura b&#225;sica. Cada secci&#243;n del archivo est&#225; contenida en un <ref target="https://developer.mozilla.org/es/docs/Glossary/Element">elemento</ref>, es decir, una categor&#237;a o nombre con el que se identifica el tipo de datos manejados. As&#237; pues, como si fueran <ref target="https://es.wikipedia.org/wiki/Matrioshka">Matrioshkas</ref>, cada nivel de elementos est&#225; contenido en otro.
El elemento <code rend="inline">&lt;ra&#237;z&gt;</code> es precisamente eso: la <emph>ra&#237;z</emph> del documento, es decir, el elemento que contiene al resto de elementos y entidades; y cada uno de estos otros elementos contenidos en &#233;l se considera un <emph>hijo</emph> (<emph>child</emph>) suyo.
An&#225;logamente, el elemento que contiene un elemento hijo se llama elemento <emph>padre</emph> (<emph>parent</emph>).
Por ejemplo:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_0" corresp="code_transformacion-datos-xml-xsl_0.txt" lang="language-xml" rend="block"/></ab>
<p>(Nota que estos nombres &#8212;<code rend="inline">ra&#237;z</code>, <code rend="inline">padre</code> y <code rend="inline">hijo</code>&#8212; son completamente arbitrarios. Pudimos haberlos llamado de cualquier otro modo. Lo importante aqu&#237; son las relaciones de continencia.)</p>
<p>Seg&#250;n las reglas de nuestra base de datos, los elementos pueden tener valores (textuales o num&#233;ricos) o bien un n&#250;mero determinado de elementos hijos.</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_1" corresp="code_transformacion-datos-xml-xsl_1.txt" lang="language-xml" rend="block"/></ab>
<p>Tambi&#233;n pueden tener <ref target="https://developer.mozilla.org/es/docs/Glossary/Attribute">atributos</ref>, algo as&#237; como los metadatos del elemento. Los atributos ayudan a distinguir, por ejemplo, entre distintos tipos de valores sin tener que crear un nuevo tipo de elemento.
Por ejemplo:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_2" corresp="code_transformacion-datos-xml-xsl_2.txt" lang="language-xml" rend="block"/></ab>
<p>Si tienes acceso a una base de datos XML, o si quieres almacenar datos en una, puedes utilizar XSL para ordenar, filtrar y presentar la informaci&#243;n en (casi) todas las maneras imaginables.
Por ejemplo, podr&#237;as abrir un archivo XML como Word (.docx) o Excel (.xslx), inspeccionarlo y, a continuaci&#243;n, eliminar la informaci&#243;n a&#241;adida por Microsoft por defecto como la localizaci&#243;n geogr&#225;fica del creador del documento.
Si quieres saber m&#225;s sobre XML, te recomendamos leer una explicaci&#243;n m&#225;s detallada sobre su estructura y uso en las humanidades en la p&#225;gina web de la <ref target="https://tei-c.org/release/doc/tei-p5-doc/en/html/SG.html">Text Encoding Initiative</ref>.</p>
</div><div type="2"><head>&#191;Qu&#233; es XSL?</head>
<p>El Lenguaje de Hojas de Estilo Extensibles (<emph>eXtensible Stylesheet Language</emph>, abreviado como "XSL") es el complemento natural de XML.
En t&#233;rminos generales, proporciona instrucciones de procesamiento;
en cierto modo, podr&#237;amos decir que XSL es an&#225;logo a las <ref target="https://es.wikipedia.org/wiki/Hoja_de_estilos_en_cascada">Hojas de Estilos en Cascada</ref> (<emph>Cascading Stylesheets</emph>, abreviado "CSS") necesarias para presentar archivos HTML.
Ambos lenguajes permiten transformar el texto plano en un formato de texto enriquecido, as&#237; como determinar su dise&#241;o y apariencia tanto en pantalla como impreso, sin tener que alterar los archivos originales. En un nivel m&#225;s avanzado, tambi&#233;n permiten ordenar y filtrar la informaci&#243;n seg&#250;n un criterio concreto y crear o visualizar otros datos derivados a partir del archivo original.</p>
<p>Al separar los datos (XML) de las instrucciones de procesamiento (XSL), es posible refinar y modificar la presentaci&#243;n sin correr el riesgo de corromper la estructura de los archivos. Asimismo, podemos crear m&#225;s de una <emph>hoja de estilo</emph>, de tal modo que se utilicen en funci&#243;n del objetivo para transformar un solo archivo fuente.
En la pr&#225;ctica, esto significa que solo hay que actualizar los datos en un solo lugar y luego exportar distintos documentos.<ref type="footnotemark" target="#note_A1"/></p>
</div><div type="2"><head>Algunos programas necesarios o recomendados</head>
<div type="3"><head>Editores de texto</head>
<p>Una de las ventajas de guardar datos en formato de texto plano es la facilidad de encontrar programas para visualizarlos y manipularlos. Para los prop&#243;sitos de este tutorial, recomendamos utilizar el editor <ref target="https://code.visualstudio.com/">Visual Studio Code</ref> (que abreviaremos aqu&#237; como "VSCode"),
aunque cualquier otro editor para programaci&#243;n puede servir para este tutorial (Notepad++, Atom, Emacs, Vim, etc.).
VSCode es un editor gratuito y de c&#243;digo abierto.
Mantiene el formato de texto plano, pero ofrece esquemas de colores distintos (verde sobre negro o marr&#243;n sobre beige), as&#237; como la funci&#243;n de esconder secciones o de comentar trozos de c&#243;digo para desactivarlo de manera temporal. </p>
<p>Para los usuarios m&#225;s avanzados, que precisen realizar transformaciones de naturaleza compleja, se recomienda el uso del <ref target="https://www.oxygenxml.com/">Oxygen XML Editor</ref>, si bien no es ni gratuito ni de c&#243;digo abierto.</p>
</div><div type="3"><head>Procesadores de XSL</head>
<p>Tras instalar VSCode en el sistema, hace falta instalar un <emph>procesador de XSL</emph>.
Hay tres maneras de utilizar una hoja de estilo para transformar documentos XML:</p>
<list type="unordered">
<item>mediante un navegador web, que incluye un procesador XSL b&#225;sico;</item>
<item>mediante un procesador XSL incluido en un editor de XML; o</item>
<item>mediante un procesador XSL independiente, que se corre desde la l&#237;nea de comandos (o como un <emph>binding</emph> desde otro lenguaje de programaci&#243;n).</item>
</list>
<p>Hasta hace poco, la primera opci&#243;n habr&#237;a sido la m&#225;s c&#243;moda para aprender a trabajar con XSL.
Sin embargo, los navegadores web han introducido restricciones de seguridad que hacen m&#225;s dif&#237;cil la transformaci&#243;n y el procesamiento de documentos XML locales.
A fin de evitar este problema, podr&#237;as instalar complementos (<emph>addons</emph>) en Google Chrome o en Mozilla Firefox, o modificar directamente sus pol&#237;ticas de seguridad, para permitir que se corran las transformaciones.
Sin embargo, esto tiene el inconveniente de hacer vulnerable el navegador a ciertos tipos de ataque inform&#225;tico.
Por esta raz&#243;n, evitaremos tomar este camino.</p>
<p>La segunda opci&#243;n requiere la instalaci&#243;n de un editor especializado como Oxygen XML Editor o Altova XMLSpy.
Sin embargo, puesto que no son editores gratuitos ni de c&#243;digo abierto, tampoco tomaremos este camino aqu&#237;.</p>
<p>Nos queda la tercera opci&#243;n.
Utilizaremos un procesador XSL gratuito y de c&#243;digo abierto llamado <ref target="https://www.saxonica.com/download/java.xml">Saxon-HE</ref>, desarrollada por Michael Kay, uno de los especialistas m&#225;s renombrados en el campo de XML, XSL, XPath, XQuery y tecnolog&#237;as relacionadas.
Saxon-HE es la versi&#243;n "casera" (<emph>Home Edition</emph>) del procesador XSL Saxon.
<ref target="https://www.saxonica.com/">Saxonica</ref>, la casa de software de Michael Kay, tambi&#233;n tiene para la venta ediciones del procesador Saxon mucho m&#225;s potentes, adecuadas para proyectos gran envergadura y requisitos t&#233;cnicos.
Sin embargo, para nuestros fines &#8212;y de hecho para la gran mayor&#237;a de proyectos que requieren transformaci&#243;n de XML por medio de XSLT&#8212;, la edici&#243;n Saxon-HE es m&#225;s que suficiente.</p>
<div type="4"><head>Instalaci&#243;n de Saxon-HE</head>
<p>Saxon-HE es una aplicaci&#243;n de Java (de hecho, su nombre t&#233;cnico completo es "SaxonJ-HE").
Eso significa que tu sistema operativo debe tener instalada una m&#225;quina virtual de Java (Java Virtual Machine o Java VM) para poder ejecutar Saxon-HE.
La versi&#243;n 11 de Saxon-HE, a la fecha la &#250;ltima, requiere por lo menos la versi&#243;n Java SE 8 (JDK 1.8).
Debes asegurarte de que est&#233; instalada en tu sistema.
Si no lo est&#225;, deber&#225;s instalarla t&#250; mismo.</p>
<p>Para verificar si ya lo est&#225;, deber&#225;s usar la l&#237;nea de comandos de tu sistema operativo.
Para ello, abre tu emulador de terminal (en adelante, el "terminal").
Si est&#225;s en Microsoft Windows, puedes usar para ello o bien <ref target="https://docs.microsoft.com/es-es/powershell/">PowerShell</ref> o bien <ref target="https://git-scm.com/downloads">Git Bash</ref>.
Si est&#225;s en Mac OS, puedes usar la aplicaci&#243;n <ref target="https://support.apple.com/guide/terminal/welcome/mac">Terminal.app</ref> (incluida por defecto en el sistema).
Y si est&#225;s en Linux, puedes usar cualquiera de los terminales instalados por defecto.</p>
<p>Si est&#225;s en Windows, escribe ahora el siguiente comando en tu terminal:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_3" corresp="code_transformacion-datos-xml-xsl_3.txt" lang="language-sh" rend="block"/></ab>
<p>En MacOS y Linux deber&#225;s escribir lo siguiente:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_4" corresp="code_transformacion-datos-xml-xsl_4.txt" lang="language-sh" rend="block"/></ab>
<p>(f&#237;jate en el doble gui&#243;n <code rend="inline">--</code>).</p>
<p>Si Java no est&#225; instalado, ver&#225;s un mensaje de error como el siguiente:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_5" corresp="code_transformacion-datos-xml-xsl_5.txt" lang="language-sh" rend="block"/></ab>
<p>Pero si Java s&#237; est&#225; instalado, obtendr&#225;s algo como esto:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_6" corresp="code_transformacion-datos-xml-xsl_6.txt" lang="language-sh" rend="block"/></ab>
<p>Ahora bien, si la versi&#243;n de Java es inferior a 1.8, o si simplemente no est&#225; instalado, deber&#225;s bajar e instalar la versi&#243;n m&#225;s reciente.
Para ello, ve a la p&#225;gina oficial de descargas de Java, <ref target="https://www.java.com/es/download/">https://www.java.com/es/download/</ref>, y baja la versi&#243;n apropiada a nuestro sistema operativo.
Luego de instalarla, deber&#225;s reiniciar tu computador a fin de que las variables globales, que le informan al sistema d&#243;nde est&#225; el ejecutable de Java, hayan sido correctamente aplicadas.
Hecho esto, verifica de nuevo en la l&#237;nea de comandos la versi&#243;n de Java.
(Si ya has instalado la versi&#243;n m&#225;s reciente y con todo te aparece un mensaje de error indicando que no est&#225; instalada, deber&#225;s ajustar manualmente la variable <code rend="inline">PATH</code> en tu  sistema.
Para ello, revisa <ref target="https://stackoverflow.com/questions/16811332/cannot-run-java-from-the-windows-powershell-command-prompt">esta explicaci&#243;n</ref>.)</p>
<p>A continuaci&#243;n deber&#225;s descargar e instalar Saxon-HE.
Puede bajarlo del repositorio de SourceForge de Saxonica en esta direcci&#243;n:
<ref target="https://sourceforge.net/projects/saxon/files/Saxon-HE/11/Java/">https://sourceforge.net/projects/saxon/files/Saxon-HE/11/Java/</ref>
Busca en la lista la versi&#243;n m&#225;s reciente.
(A la fecha de hoy esta es la versi&#243;n 11.2.)
Descarga entonces el archivo <code rend="inline">SaxonHE11-2J.zip</code> (o el m&#225;s reciente) y descompr&#237;melo en alguna carpeta de tu equipo. (No olvides d&#243;nde qued&#243;.)
Ahora abre el terminal ah&#237; mismo y ejecuta el siguiente comando (ten en cuenta que el nombre del ejecutable &#8212;<code rend="inline">saxon-he-11.2.jar</code>&#8212; puede ser diferente para ti):</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_7" corresp="code_transformacion-datos-xml-xsl_7.txt" lang="language-sh" rend="block"/></ab>
<p>(el par&#225;metro <code rend="inline">-t</code> le dice a Saxon que muestre su versi&#243;n, as&#237; como otra informaci&#243;n &#250;til). </p>
<p>Por ejemplo, en Windows obtendr&#225;s:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_8" corresp="code_transformacion-datos-xml-xsl_8.txt" lang="language-sh" rend="block"/></ab>
<p>Ahora bien, dado que hemos descomprimido Saxon en una carpeta cualquiera (en <code rend="inline">C:\Users\usuario\Downloads</code>, en nuestro ejemplo), solo podremos correr Saxon desde ah&#237;.
Esto quiere decir que si estamos en otra carpeta en nuestro sistema, no podremos correr simplemente la instrucci&#243;n <code rend="inline">java -jar saxon-he-11.2.jar</code> para empezar a trabajar, puesto que el ejecutable <code rend="inline">saxon-he-11.2.jar</code> no estar&#225; disponible ah&#237;.
Esto no es necesariamente un problema.
Tan solo debes asegurarte de que los documentos XML y XSL que vayas a utilizar en tus transformaciones se encuentren siempre <emph>en la misma carpeta</emph> del ejecutable de Saxon.
Los ejemplos de c&#243;digo de l&#237;nea de comandos que mostraremos aqu&#237; presupondr&#225;n que tal es el caso.<ref type="footnotemark" target="#note_A2"/></p>
</div></div></div><div type="2"><head>C&#243;mo elegir y preparar datos en XML</head>
<p>Para empezar a transformar un documento XML, primero es necesario obtener un archivo <emph>bien formado</emph>.<ref type="footnotemark" target="#note_2"/>
Muchas bases de datos hist&#243;ricas disponibles en l&#237;nea est&#225;n modeladas en XML y, a veces, ofrecen sus datos en abierto.
Para realizar este tutorial utilizaremos la base de datos <ref target="http://www.scissorsandpaste.net">Scissors and Paste</ref>.</p>
<p>La base de datos <emph>Scissors and Paste</emph> es una colecci&#243;n colaborativa, en continuo crecimiento, que contiene noticias procedentes de peri&#243;dicos brit&#225;nicos e imperiales de los siglos XVIII y XIX. Los dos objetivos originales del proyecto eran facilitar la comparaci&#243;n de reediciones aparecidas en distintos peri&#243;dicos y detectar temas similares en distintas publicaciones inglesas. Como muchas bases de datos XML, <emph>Scissors and Paste</emph> contiene datos (el texto), informaci&#243;n sobre el formato (como las cursivas o las justificaci&#243;n de los p&#225;rrafos) y metadatos.<ref type="footnotemark" target="#note_3"/>
Los metadatos recogen la paginaci&#243;n de la noticia, la fecha de impresi&#243;n, algunos detalles adicionales sobre el peri&#243;dico, los temas principales y una lista con las personas y lugares mencionados.</p>
<p>En 2015, la base de datos alcanz&#243; las 350 noticias con metadatos. Aunque quiz&#225;s algunos investigadores quieran acceder a toda la informaci&#243;n, la mayor&#237;a est&#225;n interesados en una porci&#243;n de los datos como el a&#241;o de publicaci&#243;n o el tema principal de la noticia. Gracias al uso de XSL, es posible filtrar la informaci&#243;n innecesaria u ordenar el material de un modo que sea m&#225;s &#250;til para investigar. Por ejemplo, como imagin&#225;bamos en la introducci&#243;n, quiz&#225;s nos ser&#237;a de utilidad preparar una lista de publicaciones o bien una tabla con las fechas, los t&#237;tulos y la paginaci&#243;n de las noticias humor&#237;sticas contenidas en la base de datos. En ambos casos, podemos obtener los resultados sin muchos problemas utilizando hojas de estilo XSL. </p>
<p>Para empezar a trabajar con la base de datos <emph>Scissors and Paste</emph>, descarga el archivo <ref target="/assets/transforming-xml-with-xsl/master.zip"><code rend="inline">master.zip</code></ref>.
Descomprime el archivo ZIP para obtener la carpeta llamada <code rend="inline">scissorsandpaste-master</code>.
Puedes descomprimirlo haciendo doble clic desde el explorador de archivos (en Windows, MacOS o Linux) o usando un programa especial para ello.</p>
<p>La carpeta contiene tres &#237;tems principales:</p>
<list type="unordered">
<item>el archivo <code rend="inline">TEISAP.XML</code>: la base de datos XML</item>
<item>la carpeta <code rend="inline">Transformers</code>: una colecci&#243;n de hojas de estilo XSL</item>
<item>la carpeta <code rend="inline">Outputs</code>: archivos derivados de la base de datos mediante las hojas de estilo XSL</item>
</list>
<p>Tambi&#233;n encontrar&#225;s ah&#237; los siguientes documentos:</p>
<list type="unordered">
<item>el archivo <code rend="inline">Template_TEISAP.xml</code>, una plantilla para los investigadores que quieran contribuir con m&#225;s noticias</item>
<item>el archivo <code rend="inline">README.md</code> con informaci&#243;n sobre la base de datos</item>
<item>el archivo <code rend="inline">cite.md</code> que explica c&#243;mo citar la base de datos</item>
<item>el archivo <code rend="inline">license.md</code> con los t&#233;rminos de uso</item>
</list>
<p>Al finalizar este tutorial, te recomendamos explorar las otras hojas de estilo XSL contenidas en la carpeta <code rend="inline">Transformers</code> y los archivos generados con ellas; de esta manera podr&#225;s descubrir otras posibilidades y crear archivos adaptados a tus necesidades.</p>
<p>La informaci&#243;n contenida en el archivo <code rend="inline">TEISAP.XML</code> ha sido codificada seg&#250;n las recomendaciones de la <ref target="https://tei-c.org/">Text-Encoding Initiative</ref> (TEI), gran parte de la cual corresponde a los metadatos.</p>
<p>Sin embargo, en este tutorial utilizaremos una versi&#243;n simplificada que cubre los datos hist&#243;ricos m&#225;s importantes.<ref type="footnotemark" target="#note_4"/>
Deber&#225;s descargar el archivo
<ref target="/assets/transforming-xml-with-xsl/SAPsimple_es.xml"><code rend="inline">SAPsimple_es.xml</code></ref>.
Haz una copia de &#233;l en la misma carpeta donde antes hab&#237;as descomprimido el ejecutable de Saxon.
Ahora &#225;brelo en el editor VSCode y examina su contenido.</p>
<figure><desc>Figura 1: Una primera mirada a un documento XML</desc><graphic url="transformacion-datos-xml-xsl-1.png"/></figure>
<p>La primera l&#237;nea del archivo XML es la siguiente:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_9" corresp="code_transformacion-datos-xml-xsl_9.txt" lang="language-xml" rend="block"/></ab>
<p>Esta l&#237;nea indica la versi&#243;n de XML utilizada (1.0) y el m&#233;todo de codificaci&#243;n del texto (<ref target="https://es.wikipedia.org/wiki/UTF-8">UTF-8</ref>). En la segunda l&#237;nea se encuentra la etiqueta de apertura <code rend="inline">&lt;ra&#237;z&gt;</code> y, al final, la etiqueta de cierre <code rend="inline">&lt;/ra&#237;z&gt;</code>.
Esto quiere decir que <code rend="inline">&lt;ra&#237;z&gt;</code>, como su nombre lo indica, es el elemento ra&#237;z que contiene todos los art&#237;culos de peri&#243;dicos, cada uno etiquetado con un elemento <code rend="inline">&lt;registro&gt;</code>. Antes de continuar, ubica la etiqueta de cierre <code rend="inline">&lt;/registro&gt;</code>.</p>
<p>Dentro de cada registro hay varios elementos hijos. La Text Encoding Initiative permite anidar centenares de elementos para modelar datos de muy distinta naturaleza. Adem&#225;s, la gracia de XML es que puedes dar nombre a tus elementos nuevos con <ref target="https://www.w3schools.com/xml/xml_elements.asp">bastante libertad</ref>. En la base de datos <emph>Scissors and Paste</emph> cada registro contiene los siguientes elementos:</p>
<list type="unordered">
<item><code rend="inline">&lt;identificador&gt;</code>: n&#250;mero de identificaci&#243;n del registro</item>
<item><code rend="inline">&lt;t&#237;tulo&gt;</code>: t&#237;tulo del peri&#243;dico</item>
<item><code rend="inline">&lt;ciudad&gt;</code>: ciudad del peri&#243;dico</item>
<item><code rend="inline">&lt;provincia&gt;</code>: provincia o regi&#243;n del peri&#243;dico</item>
<item><code rend="inline">&lt;pa&#237;s&gt;</code>: pa&#237;s del peri&#243;dico</item>
<item><code rend="inline">&lt;fecha&gt;</code>: fecha del art&#237;culo en formato ISO<ref type="footnotemark" target="#note_5"/></item>
<item><code rend="inline">&lt;a&#241;o&gt;</code>: a&#241;o de la publicaci&#243;n</item>
<item><code rend="inline">&lt;mes&gt;</code>: mes de la publicaci&#243;n</item>
<item><code rend="inline">&lt;d&#237;a&gt;</code>: d&#237;a de la publicaci&#243;n</item>
<item><code rend="inline">&lt;secci&#243;nPalabrasClave&gt;</code>: secci&#243;n que contiene las palabras claves</item>
<item><code rend="inline">&lt;palabraClave&gt;</code>: palabra clave que describe el art&#237;culo</item>
<item><code rend="inline">&lt;titular&gt;</code>: titular del art&#237;culo (opcional)</item>
<item><code rend="inline">&lt;texto&gt;</code>: secci&#243;n que contiene el art&#237;culo</item>
<item><code rend="inline">&lt;p&gt;</code>: p&#225;rrafo de texto</item>
</list>
<p>Tal es, pues, la tipolog&#237;a de datos que utilizaremos para crear otros archivos derivados.</p>
</div><div type="2"><head>C&#243;mo crear y probar tus hojas de estilo XSL</head>
<p>Ha llegado la hora de crear una archivo XSL para transformar el documento XML.
Para ello, abre el editor VSCode, crea un archivo nuevo en blanco y gu&#225;rdalo con el nombre <code rend="inline">miestilo.xsl</code>.
De nuevo, aseg&#250;rate de que el archivo se haya guardado en el mismo directorio que contiene tanto el archivo <code rend="inline">SAPsimple_es.xml</code> como el ejecutable de Saxon.</p>
<p>La primeras tres l&#237;neas de tu archivo XSL ser&#225;n las siguientes:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_10" corresp="code_transformacion-datos-xml-xsl_10.txt" lang="language-xml" rend="block"/></ab>
<p>La primera l&#237;nea declara que este es un documento XML versi&#243;n 1.0, codificado como UTF-8.
(&#161;Nota que un documento XSL es en &#250;ltimas un tipo especial de documento XML!)
La segunda l&#237;nea declara que se trata de la versi&#243;n 1.0 de XSL y que el uso del <ref target="https://es.wikipedia.org/wiki/Espacio_de_nombres_XML">espacio de nombres</ref> (<emph>namespace</emph>, en ingl&#233;s) es el est&#225;ndar establecido por el <ref target="http://www.w3.org/">Consorcio World Wide Web</ref>, cuya URI (<emph>Uniform Resource Identifier</emph>) figura en la instrucci&#243;n.
Finalmente, la tercera l&#237;nea le indica al procesador XSL que queremos generar un archivo de texto plano.
(Tambi&#233;n podr&#237;as haber puesto <code rend="inline">xml</code> o <code rend="inline">html</code>, en lugar de <code rend="inline">text</code>, para generar un documento XML o uno HTML, respectivamente.)</p>
<p>Cada vez que se abre un <code rend="inline">&lt;elemento&gt;</code>, es necesario cerrarlo con la etiqueta <code rend="inline">&lt;/elemento&gt;</code> (comoquiera que se llame).
De lo contrario, se producir&#225; un error de sintaxis y el archivo no ser&#225; bien formado.
Por lo tanto, a&#241;ade ahora la siguiente l&#237;nea al final de tu hoja de estilos XSL:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_11" corresp="code_transformacion-datos-xml-xsl_11.txt" lang="language-xml" rend="block"/></ab>
<p>La siguiente parte de tu hoja de estilo XSL ser&#225; la plantilla principal &#8212;las instrucciones de formato&#8212; para tu <emph>output</emph>.
En una l&#237;nea nueva, inmediatamente despu&#233;s de <code rend="inline">&lt;xsl:output method="text"/&gt;</code>, escribe</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_12" corresp="code_transformacion-datos-xml-xsl_12.txt" lang="language-xml" rend="block"/></ab>
<p>Dentro de estas dos etiquetas pondr&#225;s todas las instrucciones relativas al formato deseado.</p>
<p>El valor del atributo <code rend="inline">match</code> (que puede traducirse como "hacer coincidir" o "emparejar") contiene una barra <code rend="inline">/</code>, porque queremos que la instrucci&#243;n se aplique a <emph>todo el contenido</emph> del documento XML.
Podr&#237;amos haber escrito en su lugar <code rend="inline">ra&#237;z</code> para indicar que solo queremos utilizar los datos contenidos en el elemento <code rend="inline">&lt;ra&#237;z&gt;</code>.
Sin embargo, esto podr&#237;a crear algunos problemas, as&#237; que es mejor que usemos la barra <code rend="inline">/</code> en la instrucci&#243;n principal.</p>
<p>Tras esto, tu archivo <code rend="inline">miestilo.xsl</code> deber&#237;a tener este aspecto:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_13" corresp="code_transformacion-datos-xml-xsl_13.txt" lang="language-xml" rend="block"/></ab>
<p>Guarda tu archivo. En lo que sigue, aseg&#250;rate de guardarlo antes de correr cualquier transformaci&#243;n nueva.</p>
<p>Dentro de la instrucci&#243;n que acabamos de crear, escribe <code rend="inline">&lt;xsl:value-of select="ra&#237;z"/&gt;</code>. No es necesario introducir una l&#237;nea nueva, ni tampoco sangrarla a la derecha; pero si lo haces, ser&#225; m&#225;s f&#225;cil de leer.
Te habr&#225;s dado cuenta de que no hemos incluido una etiqueta de cierre <code rend="inline">&lt;/xsl:value-of&gt;</code>; esto se debe a que la instrucci&#243;n <code rend="inline">&lt;xsl:value-of select="ra&#237;z"/&gt;</code> no tiene contenido y ya est&#225; "auto-cerrada" gracias a la barra <code rend="inline">/</code> situada al final.</p>
<p>Tu archivo <code rend="inline">miestilo.xsl</code> deber&#225; verse as&#237;:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_14" corresp="code_transformacion-datos-xml-xsl_14.txt" lang="language-xml" rend="block"/></ab>
<p>Ahora vamos a transformar nuestro documento XML <code rend="inline">SAPsimple_es.xml</code> en texto plano, utilizando el la hoja de estilos XSL que acabamos de crear.
Para ello, ub&#237;cate en la l&#237;nea de comandos y ejecuta esto:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_15" corresp="code_transformacion-datos-xml-xsl_15.txt" lang="language-sh" rend="block"/></ab>
<p>Al ejecutar este comando, ver&#225;s una gran cantidad de texto desplegarse en el terminal, tanto que no es f&#225;cil leerlo ah&#237; mismo.
El par&#225;metro <code rend="inline">-xsl:</code> proporciona el nombre de la hoja de estilos XSL que ser&#225; utilizada para transformar el documento XML, cuyo nombre es proporcionado por el par&#225;metro <code rend="inline">-s:</code> (de <emph>source</emph>, "fuente").
Si quieres guardar el texto que Saxon ha arrojado, debes usar el par&#225;metro <code rend="inline">-o:</code> (de <emph>output</emph>, "salida"), seguido de un nombre de archivo, por ejemplo as&#237;:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_16" corresp="code_transformacion-datos-xml-xsl_16.txt" lang="language-sh" rend="block"/></ab>
<p>(Ese ser&#225; siempre el comando que debes correr en el terminal para transformar un XML por medio de una hoja de estilos XSLT. Deber&#225;s ejecutarlo <emph>cada vez</emph> que quieras realizar una transformaci&#243;n. En otras palabras, no bastar&#225; con que hagas cambios en tu hoja de estilos para que se produzca la transformaci&#243;n; siempre deber&#225;s ejecutar Saxon para llevarla a cabo.)</p>
<p>Ahora puedes abrir el archivo <emph>salida.txt</emph> en VSCode para inspeccionarlo.
El resultado deber&#237;a ser el texto con los saltos de l&#237;nea existentes, pero <emph>sin</emph> los elementos XML, tal como se percibe en la siguiente imagen:</p>
<figure><desc>Figura 2: Salida del texto inicial</desc><graphic url="transformacion-datos-xml-xsl-2.png"/></figure>
</div><div type="2"><head>C&#243;mo poblar los resultados de tus transformaciones</head>
<p>La l&#237;nea de c&#243;digo <code rend="inline">&lt;xsl:value-of select="ra&#237;z"/&gt;</code> selecciona e imprime la base de datos entera en formato de texto plano y la arroja como salida de la transformaci&#243;n. Si examinas los componentes de la l&#237;nea, sabr&#225;s por qu&#233;:</p>
<list type="unordered">
<item>
<p><code rend="inline">xsl:value-of</code>: sirve para seleccionar e imprimir el valor de un elemento, es decir, el <emph>texto</emph> contenido entre la etiqueta de inicio y de cierre.</p>
</item>
<item>
<p><code rend="inline">select="ra&#237;z"</code>: indica el nombre del elemento que deber&#237;a seleccionarse e imprimirse; en este caso, este elemento la ra&#237;z del documento XML, que incidentalmente se llama aqu&#237; <code rend="inline">&lt;ra&#237;z&gt;</code> (aunque pudo haberse llamado de cualquier otro modo).
A menos que declares lo contrario, si apuntas hacia un elemento padre, el procesador tambi&#233;n seleccionar&#225; el contenido de los todos elementos que est&#233;n en &#233;l.
Por lo tanto, al apuntar al elemento <code rend="inline">&lt;ra&#237;z&gt;</code>, obtenemos el texto contenido en los elementos <code rend="inline">&lt;identificador&gt;</code>, <code rend="inline">&lt;t&#237;tulo&gt;</code>, etc.
(T&#233;cnicamente hablando <code rend="inline">select</code> es un <emph>atributo</emph> del elemento <code rend="inline">&lt;xsl:value-of&gt;</code>, y el <emph>valor</emph> de ese atributo es <code rend="inline">ra&#237;z</code> aqu&#237;.)</p>
</item>
</list>
</div><div type="2"><head>C&#243;mo seleccionar e imprimir valores</head>
<p>Si quieres seleccionar e imprimir el valor de un cierto elemento, sustituye el nombre <code rend="inline">ra&#237;z</code> por el del elemento que quieras. Intent&#233;moslo.
En la hoja de estilos XSL, reemplaza <code rend="inline">ra&#237;z</code> por <code rend="inline">t&#237;tulo</code> en la l&#237;nea apropiada, as&#237;:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_17" corresp="code_transformacion-datos-xml-xsl_17.txt" lang="language-xml" rend="block"/></ab>
<p>Guarda el archivo, ejecuta de nuevo el comando de transformaci&#243;n en el terminal y examina el resultado en VSCode.
(VSCode autom&#225;ticamente refrescar&#225; la ventana cada vez que detecta que un archivo ha sido actualizado.)</p>
<p>&#191;No funcion&#243;? Eso es porque el procesador XSL no sabe d&#243;nde ubicar los elementos <code rend="inline">&lt;t&#237;tulo&gt;</code>. Veamos por qu&#233;.</p>
<div type="3"><head>Padres e hijos</head>
<p>El elemento <code rend="inline">&lt;t&#237;tulo&gt;</code> no est&#225; situado en el nivel m&#225;s alto de la jerarqu&#237;a, as&#237; que debemos explicarle al procesador c&#243;mo llegar hasta el elemento que queremos.
El lenguaje con que se hace esto se conoce como <ref target="https://es.wikipedia.org/wiki/XPath">XPATH</ref> y funciona de una manera similar al modo como se estructuran las rutas de las carpetas en un computador.
Sustituye <code rend="inline">t&#237;tulo</code> por <code rend="inline">ra&#237;z/registro/t&#237;tulo</code>. La hoja de estilos XSL quer&#237;a entonces as&#237;:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_18" corresp="code_transformacion-datos-xml-xsl_18.txt" lang="language-xml" rend="block"/></ab>
<p>Gu&#225;rdala, corre la transformaci&#243;n y examina el resultado en VSCode de nuevo.</p>
<p>Ahora deber&#237;as obtener "Caledonian Mercury", es decir, el t&#237;tulo del primer registro en el documento XML.
Sin embargo, tenemos m&#225;s de 300 elementos <emph>t&#237;tulo</emph>.
&#191;Qu&#233; ha ocurrido?
Es muy sencillo: como no hemos especificado cu&#225;l t&#237;tulo quer&#237;amos imprimir, el procesador ha asumido que solo nos interesaba el primero. Una vez lo selecciona y lo imprime, se detiene.<ref type="footnotemark" target="#note_A3"/></p>
</div><div type="3"><head>Bucles con <code rend="inline">for-each</code></head>
<p>Para un ser humano quiz&#225;s parezca normal querer el contenido de <emph>todos</emph> los elementos <code rend="inline">&lt;t&#237;tulo&gt;</code> en la base de datos XML, pero el procesador no sabe esto por defecto.
Para remediar la situaci&#243;n, debemos repetir la operaci&#243;n una y otra vez por medio de un <emph>bucle <code rend="inline">for</code></emph>.
Adem&#225;s de seleccionar todos y cada uno de los elementos, los bucles <code rend="inline">for</code> nos permiten controlar con mucha precisi&#243;n c&#243;mo hacer esto.
El bucle le indica al procesador XSL que debe procesar todo el documento XML y llevar a cabo la transformaci&#243;n indicada cada vez que una cierta condici&#243;n sea se cumpla.</p>
<p>As&#237; pues, crea una nueva l&#237;nea despu&#233;s de <code rend="inline">&lt;xsl:template match="/"&gt;</code> e inserta <code rend="inline">&lt;xsl:for-each select="ra&#237;z/registro"&gt;</code>. Esta instrucci&#243;n le indica al procesador que para cada elemento <code rend="inline">&lt;registro&gt;</code> situado dentro del elemento <code rend="inline">&lt;ra&#237;z&gt;</code> debe realizar una determinada acci&#243;n.</p>
<p>A continuaci&#243;n, elimina <code rend="inline">ra&#237;z/registro</code> del valor del atributo <code rend="inline">@select</code> en el elemento <code rend="inline">&lt;xsl:value-of&gt;</code> y deja solo <code rend="inline">t&#237;tulo</code>.
La raz&#243;n de esto es que ya estamos adentro del contexto <code rend="inline">ra&#237;z/registro</code> (cuando lo seleccionamos con el elemento <code rend="inline">&lt;xsl:for-each select="ra&#237;z/registro"&gt;</code>)
Tras <code rend="inline">&lt;xsl:value-of&gt;</code>, hay que terminar la operaci&#243;n con la etiqueta de cierre <code rend="inline">&lt;/xsl:for-each&gt;</code>.</p>
<p>El archivo resultante ser&#225; el siguiente:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_19" corresp="code_transformacion-datos-xml-xsl_19.txt" lang="language-xml" rend="block"/></ab>
<p>Ahora el elemento <code rend="inline">&lt;xsl:template&gt;</code> contiene tres l&#237;neas de c&#243;digo:</p>
<list type="ordered">
<item>una etiqueta de inicio para el bucle</item>
<item>una instrucci&#243;n para seleccionar un <code rend="inline">&lt;t&#237;tulo&gt;</code> e imprimir su contenido</item>
<item>una etiqueta de cierre para el bucle</item>
</list>
<p>Guarda la hoja de estilos XLS, corre la transformaci&#243;n en el terminar y examina el resultado en VSCode.
Deber&#237;as obtener una &#250;nica l&#237;nea largu&#237;sima de texto con el valor de cada uno de los elementos <code rend="inline">&lt;t&#237;tulo&gt;</code>. </p>
<p>Puedes mejorar la forma como se imprime indic&#225;ndole al procesador que a&#241;ada un salto de l&#237;nea tras cada entrada.
Para ello, justo despu&#233;s de la l&#237;nea <code rend="inline">&lt;xsl:value-of select="t&#237;tulo"/&gt;</code> en tu archivo XSL, a&#241;ade <code rend="inline">&lt;xsl:text&gt;&amp;#xA;&lt;/xsl:text&gt;</code> para crear un salto de l&#237;nea.
<code rend="inline">&amp;#xA;</code> es el c&#243;digo <ref target="https://es.wikipedia.org/wiki/Nueva_l%C3%ADnea">hexadecimal ISO 10646</ref> con el que se representa un salto de l&#237;nea. <ref type="footnotemark" target="#note_A4"/>
Con el elemento <code rend="inline">&lt;xsl:text&gt;</code> especificamos que queremos imprimir el contenido como texto plano.</p>
<p>Dependiendo del tipo de <emph>output</emph> que se haya escogido (con el elemento <code rend="inline">&lt;xsl:output&gt;</code>), algunos caracteres especiales, espec&#237;ficamente los espacios m&#250;ltiples o los saltos de l&#237;nea, pueden no visualizarse correctamente si se introducen por s&#237; solos.
El uso de elementos <code rend="inline">&lt;xsl:text&gt;</code> garantiza que tu texto se visualizar&#225; exactamente como lo deseas.</p>
<p>El c&#243;digo completo de nuestra hoja de estilos XSL ser&#225; entonces este:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_20" corresp="code_transformacion-datos-xml-xsl_20.txt" lang="language-xml" rend="block"/></ab>
<p>Guarda el archivo, ejecuta de nuevo el comando de transformaci&#243;n en el terminal y examina el resultado en VSCode.
Ahora deber&#237;as ver impreso el valor de los t&#237;tulos de todos los registros contenidos en el documento.</p>
<div type="4"><head>Ejercicio A</head>
<quote>
<p>Nota: algunas soluciones posibles para estos ejercicios se encuentran al final del tutorial.</p>
</quote>
<p>Imprime un inventario de los registros que contenga el identificador, el t&#237;tulo y la fecha de cada registro. </p>
</div><div type="4"><head>Ejercicio B</head>
<p>Imprime el texto de todos los art&#237;culos, precedido por el identificador entre corchetes cuadrados (<code rend="inline">[]</code>).</p>
</div></div><div type="3"><head>Atributos</head>
<p>En un elemento, no siempre se almacena la informaci&#243;n dentro su <emph>contenido</emph> (esto es, aquello que va entre sus etiquetas de apertura y de cierre).
Algunos datos pueden almacenar como valores de <emph>atributos</emph> de ese elemento.
Por ejemplo, el elemento <code rend="inline">&lt;fecha&gt;</code> tiene un atributo llamado <code rend="inline">cu&#225;ndo</code> que contiene el valor de la fecha del art&#237;culo, as&#237;:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_21" corresp="code_transformacion-datos-xml-xsl_21.txt" lang="language-xml" rend="block"/></ab>
<p>Ahora bien, para obtener el valor contenido en el atributo <code rend="inline">cu&#225;ndo</code> hay que hacer referencia a este atributo utilizando el valor <code rend="inline">@cu&#225;ndo</code> (nota la arroba <code rend="inline">@</code> que precede su nombre), as&#237;</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_22" corresp="code_transformacion-datos-xml-xsl_22.txt" lang="language-xml" rend="block"/></ab>
<p>lo que significa: selecciona e imprime el valor del atributo <code rend="inline">cu&#225;ndo</code> del elemento <code rend="inline">&lt;fecha&gt;</code>.</p>
<div type="4"><head>Ejercicio C</head>
<p>Crea un inventario de registros en el que se liste el t&#237;tulo del peri&#243;dico seguido de la fecha de publicaci&#243;n.</p>
</div></div></div><div type="2"><head>C&#243;mo ordenar resultados</head>
<p>Esta base de datos XML fue escrita seg&#250;n se iba recolectando la informaci&#243;n, sin organizar los registros por fecha o t&#237;tulo.
A fin de organizarlos, podemos a&#241;adir un elemento <code rend="inline">&lt;xsl:sort&gt;</code> (literalmente, <emph>ordena</emph> o <emph>clasifica</emph>) al principio de la repetici&#243;n en bucle, es decir, inmediatamente despu&#233;s del elemento <code rend="inline">&lt;xsl:for-each&gt;</code>.
Este elemento tiene varios atributos opcionales que modifican c&#243;mo los datos se ordenan en el documento resultante:</p>
<list type="unordered">
<item><code rend="inline">select</code>: contiene el nombre del elemento que sirve como criterio para ordenar los datos</item>
<item><code rend="inline">order</code>: define si los datos se ordenan de manera ascendiente (con el valor <code rend="inline">ascending</code>) o descendiente (con el valor <code rend="inline">descending</code>)</item>
<item><code rend="inline">data-type</code>: informa al procesador XSL si los datos son de texto (con el valor <code rend="inline">textual</code>) o num&#233;ricos (con <code rend="inline">number</code>)</item>
</list>
<p>Por ejemplo, podemos escribir la siguiente instrucci&#243;n para ordenar los datos a partir del elemento <code rend="inline">&lt;identificador&gt;</code> en orden descendiente, es decir de mayor a menor:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_23" corresp="code_transformacion-datos-xml-xsl_23.txt" lang="language-xml" rend="block"/></ab>
<p>Vale aclarar que es posible ordenar los resultados utilizando un cierto elemento, incluso si no se lo desea imprimir.</p>
<div type="3"><head>Ejercicio D</head>
<p>Imprime el texto de todos los art&#237;culos, ordenados de m&#225;s a menos recientes.
Para ello, utiliza el elemento <code rend="inline">&lt;xsl:sort&gt;</code> y trata las fechas como si fueran texto (<code rend="inline">text</code>).</p>
</div></div><div type="2"><head>C&#243;mo filtrar resultados</head>
<p>Hasta el momento hemos impreso todos los registros contenidos en el documento XML.
Ahora bien, si solo queremos seleccionar unos cuantos, necesitaremos filtrar los resultados mediante condiciones.
Esto se consigue utilizando el elemento <code rend="inline">&lt;xsl:if&gt;</code> (literalmente, <emph>si</emph>) y a&#241;adiendo la condici&#243;n deseada en el atributo <code rend="inline">test</code>.
Si se cumple la condici&#243;n, el procesador llevar&#225; a cabo la instrucci&#243;n contenida en <code rend="inline">&lt;xsl:if&gt;</code>.
Si no la cumple, lo ignorar&#225; y seguir&#225; adelante.</p>
<p>As&#237;, para imprimir los identificadores de los registros del a&#241;o 1789, podemos usar el siguiente c&#243;digo:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_24" corresp="code_transformacion-datos-xml-xsl_24.txt" lang="language-xml" rend="block"/></ab>
<p>Si queremos excluir el a&#241;o 1789, en cambio, utilizaremos la expresi&#243;n <code rend="inline">fecha/a&#241;o!=1789'</code> (donde <code rend="inline">!=</code> significa: <emph>no igual a</emph>).</p>
<div type="3"><head>Ejercicio E</head>
<p>A modo de recapitulaci&#243;n, crea una lista de registros fechados a partir de 1789 ordenada del m&#225;s reciente al m&#225;s antiguo y que contenga el identificador, el t&#237;tulo y la fecha separados por comas; cada registro deber&#225; mostrarse tras un salto de l&#237;nea.</p>
<p>Si lo deseas, puedes especificar que el archivo de salida sea un archivo de <ref target="https://es.wikipedia.org/wiki/Valores_separados_por_comas">Valores separados por comas (CSV)</ref>, que puede abrirse y manipularse como una hoja de c&#225;lculo con Microsoft Excel o LibreOffice Calc.
Para hacer eso, tan solo especif&#237;calo en la l&#237;nea de comandos cuando realices la transformaci&#243;n:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_25" corresp="code_transformacion-datos-xml-xsl_25.txt" lang="language-sh" rend="block"/></ab>
</div></div><div type="2"><head>Conclusi&#243;n</head>
<p>Esta lecci&#243;n ha cubierto el funcionamiento principal de XSL.
Con la informaci&#243;n proporcionada, resulta f&#225;cil generar varios <emph>outputs</emph> en distintos formatos: texto plano, valores separados por coma o por tabulaciones, o Markdown.
Tambi&#233;n ser&#237;a posible crear p&#225;ginas web cambiando valor el atributo <code rend="inline">method</code> en el elemento <code rend="inline">&lt;xsl:output&gt;</code> de <code rend="inline">text</code> a <code rend="inline">html</code>, y envolviendo las instrucciones <code rend="inline">&lt;xsl:value-of&gt;</code> con los elementos HTML pertinentes.</p>
<p>Existen muchas m&#225;s instrucciones con las que transformar documentos XML a otros formatos y estructuras.
Aunque algunas transformaciones m&#225;s avanzadas requieren un procesador XSL 2.0 o 3.0, las explicaciones de este tutorial satisfacen las necesidades m&#225;s comunes de los historiadores.
Para los usuarios m&#225;s experimentados, recomendamos explorar el directorio <code rend="inline">Transformers</code> de la base de datos <emph>Scissors and Paste</emph> a fin de ver m&#225;s ejemplos de c&#243;mo transformar datos estructurados con lenguaje XML.</p>
</div><div type="2"><head>Posibles soluciones a los ejercicios</head>
<div type="3"><head>Introducci&#243;n (fuentes primarias)</head>
<ab><code xml:id="code_transformacion-datos-xml-xsl_26" corresp="code_transformacion-datos-xml-xsl_26.txt" lang="language-xml" rend="block"/></ab>
<p>El punto (<code rend="inline">.</code>) en el elemento XSL <code rend="inline">&lt;xsl:value-of select="."/&gt;</code> es la forma de referirnos al elemento actual en el contexto.
En este caso nos referimos al elemento seleccionado con la instrucci&#243;n <code rend="inline">&lt;xsl:for-each select="texto/p"&gt;</code>, es decir, el elemento <code rend="inline">&lt;p&gt;</code> hijo de <code rend="inline">&lt;texto&gt;</code>.
Si en su lugar tuvi&#233;ramos <code rend="inline">p</code>, no seleccionar&#237;amos nada, pues no existe ning&#250;n <code rend="inline">texto/p/p</code>.</p>
</div><div type="3"><head>Ejercicio A</head>
<ab><code xml:id="code_transformacion-datos-xml-xsl_27" corresp="code_transformacion-datos-xml-xsl_27.txt" lang="language-xml" rend="block"/></ab>
</div><div type="3"><head>Ejercicio B</head>
<ab><code xml:id="code_transformacion-datos-xml-xsl_28" corresp="code_transformacion-datos-xml-xsl_28.txt" lang="language-xml" rend="block"/></ab>
<p>Para eliminar la sangr&#237;a del texto que precede al identificador entre corchetes, necesitar&#225;s hacerte cargo directo del espaciado introduciendo saltos de l&#237;nea tras el identificador y cada p&#225;rrafo, as&#237;:</p>
<ab><code xml:id="code_transformacion-datos-xml-xsl_29" corresp="code_transformacion-datos-xml-xsl_29.txt" lang="language-xml" rend="block"/></ab>
</div><div type="3"><head>Ejercicio C</head>
<ab><code xml:id="code_transformacion-datos-xml-xsl_30" corresp="code_transformacion-datos-xml-xsl_30.txt" lang="language-xml" rend="block"/></ab>
<p><code rend="inline">&amp;#32;</code> es el c&#243;digo HEX equivalente a un espacio.
Aunque es posible a&#241;adir un espacio en la instrucci&#243;n, es mejor utilizar el c&#243;digo hexadecimal para asegurarnos que se mantendr&#225; en el documento generado.
Tambi&#233;n es posible utilizar una coma o cualquier otro separador.</p>
</div><div type="3"><head>Ejercicio D</head>
<ab><code xml:id="code_transformacion-datos-xml-xsl_31" corresp="code_transformacion-datos-xml-xsl_31.txt" lang="language-xml" rend="block"/></ab>
</div><div type="3"><head>Ejercicio E</head>
<ab><code xml:id="code_transformacion-datos-xml-xsl_32" corresp="code_transformacion-datos-xml-xsl_32.txt" lang="language-xml" rend="block"/></ab>
</div></div><div type="2"><head>Bibliograf&#237;a recomendada</head>
<list type="unordered">
<item>Hunter, David <emph>et al</emph>. <emph>Beginning XML</emph>, 4a ed. Indianapolis, IN: Wiley, 2007. Impreso.</item>
<item>Kay, Michael, <emph>XSLT 2.0 and XPATH 2.0: Programmer's Reference</emph>. Indianapolis, IN: Wiley, 2011. Impreso.</item>
<item>Kelly, David J. <emph>XSLT Jumpstarter: Level the Learning Curve and Put Your XML to Work</emph>. Raleigh, NC: Peloria Press, May 2015. Impreso.</item>
<item>Mangano, Sal. <emph>XSLT Cookbook</emph>, 2a ed. Sebstopol, CA: O'Reilly, 2006. Impreso.</item>
<item>Riley, Jenn. <ref target="https://www.niso.org/node/12366"><emph>Understanding Metadata: What is Metadata, and What is For?</emph></ref> NISO, 2017. Web</item>
<item>Tennison, Jeni. <emph>Beginning XSLT 2.0. From Novice to Professional</emph>. Nueva York: Apress, 2005. Impreso.</item>
<item>Tidwell, Doug. <emph>XSLT</emph>, 2a ed. Sebstopol, CA: O'Reilly, 2008. Impreso</item>
</list>
</div><div type="2"><head>Notas</head>
<p><ref type="footnotemark" target="#note_1"/> : Nota del traductor: Seg&#250;n <ref target="https://es.wikipedia.org/wiki/Base_de_datos_XML">Wikipedia</ref>, una base de datos XML es un programa "que da persistencia a datos almacenados en formato XML. Estos datos pueden ser interrogados, exportados y serializados". Pueden distinguirse dos tipos: bases de datos habilitadas (por ejemplo, una basee de datos relacional cl&#225;sica que acepta XML como formato de entrada y salida) y bases de datos nativas (es decir, que utilizan documentos XML como unidad de almacenamiento) como <ref target="https://exist-db.org/exist/apps/homepage/index.html">eXist</ref> o <ref target="https://basex.org/">BaseX</ref>. En este tutorial, sin embargo, la autora, a menudo, no distingue entre el continente (el programario) y el contenido de la base de datos XML (los documentos).</p>
<p><ref type="footnotemark" target="#note_2"/> : Nota del traductor: La <ref target="https://tei-c.org/release/doc/tei-p5-doc/de/html/SG.html#SG132">Text Encoding Initiative</ref> considera que un documento XML est&#225; bien formado cuando cumple tres reglas: (1) un solo elemento (o elemento ra&#237;z) contiene todo el documento; (2) todos los elementos est&#225;n contenidos en el elemento ra&#237;z; y (3) las etiquetas de apertura y cierre marcan, respectivamente, el inicio y el fin de todos los elementos. Para m&#225;s detalles sobre el funcionamiento de XML, aconsejamos consultar Hunter <emph>et al</emph>. (2007). </p>
<p><ref type="footnotemark" target="#note_3"/> : Nota del traductor: La National Information Standards Organization (NISO), nacida en Estados Unidos en 1983 en el &#225;mbito de las bibliotecas, define los metadatos como "la informaci&#243;n creada, almacenada y compartida para describir objetos y que nos permite interactuar con &#233;stos a fin de obtener conocimiento" (Riley, 2017).</p>
<p><ref type="footnotemark" target="#note_4"/> : Nota del traductor: En la versi&#243;n espa&#241;ola de este tutorial, hemos traducido al espa&#241;ol los nombres de los elementos (pero no su contenido) y hemos adaptado las instrucciones XSL para que coincidan con los utilizados en el archivo fuente (<emph>input</emph>). En adelante, daremos por sentado que est&#225;s utilizando el archivo XML <emph><code rend="inline">SAPsimple_es.xml</code></emph>.</p>
<p><ref type="footnotemark" target="#note_5"/> : Nota del traductor: M&#225;s informaci&#243;n en <ref target="https://es.wikipedia.org/wiki/ISO_8601">Wikipedia</ref> y en la p&#225;gina web de <ref target="https://www.iso.org/home.html">International Organization for Standardization</ref>. ISO es una organizaci&#243;n internacional fundada en 1947 y establecida en Ginebra que tiene por misi&#243;n la creaci&#243;n y mantenimiento de est&#225;ndares.</p>
<p><note xml:id="note_A1"> El lenguaje XSL tiene dos ramas: (1) <emph>XSL Formatting Objects</emph> (XSL:FO), que contiene instrucciones de formato para producir un documento PDF a partir de un documento XML; y (2) <emph>Extensible Stylesheet Language Transformations</emph> (XSLT), es contiene instrucciones para transformar un documento XML en otros documentos (XML, HTML, XHTML y texto plano). En este tutorial solo se discute la segunda.</note></p>
<p><note xml:id="note_A2"> Otra posibilidad es que ubiquemos el ejecutable de Saxon en una carpeta que ya est&#233; incluida en la variable global de sistema <code rend="inline">PATH</code> (o que cambiemos dicha variable para que incluya la carpeta que hemos escogido para Saxon). Quienes tengan inter&#233;s pueden consultar estas p&#225;ginas que explican c&#243;mo hacerlo en <ref target="https://www.computerhope.com/issues/ch000549.htm">Windows</ref>, <ref target="https://stackoverflow.com/questions/22465332/setting-path-environment-variable-in-osx-permanently">MacOS</ref> y <ref target="https://opensource.com/article/17/6/set-path-linux">Linux</ref>.</note></p>
<p><note xml:id="note_A3"> Desde la versi&#243;n 2.0 de XSLT, la instrucci&#243;n <code rend="inline">&lt;xsl:value-of&gt;</code> selecciona <emph>todas</emph> las ocurrencias de la expresi&#243;n en el documento XML. (Al respecto, v&#233;ase <ref target="https://www.w3.org/TR/2021/REC-xslt20-20210330/#changes">aqu&#237;</ref>.) Si quieres intentarlo, debes cambiar el valor del atributo <code rend="inline">@version</code> de <code rend="inline">1.0</code> a <code rend="inline">2.0</code> (o a <code rend="inline">3.0</code>) en la l&#237;nea <code rend="inline">&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;</code> de la hoja de estilos XSL.</note></p>
<p><note xml:id="note_A4"> En lugar de usar la entidad <code rend="inline">&amp;#xA;</code>, puedes reemplazar la l&#237;nea con este c&#243;digo:</note>
<code rend="inline">xml &lt;xsl:text&gt; &lt;/xsl:text&gt; </code>
(F&#237;jate en la l&#237;nea en blanco como contenido del elemento <code rend="inline">&lt;xsl:text&gt;</code>.)
Ambas expresiones son equivalentes, aunque esta segunda ocupa m&#225;s espacio (y es m&#225;s evidente) que la primera.</p>
</div></body>
  </text>
</TEI>
