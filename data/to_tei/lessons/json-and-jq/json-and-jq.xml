<TEI xmlns="https://tei-c.org/ns/1-0/">
  <metadata>
  <title>Reshaping JSON with jq</title>
  <layout>lesson</layout>
  <date>2016-05-24</date>
  <authors>Matthew Lincoln</authors>
  <reviewers>Shawn Graham,Nick Ruest</reviewers>
  <editors>Ian Milligan</editors>
  <difficulty>2</difficulty>
  <review-ticket>https://github.com/programminghistorian/ph-submissions/issues/23</review-ticket>
  <activity>transforming</activity>
  <topics>data-manipulation</topics>
  <abstract>Working with data from an art museum API and from the Twitter API, this lesson teaches how to use the command-line utility _jq_ to filter and parse complex JSON files into flat CSV files.</abstract>
  <redirect_from>/lessons/json-and-jq</redirect_from>
  <avatar_alt>A grid-like device for drawing lines</avatar_alt>
  <doi>10.46430/phen0055</doi>
</metadata>
  <text xml:lang="en">
    <body><p class="alert alert-warning" style="alert alert-warning">
Access to Twitter&#8217;s API has recently changed. The Free Tier no longer allows users to search and download Twitter data. Unfortunately, this means that elements of this lesson will only work for those who are paying for an upgraded plan. At the moment, there are no special access plans for researchers or academics. [2023]
</p>
<div type="2"><head>Lesson goals</head>
<p>JSON (JavaScript Object Notation) is a common data sharing format that can describe complex relationships.
Many libraries, archives, museums, and social media sites expose their data through JSON-based APIs.
(On accessing APIs, see <link target="/lessons/applied-archival-downloading-with-wget">downloading structured data with wget</link> and the <link target="/lessons/intro-to-the-zotero-api">series of lessons on working with APIs</link>.)</p>
<p>However, many tools for data analysis and visualization require input in flat tables (i.e. CSV), and because JSON is such a flexible data format, often with many nested levels of data, there is no one-size-fits-all graphical user interface for transforming JSON into other formats.</p>
<p>Working with data from an art museum API and from the Twitter API, this lesson teaches how to use the command-line utility <link target="https://stedolan.github.io/jq/">jq</link> to filter and parse complex JSON files into flat CSV files.
This lesson will begin with an overview of the basic operators of the jq query syntax.
Next, you will learn progressively more complex ways of connecting these operators together.
By the end of the lesson, you will understand how to combine basic operators to create queries that can reshape many types of JSON data.</p>
</div><div type="2"><head>What is JSON?</head>
<p><link target="http://www.json.org/">You may find a short and cogent primer on JSON here.</link>
In brief, a JSON <hi rend="bold">object</hi> is a series of key/value pairs, where <hi rend="bold">keys</hi> are the names for the <hi rend="bold">values</hi> they are paired with.
For example, the tiny JSON object:</p>
<pre><code class="language-json" xml:id="code_json-and-jq_0" type="block" corresp="code_json-and-jq_0.txt"></code></pre>
<p>describes two data points: a name and a role.
Keys are separated from values with a colon (<code type="inline">:</code>), while key/value pairs are separated from each other by a comma (<code type="inline">,</code>).
These objects must be wrapped in curly braces. (<code type="inline">{}</code>)</p>
<p>Keys must be text strings (wrapped in double quotation marks: <code type="inline">""</code>), while values may be quoted text; the unquoted words <code type="inline">true</code>, <code type="inline">false</code>, or <code type="inline">null</code>; an unquoted number; an <hi rend="bold">array</hi> (multiple equivalent values within square brackets: <code type="inline">[]</code>); or another JSON object (wrapped in curly braces: <code type="inline">{}</code>)</p>
<p>Let's consider the JSON for <link target="https://www.rijksmuseum.nl/nl/collectie/SK-C-5">Rembrandt's <emph>Nightwatch</emph> in the Rijksmuseum</link>:</p>
<pre><code class="language-json" xml:id="code_json-and-jq_1" type="block" corresp="code_json-and-jq_1.txt"></code></pre>
<p>Takeaways:</p>
<ul>
<li>The entire text is wrapped in <code type="inline">{}</code>, identifying it as a JSON object.</li>
<li><code type="inline">id</code> is a key, separated by a colon from its value, <code type="inline">"nl-SK-C-5"</code></li>
<li>Some keys here have entire objects as their values. For example, <code type="inline">webImage</code> has an object with its own key:value pairs like <code type="inline">"width": 2500</code> and <code type="inline">"height": 2034</code>.</li>
<li>The key <code type="inline">productionPlaces</code> has an <emph>array</emph> as its value, denoted by the <code type="inline">[]</code> wrapping it.
In this object, the array only has one value, <code type="inline">"Amsterdam"</code>, however it could have multiple values, e.g. <code type="inline">["Amsterdam", "Kloveniersdoelen"]</code>.
Remember, values of an array have no keys - they are all considered to be semantically equivalent to each other.</li>
</ul>
</div><div type="2"><head>Lesson Setup</head>
<p>For the bulk of this lesson, we will be working with a web-based version of jq at the site <link target="https://jqplay.org/">jq play</link>.
For this, you will only need your internet browser.
<link target="https://jqplay.org/">jq play</link> cannot handle very large JSON files, but it is a great sandbox for learning the query language for jq.
(At the end of this lesson, we will download and install the command-line version of jq, which you may use to speedily parse much larger JSON files.)</p>
<figure><desc>The jq play website, with input JSON, filter, and results.</desc><graphic url="jqplay-screenshot.png"/></figure>
<p>We will type all queries into the "Filter" box in the upper-left corner of <link target="https://jqplay.org/">jq play</link>.
Some of the filter queries are long, so be sure to scroll all the way to the right when copying them.
The results will immediately display on the right-hand side, and update whenever you change the filter or the input JSON.
You do not need to press enter.
After each query in this lesson, I will include the first few lines of the expected results, so that you can check your work.
If you see an error displayed in the "Results" field of jq play, don't panic; just edit the query in the "Filter" field and jq play will re-run everything.</p>
<p>In some instances, we will interact with the checkboxes on the upper-right.
These set various jq <link target="https://stedolan.github.io/jq/manual/#Invokingjq">command-line options, or <emph>flags</emph></link>, that affect things like input handling, and the final formatting of the output.
<hi rend="bold">Start the lesson with all of them unchecked.</hi></p>
</div><div type="2"><head>Core jq filters</head>
<p>jq operates by way of <emph>filters</emph>: a series of text commands that you can string together, and which dictate how jq should transform the JSON you give it.</p>
<p>To learn the basic jq filters, we'll work with a sample response from the Rijksmuseum API: <link target="/assets/jq_rkm.json">rkm.json</link>
Select all the text at that link, copy it, and paste it into the "JSON" box at <link target="https://jqplay.org/">jq play</link> on the left hand side.</p>
<div type="3"><head>The dot: <code type="inline">.</code></head>
<p>The basic jq operator is the dot: <code type="inline">.</code>
Used by itself, <code type="inline">.</code> leaves the input unmodified.
Add the name of a key to it, however, and the filter will return the value of that key.
Try the following filter:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_2" type="block" corresp="code_json-and-jq_2.txt"></code></pre>
<p>This tells jq to return the value of the field <code type="inline">count</code>.
The result should read <code type="inline">359</code>.
If you want to access a value in an object that's already within another object, you can chain <code type="inline">.</code> filters together, e.g. <code type="inline">.links.self</code>.
<link target="#output-a-csv-csv">We will use this functionality later in the lesson.</link></p>
<p>Try the <code type="inline">.</code> operator again, this time accessing the field <code type="inline">artObjects</code>.</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_3" type="block" corresp="code_json-and-jq_3.txt"></code></pre>
<p>The results:</p>
<pre><code class="language-json" xml:id="code_json-and-jq_4" type="block" corresp="code_json-and-jq_4.txt"></code></pre>
<p>Note that jq has returned the entire array.
Rather than being wrapped in <code type="inline">{}</code>, the result is a series of objects wrapped within an array (<code type="inline">[{},{},{}]</code>)
The significance of this will be discussed in the next section.</p>
</div><div type="3"><head>The array operator: <code type="inline">[]</code></head>
<p><code type="inline">.artObjects</code> returned one big array of JSON objects.
Before we can access the values inside those objects, we need to break them out of the array that they're in.
By adding <code type="inline">[]</code> onto the end of our filter, jq will break up this one array into 10 separate objects:</p>
<p>Try it:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_5" type="block" corresp="code_json-and-jq_5.txt"></code></pre>
<p>Notice that the <code type="inline">[]</code> wrapping our results are now gone.
To make clear what has happened, check the "Compact Output" checkbox in the upper right.
This removes the cosmetic line breaks in the results, returning one JSON object per line.
You should have a 10-line output now.</p>
<figure><desc>jq's 'Compact Output' option removes all cosmetic line breaks in a file, just leaving one JSON object per line.</desc><graphic url="compact-output-multiple.png"/></figure>
<p>Keeping "Compact Output" checked, remove the <code type="inline">[]</code> from the filter, so it just reads <code type="inline">.artObjects</code> again.
The results should now be just one line, as jq is now just returning one single JSON array:</p>
<figure><desc>When jq returns just one JSON object, the 'Compact Output' option will produce a one-line result.</desc><graphic url="compact-output-single.png"/></figure>
<p>If you want to access just the first (or the <emph>n</emph>-th) item in an array, put a digit in the <code type="inline">[]</code> operator:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_6" type="block" corresp="code_json-and-jq_6.txt"></code></pre>
<p><hi rend="bold">IMPORTANT: you access the first element of an array with <code type="inline">0</code>, not <code type="inline">1</code>.</hi>
This is because JavaScript, like quite a few other programming languages (<link target="http://stackoverflow.com/questions/3135325/why-do-vector-indices-in-r-start-with-1-instead-of-0">though not all!</link>), <link target="http://skillcrush.com/2013/01/17/why-programmers-start-counting-at-zero/">starts counting at 0</link>.</p>
<p>This filter returns just the first element of the <code type="inline">artObjects</code> array.
<code type="inline">.artObjects[1]</code> would return the second, and so on.</p>
<p>Uncheck the "Compact Output" box again before continuing with the lesson.</p>
</div><div type="3"><head>The pipe: <code type="inline">|</code></head>
<p>The magic of jq is that you can connect, or <emph>pipe</emph>, several operators together to accomplish some very complex transformations of your data.
What's more, jq will repeat the filter for each JSON object provided by the previous step.
Therefore, while we started with just one big JSON object, <code type="inline">.artObjects[]</code> created 10 smaller JSON objects.
Any operator we put after the <code type="inline">|</code> will be repeated for each of these objects.</p>
<p>For example, try the following query:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_7" type="block" corresp="code_json-and-jq_7.txt"></code></pre>
<p>This will return a list of every value at the key <code type="inline">id</code> within the <code type="inline">artObjects</code> array, separated by a line break.</p>
</div><div type="3"><head>Filter: <code type="inline">select()</code></head>
<p>Normally jq repeats every filter operation for each line of input that it receives, passing each answer on to the following filter operation.
<code type="inline">select()</code> will only pass on a subset of the input onto the next step of the filter.</p>
<p>Let's filter the Rijksmuseum JSON to only return the ids of objects that have at least one value assigned to their <code type="inline">productionPlaces</code>:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_8" type="block" corresp="code_json-and-jq_8.txt"></code></pre>
<p>This should return:</p>
<pre><code class="language-json" xml:id="code_json-and-jq_9" type="block" corresp="code_json-and-jq_9.txt"></code></pre>
<p>Let's break down this query into its component pieces:</p>
<ol>
<li><code type="inline">.artObjects[] |</code> Breaks open the array of objects contained in the original Rijksmuseum JSON, just like we did in the previous step of this lesson. The <code type="inline">|</code> sends the results of this step along to the next command...</li>
<li>
<code type="inline">select(.productionPlaces | length &gt;= 1) |</code> The command <code type="inline">select(...)</code> will only pass along the JSON objects that match the rule defined inside the parentheses. Our rule has 3 parts:<ol>
<li><code type="inline">.productionPlaces</code> Access the array at the key named <code type="inline">productionPlaces</code></li>
<li><code type="inline">| length</code> The pipe (<code type="inline">|</code>) sends that array to the next command, <code type="inline">length</code>, which returns the number of elements in the array.</li>
<li><code type="inline">&gt;= 1</code> This last part of our rule checks whether the number returned by <code type="inline">length</code> is greater than or equal to 1. If it is <code type="inline">true</code>, then <code type="inline">select()</code> will pass the object along to the last part of our filter. If it is <code type="inline">false</code>, it will not pass it.</li>
</ol>
</li>
<li><code type="inline">.id</code> This final command accesses the value stored in the key <code type="inline">id</code> in the two objects that make it through the <code type="inline">select()</code> filter.</li>
</ol>
<p>jq can also filter based on regular expressions.
(To learn more about regular expressions, see the Programming Historian lesson <link target="/lessons/understanding-regular-expressions">"Understanding Regular Expressions"</link>.)
For example, let's select only those objects whose primary maker has the particle "van" in their name, and return the artist name and artwork id.
<code type="inline">test("van")</code> takes the value returned by the operator <code type="inline">.principalOrFirstMaker</code> and returns true if that value contains the string <code type="inline">van</code>:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_10" type="block" corresp="code_json-and-jq_10.txt"></code></pre>
<p>The results:</p>
<pre><code class="language-json" xml:id="code_json-and-jq_11" type="block" corresp="code_json-and-jq_11.txt"></code></pre>
<p>To see other types of rules for <code type="inline">select()</code>, <link target="https://stedolan.github.io/jq/manual/#ConditionalsandComparisons">consult the full list of jq conditionals and comparisons.</link></p>
</div><div type="3"><head>Create new JSON: <code type="inline">[]</code> and <code type="inline">{}</code></head>
<p>By wrapping <code type="inline">.</code> operators within either <code type="inline">[]</code> or <code type="inline">{}</code>, jq can synthesize new JSON arrays and objects.
This can be useful if you want to output a new JSON file.
As we will see below, this can also be a crucial intermediate step when reshaping complex JSON.</p>
<p>Create a new set of JSON objects with the following filter:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_12" type="block" corresp="code_json-and-jq_12.txt"></code></pre>
<p>When creating an object with <code type="inline">{}</code>, you specify the names of the keys with unquoted text, and then assign the values with regular jq filters.
The resulting set of JSON objects have just two keys: <code type="inline">id</code> and <code type="inline">title</code>:</p>
<pre><code class="language-json" xml:id="code_json-and-jq_13" type="block" corresp="code_json-and-jq_13.txt"></code></pre>
<p>We can also create arrays using <code type="inline">[]</code>:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_14" type="block" corresp="code_json-and-jq_14.txt"></code></pre>
<p>The results:</p>
<pre><code class="language-json" xml:id="code_json-and-jq_15" type="block" corresp="code_json-and-jq_15.txt"></code></pre>
<p>Unlike objects made using <code type="inline">{}</code>, arrays have no keys; they are just simple lists of values.
Creating simple arrays is crucial, however, for mapping our JSON into a CSV file.</p>
</div><div type="3"><head>Output a CSV: <code type="inline">@csv</code></head>
<p>To create a CSV table with jq we want to filter our input JSON into a series of arrays, with each array being a row of the CSV.</p>
<p>The previous filter gave us an array with the <code type="inline">id</code> and <code type="inline">title</code> keys of each painting.
Let's add the primary artist for each artwork as well:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_16" type="block" corresp="code_json-and-jq_16.txt"></code></pre>
<p>The results:</p>
<pre><code class="language-json" xml:id="code_json-and-jq_17" type="block" corresp="code_json-and-jq_17.txt"></code></pre>
<p>Note that, to access the url nested in the <code type="inline">webImage</code> object, we chained together <code type="inline">.webImage.url</code>.</p>
<p>To format this as CSV, add the operator <code type="inline">@csv</code> on the end with another pipe and check the "Raw Output" box in the upper right.
<code type="inline">@csv</code> properly joins the arrays with <code type="inline">,</code> and adds quotes where needed.
"Raw Output" tells jq that we want to produce a text file, rather than a new JSON file.</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_18" type="block" corresp="code_json-and-jq_18.txt"></code></pre>
<p>The results:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_19" type="block" corresp="code_json-and-jq_19.txt"></code></pre>
<p>This is a valid CSV file, which we could now import into an analysis program.</p>
</div></div><div type="2"><head>Advanced operations</head>
<div type="3"><head>JSON vs. JSON Lines</head>
<p>You may encounter two different types of JSON files in the wild: files with one large JSON object, and so-called "JSON lines" files, which have multiple, separate JSON objects each on one single line, not wrapped by <code type="inline">[]</code>.</p>
<p>You will commonly find larger data dumps of JSON will come in a JSON lines format.
For example, the <link target="https://github.com/NYPL-publicdomain/data-and-utilities/tree/master/items">New York Public Library released their public domain collections in multiple JSON lines-formatted files</link>.
You'll note that the NYPL used the file extension <code type="inline">.ndjson</code>, but is is just one convention --- others use <code type="inline">.jsonl</code> or even just <code type="inline">.json</code>.
Because there is no standard for naming JSON vs. JSON lines files, the only way to check what type you are getting is to open the file in a text editor (or use <code type="inline">head</code> on the command line) to check if the file has one object per line, or is one big object (or a series of objects wrapped with <code type="inline">[]</code>) spread out over many lines.</p>
<p>jq will repeat your entire filter statement <emph>per JSON object</emph>.
This means that it will run your filter once on a file with a large JSON object, and run it <emph>once per line</emph> on a "JSON lines" file.</p>
<p>The Rijksmuseum example above is a single JSON object that contains many smaller sub-objects, each of which stands for an artwork in the collection.
We will now begin working with a set of Twitter JSON in the "JSON lines" format, transforming complex relationships into usable flat tables.</p>
<p>Data about tweets can be accessed via the <link target="https://dev.twitter.com/overview/api">Twitter API</link>, which returns JSON data.
One of the easiest ways to search and download Twitter data is using the excellent utility <link target="https://github.com/edsu/twarc">twarc</link>, which saves data as JSON lines.</p>
<p>For this lesson, we will use a small sample of 50 public tweets.
Clear the "Filter", "JSON" and "Result" boxes on <link target="https://jqplay.org/">jq play</link>, and ensure all the checkboxes are unchecked.
<link target="/assets/jq_twitter.json">Then copy this sample Twitter data</link> into <link target="https://jqplay.org/">jq play</link>.</p>
</div><div type="3"><head>One-to-many relationships: Tweet hashtags</head>
<p>Often you may wish to create a table that expresses a one-to-many relationship, such as a tweet and its hashtags.
A tweet will always have exactly one tweet ID, while it may have zero, one, or more hashtags.
There are a few ways to express this as a CSV table, but we will implement two common solutions here:</p>
<ol>
<li>One row per tweet, with multiple hashtags in the same cell</li>
<li>One row per hashtag/tweet combination (<link target="https://en.wikipedia.org/wiki/Wide_and_narrow_data">also known as "long" or "narrow" data</link>), with tweet IDs and hashtags repeated as necessary</li>
</ol>
<div type="4"><head>One row per tweet</head>
<p>Let's create a table with one column with a tweet ID, and a second column with all the hashtags in each tweet, separated by a semicolon: <code type="inline">;</code></p>
<p>This is a relatively complex query that will require a multi-step filter.
First, let's reduce the Twitter JSON to just ids and the objects describing the hashtags.
Paste this filter into <link target="https://jqplay.org/">jq play</link>:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_20" type="block" corresp="code_json-and-jq_20.txt"></code></pre>
<p>The results:</p>
<pre><code class="language-json" xml:id="code_json-and-jq_21" type="block" corresp="code_json-and-jq_21.txt"></code></pre>
<p>Note that we do not have to start this query by breaking apart an array like we did with the Rijskmuseum data.
This is because the Twitter data comes in the JSON lines format, with one separate JSON object per line in the file.
jq simply repeats the filter for each of these separate objects.
This has created a set of JSON objects (wrapped in <code type="inline">{}</code>) with an <code type="inline">id</code> key and a <code type="inline">hashtags</code> key.
The value of <code type="inline">hashtags</code> is the  array (wrapped in <code type="inline">[]</code>) from the original data, which may have 0 or more objects inside it.
Let's add a second query to preserve just the text of those hashtags:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_22" type="block" corresp="code_json-and-jq_22.txt"></code></pre>
<p>The results:</p>
<pre><code class="language-json" xml:id="code_json-and-jq_23" type="block" corresp="code_json-and-jq_23.txt"></code></pre>
<p><code type="inline">id: .id</code> just keeps the <code type="inline">id</code> field unchanged.
The <code type="inline">[]</code> in <code type="inline">.hashtags[].text</code> breaks open the array of hashtags in each tweet, allowing us to extract the value of the <code type="inline">text</code> key from each one.
Note, however, that tweet ID <code type="inline">501064196931330050</code> shows up twice in the results, because it had 2 hashtags: <code type="inline">Ferguson</code> and <code type="inline">MikeBrown</code>.
We want the tweet ID to only show up once, with an array of hashtags.
To do this, let's edit our filter by adding another set of <code type="inline">[]</code>, this time wrapping around <code type="inline">.hashtags[].text</code>:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_24" type="block" corresp="code_json-and-jq_24.txt"></code></pre>
<p>By adding <code type="inline">[]</code> around <code type="inline">.hashtags[].text</code>, we tell jq to collect the individual results of <code type="inline">.hashtags[].text</code> within an array.
If it finds multiple results, it will put them together in the same array.
Note that tweet ID <code type="inline">501064196931330050</code> now has just one object, with an embedded array of two hashtags:</p>
<pre><code class="language-json" xml:id="code_json-and-jq_25" type="block" corresp="code_json-and-jq_25.txt"></code></pre>
<p>Finally, we want to express this as a CSV file, delimiting the hashtags with <code type="inline">;</code>.
To do this, we need to add one more intermediary JSON object:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_26" type="block" corresp="code_json-and-jq_26.txt"></code></pre>
<p>Once again, we use <code type="inline">id: .id</code> to preserve the <code type="inline">id</code> value unchanged.
However, we change the value of <code type="inline">hashtags</code> one last time.
<code type="inline">.hashtags | join(";")</code> uses the <link target="https://stedolan.github.io/jq/manual/#join(str)"><code type="inline">join()</code></link> command, which takes an array as input and joins the elements together using the provided string (in this case, <code type="inline">";"</code>):</p>
<pre><code class="language-json" xml:id="code_json-and-jq_27" type="block" corresp="code_json-and-jq_27.txt"></code></pre>
<p>Now, we can finally format the individual rows of the CSV and output it (remember to check the "Raw Output" box):</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_28" type="block" corresp="code_json-and-jq_28.txt"></code></pre>
<p>This is a very complex, multipart query.
Let's review its components one more time:</p>
<ol>
<li><code type="inline">{id: .id, hashtags: .entities.hashtags} |</code> Create a new set of JSON objects by extracting the <code type="inline">id</code> field from each tweet, along with the JSON object describing the tweet's hashtags.</li>
<li><code type="inline">{id: .id, hashtags: [.hashtags[].text]} |</code> Preserve the <code type="inline">id</code> key:value pair, and collect the <code type="inline">text</code> of each <code type="inline">hashtags</code> object in an array, which we reassign to the key <code type="inline">hashtags</code>.</li>
<li><code type="inline">{id: .id, hashtags: .hashtags | join(";")} |</code> Preserve the <code type="inline">id</code> key:value pair, and join the contents of the <code type="inline">hashtags</code> array together, separated by <code type="inline">;</code></li>
<li><code type="inline">[.id, .hashtags] |</code> Build an array for each row of our desired table</li>
<li><code type="inline">@csv</code> Format everything as a CSV</li>
</ol>
<p>The final results:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_29" type="block" corresp="code_json-and-jq_29.txt"></code></pre>
<p>There are ways to get the same results using an even shorter query, but in most cases, it pays to break up your jq transformations into small steps.</p>
</div><div type="4"><head>One row per hashtag</head>
<p>This is actually simpler to implement in jq, because we can take advantage of jq's natural behavior of repeating filters.</p>
<p>We will start with the same set of operations that extract the tweet ID and the hashtag objects from the original Twitter JSON:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_30" type="block" corresp="code_json-and-jq_30.txt"></code></pre>
<p>This results in a long series of JSON objects with one id and one hashtag per object.
All we need to do is construct the CSV row arrays and pipe them through the <code type="inline">@csv</code> operator:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_31" type="block" corresp="code_json-and-jq_31.txt"></code></pre>
<p>The results:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_32" type="block" corresp="code_json-and-jq_32.txt"></code></pre>
</div></div><div type="3"><head>Grouping and Counting</head>
<p>Often times, your JSON will be structured around one type of entity (say, artworks from the Rijksmuseum API, or tweets from the Twitter API) when you, the researcher, may be more interested in collecting information about a related, but secondary entity, like an artist, a Twitter hashtag, or a Twitter user.
In this section, we will use jq to extract a table of information about Twitter <emph>users</emph> from the tweet-based JSON, as well as grouping and counting tweet <emph>hashtags</emph>.</p>
<p>For the previous examples, we have only needed to consider each tweet individually.
By default, jq will look at one JSON object at a time when parsing a file; consequently, it can <emph>stream</emph> very large files without having to load the entire set in to memory.</p>
<p>However, in cases where we are aggregating information about the individual objects in a JSON file, we need to give jq access to every JSON object in a file simultaneously.
This is where we want to use "Slurp" (or the <code type="inline">-s</code> flag on command-line jq).
"Slurp" tells jq to read every line of the input JSON lines and treat the entire group as one huge array of objects.</p>
<p>With the Twitter data still in the input box on <link target="https://jqplay.org/">jq play</link>, check the "Slurp" box, and just put <code type="inline">.</code> in the filter.
Note that it's wrapped the objects in <code type="inline">[]</code>.
Now we can build even more complex commands that require knowledge of the entire input file.</p>
<div type="4"><head>Extracting user data</head>
<p>Because the Twitter API returns per-tweet information, info about the <emph>users</emph> who send those tweets is repeated with each tweet within an object assigned to the key <code type="inline">user</code>.
Let's look at the user data in the very first tweet in this dataset (remember to keep the "Slurp" option checked.)</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_33" type="block" corresp="code_json-and-jq_33.txt"></code></pre>
<p>The <code type="inline">[0]</code> operator accesses the very first tweet in the data, while <code type="inline">.user</code> extracts the embedded information in the user field.
The results will look like this:</p>
<pre><code class="language-json" xml:id="code_json-and-jq_34" type="block" corresp="code_json-and-jq_34.txt"></code></pre>
<p>To collect information about users, we will want to use the <code type="inline">group_by()</code>
<code type="inline">group_by(.key)</code> takes an array of objects as its input, and returns an array of arrays, with those sub-arrays filled with objects that share the same value for the specified <code type="inline">key</code>.
Because we have read the input JSON lines using the "Slurp" option, we already start with an array of tweet objects.
We can use <code type="inline">group_by(.user)</code> to collect these tweets into sub-arrays of one user each.</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_35" type="block" corresp="code_json-and-jq_35.txt"></code></pre>
<p>You should see that the results are now wrapped within an additional pair of <code type="inline">[]</code>:</p>
<pre><code class="language-json" xml:id="code_json-and-jq_36" type="block" corresp="code_json-and-jq_36.txt"></code></pre>
<p>We can now create a table of users.
Let's create a table with columns for the user id, user name, followers count, and a column of their tweet ids separated by a semicolon.</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_37" type="block" corresp="code_json-and-jq_37.txt"></code></pre>
<p>The results should look like:</p>
<pre><code class="language-json" xml:id="code_json-and-jq_38" type="block" corresp="code_json-and-jq_38.txt"></code></pre>
<p>Let's break down this complex filter:</p>
<ol>
<li><code type="inline">group_by(.user) |</code> This takes the big array of tweets and returns an array of sub-arrays, each sharing the exact same information in the <code type="inline">user</code> key. Note that this works even when the value at the <code type="inline">user</code> key is itself a JSON object wrapped in <code type="inline">{}</code>.</li>
<li><code type="inline">.[] |</code> Having created an array of sub-arrays, we want to break out the individual sub-arrays.</li>
<li>
<code type="inline">{user_id: .[0].user.id, user_name: .[0].user.screen_name, user_followers: .[0].user.followers_count, tweet_ids: [.[].id | tostring] | join(";")}</code> This next bit creates a new set of JSON information, filling in keys and values with the following sub-commands:<ol>
<li><code type="inline">user_id: .[0].user.id,</code> This pulls the first tweet in the sub-array and access the user id, assigning it to the key <code type="inline">user_id</code> in our new JSON object</li>
<li><code type="inline">user_name: .[0].user.screen_name,</code> This does the same for the user name.</li>
<li><code type="inline">user_followers: .[0].user.followers_count,</code> This does the same for the number of followers the user has.</li>
<li>
<code type="inline">tweet_ids: [.[].id | tostring] | join(";")</code> This command collects all the different tweet ids associated with this user and sticks them into one string, delimited with <code type="inline">;</code>. How do we do that?<ol>
<li><code type="inline">.[].id</code> While we know that the user id, name, and followers will be the same for every tweet the user makes, the tweet ids will be unique, so instead of using <code type="inline">.[0]</code> to get values from just the first tweet, we use <code type="inline">.[].id</code> here to get the ids of every single tweet in a user's sub-array.</li>
<li>The command <code type="inline">| tostring</code> converts the tweet id numbers into strings that jq can then paste together with semicolons. <link target="#one-row-per-tweet">We didn't have to use this last time we used <code type="inline">join()</code> to create a column of semicolon-delimited hashtags.</link> Why? Because when we were making a column of hashtags, the original values were already text values wrapped in quotation marks. Tweet ids, on the other hand, are integers that are not wrapped in <code type="inline">""</code>, Because jq can be very picky about data types, we need to convert our integers into strings before using the <code type="inline">join()</code> command in the next step.</li>
<li>Both of these commands are wrapped in <code type="inline">[]</code> which tells jq to collect every result into one single array, which is passed with a <code type="inline">|</code> along to:</li>
<li><code type="inline">join(";")</code>, which turns that array into one single character string, with semicolon delimiters between multiple tweet ids.</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>This filter created new JSON.
To produce a CSV table from this, we just need to add an array construction and the <code type="inline">@csv</code> command at the end of this filter.
You should recognize the way that we combine array construction and <code type="inline">@csv</code> <link target="#output-a-csv-csv">from the earlier example of using <code type="inline">@csv</code></link>.
Don't forget to check both the "Slurp" and "Raw Output" options when creating a CSV table with jq:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_39" type="block" corresp="code_json-and-jq_39.txt"></code></pre>
<p>The results should start like this:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_40" type="block" corresp="code_json-and-jq_40.txt"></code></pre>
<p>Although this table happens to start with users who only have one tweet each in these sample data, you can scroll down through the results to find several users who made multiple tweets.</p>
</div><div type="4"><head>Counting Twitter hashtags</head>
<p>In the previous example we combined <code type="inline">group_by()</code> with <code type="inline">join()</code> to collect multiple values into a text field.
However, we can also use <code type="inline">group_by()</code> in conjunction with <code type="inline">length</code> to compute new values.
In this final exercise, we will use jq to count the number of times unique hashtags appear in this dataset.</p>
<p>Once again, make sure that the "Slurp" option is checked.
(However, uncheck the "Raw Output" option until we are ready to actually produce the final CSV output.)
Counterintuitively, the first thing we need to do to access the hashtags again is to break them <emph>out</emph> of that large array:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_41" type="block" corresp="code_json-and-jq_41.txt"></code></pre>
<p>Adding <code type="inline">.[]</code> at the beginning splits apart the large array created by the "Slurp" option.
This is necessary because, while tweets can only have one user, they can have multiple hashtags.
Thus, we need to fully break out all the possible hashtag values per tweet, and then collect that entire output back into an array inside <code type="inline">[]</code>, so that we can pass a single array into the <code type="inline">group_by()</code> function:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_42" type="block" corresp="code_json-and-jq_42.txt"></code></pre>
<p>Note the change at the start of the filter: the first two components are now wrapped in <code type="inline">[]</code>.
We did a similar sort of wrapping in the previous section of this lesson.
We also added the <code type="inline">group_by(.hashtag)</code> command at the end of the filter.
The results:</p>
<pre><code class="language-json" xml:id="code_json-and-jq_43" type="block" corresp="code_json-and-jq_43.txt"></code></pre>
<p>In the above query, tweet/hashtag pairs are grouped in to arrays based on the value of their <code type="inline">hashtag</code> key.
To count the number of times each hashtag is used, we only have to count the size of each of these sub-arrays.</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_44" type="block" corresp="code_json-and-jq_44.txt"></code></pre>
<p>The results:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_45" type="block" corresp="code_json-and-jq_45.txt"></code></pre>
<p>(Remember, to format CSV output correctly, set jq to "Raw Output" using the <code type="inline">-r</code> flag on the command line, or check the "Raw Output" box on <link target="https://jqplay.org/">jq play</link>.)</p>
<p><code type="inline">.[]</code> once again breaks apart the large array, so we are left only with the sub-arrays within.
We need to retrieve two pieces of information: first, the name of the hashtag for each sub-array, which we can get by accessing the value of the <code type="inline">hashtag</code> key in the first tweet/hashtag combo of the array (accessed with <code type="inline">.[0]</code>).
Second, we need to get the length of the array, accessed with <code type="inline">. | length</code>.
Finally, we create the CSV and format the CSV rows.</p>
<p>To review:</p>
<ol>
<li>
<code type="inline">[.[] | {id: .id, hashtag: .entities.hashtags} | {id: .id, hashtag: .hashtag[].text}] |</code> This nested filter :<ol>
<li>breaks out individual tweet objects from the large array created by the "Slurp" option (<code type="inline">.[]</code>)</li>
<li>retrieves the tweet id and hashtag text (<code type="inline">{id: .id, hashtag: .entities.hashtags} | {id: .id, hashtag: .hashtag[].text}</code>)</li>
<li>Wraps both of those filters in <code type="inline">[]</code> in order to collect the results in one large array again.</li>
</ol>
</li>
<li><code type="inline">group_by(.hashtag) |</code> Takes the large array from the previous step and sorts it into an array of arrays, each sub-array containing tweet objects sharing the same hashtag.</li>
<li><code type="inline">.[] |</code> Break the large array produced by <code type="inline">group_by()</code> into its component sub-arrays.</li>
<li><code type="inline">{tag: .[0].hashtag, count: . | length} |</code> Get the hashtag representing each sub-array by checking the hashtag value of the first member of each sub-array, and then count the size of each sub-array, effectively counting the number of tweets in which that hashtag was used.</li>
<li><code type="inline">[.tag, .count] |</code> Create simple arrays with just the tag name and count</li>
<li><code type="inline">@csv</code> Format each array as a CSV row</li>
</ol>
</div></div><div type="3"><head>Challenges</head>
<p>These final challenges will help you test your understanding of how to pipe together <link target="https://stedolan.github.io/jq/">jq</link> commands on your own.</p>
<div type="4"><head>Filter before counting</head>
<p>What function do we need to add to the hashtag-counting filter to only count hashtags when their tweet has been retweeted at least 200 times?
Hint: the retweet count is saved under the key <code type="inline">retweet_count</code>.</p>
<p>You should get the following table:</p>
<pre><code class="language-txt" xml:id="code_json-and-jq_46" type="block" corresp="code_json-and-jq_46.txt"></code></pre>
<p><link target="/assets/filter_retweets.txt">There are multiple ways to solve this with jq. See my answer here.</link></p>
</div><div type="4"><head>Count total retweets per user</head>
<p>One more challenge to test your mastery of jq: from this dataset, try to compute the total number of times each user has had their tweets (at least within this dataset) retweeted.</p>
<p>Hints:</p>
<ul>
<li>You should have a table with two columns: one for user id, and one for the total number of retweets. There should only be one row per user id.</li>
<li>Since we are looking at per-user statistics that cut accross individual tweets, we'll need to use <code type="inline">group_by()</code> and the "Slurp" option.</li>
<li>We've used a few functions that reduce an array of multiple values into one value: <code type="inline">length</code> counts the number of values in an array, and <code type="inline">join()</code> pastes those values together in one string. If you want to <emph>add</emph> numeric values together, though, <code type="inline">add</code> could be a promising function to try...</li>
</ul>
<p>As a way to verify your results, user <code type="inline">356854246</code> should have a total retweet count of <code type="inline">51</code> based on this dataset.</p>
<p><link target="/assets/count_retweets.txt">See my answer.</link></p>
</div></div></div><div type="2"><head>Using jq on the command line</head>
<p><link target="https://jqplay.org/">jq play</link> is fine when you have under 100-200 lines of JSON to parse.
However, it will become unusably slow on  much larger files.
For fast processing of very large files, or of JSON lines spread across multiple files, you will need to run the command-line version of jq.</p>
</div><div type="2"><head>Installation</head>
<div type="3"><head>Installation on OS X</head>
<p>The easiest way to install jq on OS X is to use the package management system <link target="http://brew.sh/">Homebrew</link>.
This system works via OS X's "Terminal" application, which gives you access to the Bash command line.
<link target="/lessons/intro-to-bash">For an introduction to this system, see The Programming Historian's "Introduction to the Bash Command Line".</link></p>
<p>Follow the installation instructions for Homebrew itself, and then use this command to install jq:</p>
<pre><code class="language-sh" xml:id="code_json-and-jq_47" type="block" corresp="code_json-and-jq_47.txt"></code></pre>
</div><div type="3"><head>Installation on Windows</head>
<p>To access the command line easily on Windows, you will need the PowerShell application.
<link target="/lessons/intro-to-powershell.html">See the Programming Historian's "Introduction to PowerShell"</link></p>
<p>From PowerShell, you can install the Windows package manager <link target="https://chocolatey.org/install">Chocolatey</link>, and then install jq with the following command:</p>
<pre><code class="language-sh" xml:id="code_json-and-jq_48" type="block" corresp="code_json-and-jq_48.txt"></code></pre>
</div><div type="3"><head>Invoking jq</head>
<pre><code class="language-sh" xml:id="code_json-and-jq_49" type="block" corresp="code_json-and-jq_49.txt"></code></pre>
<ol>
<li><code type="inline">jq</code> calls the jq program.</li>
<li><code type="inline">-r</code> sets the "Raw Output" option.</li>
<li>The actual filter text is placed between <code type="inline">''</code> quotes.</li>
<li><code type="inline">jq_rkm.json</code> indicates that jq should read JSON from the file <code type="inline">jq_rkm.json</code>.</li>
<li><code type="inline">&gt; jq_rkm.csv</code> tells the command line to write jq's output into a file named <code type="inline">jq_rkm.csv</code>.</li>
</ol>
<p>Alternatively, you can use bash pipes to send text from the output of one function into jq.
This can be useful when downloading JSON with a utility like <code type="inline">wget</code> for retrieving online material.
(See <link target="/lessons/automated-downloading-with-wget">Automated Downloading with Wget</link> to learn the basics of this other command line program.)</p>
<pre><code class="language-sh" xml:id="code_json-and-jq_50" type="block" corresp="code_json-and-jq_50.txt"></code></pre>
<p>Note that you must use the <code type="inline">wget</code> flag <code type="inline">-qO-</code> in order to send the output of <code type="inline">wget</code> into <code type="inline">jq</code> by way of a shell pipe.
You can read more about command line pipes in <link target="/lessons/intro-to-bash">"Introduction to the Bash Command Line"</link> (OS X) or <link target="/lessons/intro-to-powershell.html">"Introduction to PowerShell"</link> (Windows).</p>
</div></div><div type="2"><head>Further Resources</head>
<p>jq is incredibly powerful, but its advanced features can get quite complicated.</p>
<p>It is possible to do <link target="https://stedolan.github.io/jq/manual/#Math">other basic math functions in jq</link>, however given the complexity of working with JSON's tree data model, I would suggest that it is only worth doing the most basic counting operations in jq.
If basic counting is all you need to do with your JSON data, then jq can help you avoid adding another tool onto your data analysis pipeline.
For more involved math, however, it would be more sensible to create table(s) with jq and then continue your analysis in Python, R, or even Excel.</p>
<p>If you are working with deeply-nested JSON (that is, many objects within objects), or JSON where objects have inconsistent structure, you may need to use features not covered in this lesson, including <link target="https://stedolan.github.io/jq/manual/#if-then-else">if-then-else statements</link>, <link target="https://stedolan.github.io/jq/manual/#Recursion">recursion</link>, and <link target="https://stedolan.github.io/jq/manual/#Reduce">reduction</link>.
If you can't figure out the filter you need to go from your given input to your desired output, using the tag <code type="inline">jq</code> over at <link target="http://stackoverflow.com/questions/tagged/jq">StackOverflow</link> can often get you a speedy answer.
Make sure that you try to <link target="http://stackoverflow.com/help/how-to-ask">follow best practices when describing your problem</link> and provide a <link target="http://stackoverflow.com/help/mcve">reproducible example</link>.</p>
</div></body>
  </text>
</TEI>
