<TEI xmlns="https://tei-c.org/ns/1-0/">
  <metadata>
  <title>Transformaci&#243;n de datos con XML y XSL para su reutilizaci&#243;n</title>
  <layout>lesson</layout>
  <slug>transformacion-datos-xml-xsl</slug>
  <date>2016-07-07</date>
  <translation_date>2018-08-02</translation_date>
  <authors>M. H. Beals</authors>
  <reviewers>Jonathan Blaney,Tessa C Hauswedell</reviewers>
  <translator>Antonio Rojas Castro</translator>
  <editors>Adam Crymble</editors>
  <translation-editor>Jos&#233; Antonio Motilla</translation-editor>
  <translation-reviewer>Pedro Carrillo,Jos&#233; Antonio Motilla</translation-reviewer>
  <difficulty>1</difficulty>
  <activity>transforming</activity>
  <topics>data-manipulation,data-visualization</topics>
  <review-ticket>https://github.com/programminghistorian/ph-submissions/issues/162</review-ticket>
  <original>transforming-xml-with-xsl</original>
  <abstract>Con este tutorial aprender&#225;s a convertir un conjunto de datos hist&#243;ricos procedentes de una base de datos XML (ya sea un solo documento o varios documentos interconectados) en otros formatos m&#225;s adecuados para presentar (tablas, listas) o exponer informaci&#243;n (p&#225;rrafos).</abstract>
  <avatar_alt>Dibujo de un pavo real con sus plumas extendidas.</avatar_alt>
  <doi>10.46430/phes0057</doi>
</metadata>
  <text xml:lang="es">
    <body><p class="alert alert-info" style="alert alert-info">
Debido a cambios recientes en las pol&#237;ticas de seguridad de los navegadores web, los cuales ya no pueden ejecutar c&#243;digo XSL de archivos locales, la aproximaci&#243;n original de esta lecci&#243;n ha tenido que ser replanteada. 
Esta lecci&#243;n fue actualizada en marzo de 2022 por Nicol&#225;s Vaughan.
</p>
<div type="2"><head>Introducci&#243;n</head>
<p>Imagina que, con un d&#237;a de antelaci&#243;n, un compa&#241;ero de trabajo te llama por tel&#233;fono pidi&#233;ndote que lo sustituyas en un seminario centrado en <emph>Relaciones de esclavos en el Nuevo Mundo</emph>. Decides recopilar una selecci&#243;n de fuentes primarias para trabajar en clase, encuentras algunas p&#225;ginas web y algunos libros con buenos materiales, pero escanearlo todo o copiar y pegar la informaci&#243;n en un documento nuevo conlleva demasiado tiempo; adem&#225;s, el estilo de la bibliograf&#237;a difiere y las citas son inconsistentes, as&#237; que empiezas a preguntarte si reunir todo este material tiene sentido. Una p&#225;gina web te permite descargar una versi&#243;n <link target="https://es.wikipedia.org/wiki/Extensible_Markup_Language">XML</link> de todo el material, pero son tantos los registros y hay tantos <link target="https://es.wikipedia.org/wiki/Metadatos">metadatos</link> que no es f&#225;cil encontrar r&#225;pidamente la informaci&#243;n que deseas.</p>
<p>O quiz&#225;s... has encontrado una edici&#243;n antigua de <emph>Inscriptions of Roman Tripolitania</emph> (1952) y te gustar&#237;a hacer un an&#225;lisis estad&#237;stico de la aparici&#243;n de ciertas frases en determinados contextos. Por suerte, King's College London ha publicado una <link target="https://irt.kcl.ac.uk/irt2009/">versi&#243;n digital del texto</link> con im&#225;genes, traducciones e informaci&#243;n sobre la localizaci&#243;n de las inscripciones. Puedes explorar el material con la funci&#243;n "Buscar en la p&#225;gina" en tu navegador, pero editar la informaci&#243;n en el formato necesario para el an&#225;lisis requiere tiempo.</p>
<p>Imagina ahora que est&#225;s empezando un proyecto nuevo consistente en el estudio de un cat&#225;logo de subastas de libros del siglo XVII; empiezas registrando los detalles de publicaci&#243;n y la lista de subastas en un documento Word o Excel. Un mes m&#225;s tarde el vicerrector de tu universidad te invita a dar una charla. El decano de tu facultad sugiere que hagas unas diapositivas o notas para facilitar la comprensi&#243;n del proyecto. Tienes ya algunas conclusiones preliminares, pero los datos est&#225;n dispersos en varios lugares y unificar el formato de la informaci&#243;n precisa m&#225;s tiempo del que dispones.</p>
<p>En las tres situaciones descritas, conocer c&#243;mo funciona XML y <link target="https://es.wikipedia.org/wiki/Extensible_Stylesheet_Language">XSL</link> te habr&#237;a ahorrado tiempo y esfuerzo.
En este tutorial aprender&#225;s a convertir un conjunto de datos hist&#243;ricos procedentes de una base de datos XML<ref type="footnotemark" target="#1"/> (ya sea un solo documento o varios documentos interconectados) en otros formatos m&#225;s adecuados para presentar (tablas, listas) o exponer informaci&#243;n (p&#225;rrafos). Tanto si quieres filtrar informaci&#243;n contenida en una base de datos como si quieres a&#241;adir encabezados o paginaci&#243;n, XSL ofrece a los historiadores la posibilidad de reconfigurar datos a fin de acomodarlos a los cambios de la investigaci&#243;n o a las necesidades de la publicaci&#243;n.</p>
<p>Este tutorial cubre los siguientes aspectos:</p>
<ul>
<li><hi rend="bold">Editores</hi>: herramientas necesarias para crear hojas de estilo XSL</li>
<li><hi rend="bold">Procesadores</hi>: herramientas necesarias para aplicar las instrucciones de la hoja de estilo XSL a los archivos XML</li>
<li><hi rend="bold">Elecci&#243;n y preparaci&#243;n de datos XML</hi>: c&#243;mo conectar la base de datos con las instrucciones de transformaci&#243;n XSL</li>
</ul>
<p>El tutorial tambi&#233;n sirve como gu&#237;a para crear las transformaciones m&#225;s comunes:</p>
<ul>
<li><hi rend="bold">Imprimir valores</hi>: c&#243;mo imprimir o presentar los datos</li>
<li><hi rend="bold">repeticiones <code type="inline">for-each</code> (en bucle)</hi>: c&#243;mo presentar datos concretos en cada uno de los objetos o registros existentes</li>
<li><hi rend="bold">Ordenar resultados</hi>: c&#243;mo presentar los datos en un determinado orden</li>
<li><hi rend="bold">Filtrar resultados</hi>: c&#243;mo seleccionar qu&#233; objetos o registros se quieren presentar</li>
</ul>
</div><div type="2"><head>&#191;Qu&#233; es XML?</head>
<p>El Lenguaje de Marco Extensible (<emph>eXtensible Markup Language</emph>, abreviado generalmente como "XML") es un m&#233;todo muy flexible de codificaci&#243;n y estructuraci&#243;n de datos. Al contrario que el Lenguaje de Marcado de Hipertexto (<link target="https://es.wikipedia.org/wiki/HTML">Hypertext Markup Language</link>, abreviado como "HTML"), que tiene un vocabulario predeterminado, XML es extensible; es decir, puede expandirse para incluir las etiquetas necesarias para, por ejemplo, identificar tantas secciones y subsecciones como quieras.</p>
<p>Una base de datos puede componerse de uno o m&#225;s documentos XML con una estructura b&#225;sica. Cada secci&#243;n del archivo est&#225; contenida en un <link target="https://developer.mozilla.org/es/docs/Glossary/Element">elemento</link>, es decir, una categor&#237;a o nombre con el que se identifica el tipo de datos manejados. As&#237; pues, como si fueran <link target="https://es.wikipedia.org/wiki/Matrioshka">Matrioshkas</link>, cada nivel de elementos est&#225; contenido en otro.
El elemento <code type="inline">&lt;ra&#237;z&gt;</code> es precisamente eso: la <emph>ra&#237;z</emph> del documento, es decir, el elemento que contiene al resto de elementos y entidades; y cada uno de estos otros elementos contenidos en &#233;l se considera un <emph>hijo</emph> (<emph>child</emph>) suyo.
An&#225;logamente, el elemento que contiene un elemento hijo se llama elemento <emph>padre</emph> (<emph>parent</emph>).
Por ejemplo:</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_0" type="block" corresp="code_transformacion-datos-xml-xsl_0.txt"></code></pre>
<p>(Nota que estos nombres &#8212;<code type="inline">ra&#237;z</code>, <code type="inline">padre</code> y <code type="inline">hijo</code>&#8212; son completamente arbitrarios. Pudimos haberlos llamado de cualquier otro modo. Lo importante aqu&#237; son las relaciones de continencia.)</p>
<p>Seg&#250;n las reglas de nuestra base de datos, los elementos pueden tener valores (textuales o num&#233;ricos) o bien un n&#250;mero determinado de elementos hijos.</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_1" type="block" corresp="code_transformacion-datos-xml-xsl_1.txt"></code></pre>
<p>Tambi&#233;n pueden tener <link target="https://developer.mozilla.org/es/docs/Glossary/Attribute">atributos</link>, algo as&#237; como los metadatos del elemento. Los atributos ayudan a distinguir, por ejemplo, entre distintos tipos de valores sin tener que crear un nuevo tipo de elemento.
Por ejemplo:</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_2" type="block" corresp="code_transformacion-datos-xml-xsl_2.txt"></code></pre>
<p>Si tienes acceso a una base de datos XML, o si quieres almacenar datos en una, puedes utilizar XSL para ordenar, filtrar y presentar la informaci&#243;n en (casi) todas las maneras imaginables.
Por ejemplo, podr&#237;as abrir un archivo XML como Word (.docx) o Excel (.xslx), inspeccionarlo y, a continuaci&#243;n, eliminar la informaci&#243;n a&#241;adida por Microsoft por defecto como la localizaci&#243;n geogr&#225;fica del creador del documento.
Si quieres saber m&#225;s sobre XML, te recomendamos leer una explicaci&#243;n m&#225;s detallada sobre su estructura y uso en las humanidades en la p&#225;gina web de la <link target="https://tei-c.org/release/doc/tei-p5-doc/en/html/SG.html">Text Encoding Initiative</link>.</p>
</div><div type="2"><head>&#191;Qu&#233; es XSL?</head>
<p>El Lenguaje de Hojas de Estilo Extensibles (<emph>eXtensible Stylesheet Language</emph>, abreviado como "XSL") es el complemento natural de XML.
En t&#233;rminos generales, proporciona instrucciones de procesamiento;
en cierto modo, podr&#237;amos decir que XSL es an&#225;logo a las <link target="https://es.wikipedia.org/wiki/Hoja_de_estilos_en_cascada">Hojas de Estilos en Cascada</link> (<emph>Cascading Stylesheets</emph>, abreviado "CSS") necesarias para presentar archivos HTML.
Ambos lenguajes permiten transformar el texto plano en un formato de texto enriquecido, as&#237; como determinar su dise&#241;o y apariencia tanto en pantalla como impreso, sin tener que alterar los archivos originales. En un nivel m&#225;s avanzado, tambi&#233;n permiten ordenar y filtrar la informaci&#243;n seg&#250;n un criterio concreto y crear o visualizar otros datos derivados a partir del archivo original.</p>
<p>Al separar los datos (XML) de las instrucciones de procesamiento (XSL), es posible refinar y modificar la presentaci&#243;n sin correr el riesgo de corromper la estructura de los archivos. Asimismo, podemos crear m&#225;s de una <emph>hoja de estilo</emph>, de tal modo que se utilicen en funci&#243;n del objetivo para transformar un solo archivo fuente.
En la pr&#225;ctica, esto significa que solo hay que actualizar los datos en un solo lugar y luego exportar distintos documentos.<ref type="footnotemark" target="#A1"/></p>
</div><div type="2"><head>Algunos programas necesarios o recomendados</head>
<div type="3"><head>Editores de texto</head>
<p>Una de las ventajas de guardar datos en formato de texto plano es la facilidad de encontrar programas para visualizarlos y manipularlos. Para los prop&#243;sitos de este tutorial, recomendamos utilizar el editor <link target="https://code.visualstudio.com/">Visual Studio Code</link> (que abreviaremos aqu&#237; como "VSCode"),
aunque cualquier otro editor para programaci&#243;n puede servir para este tutorial (Notepad++, Atom, Emacs, Vim, etc.).
VSCode es un editor gratuito y de c&#243;digo abierto.
Mantiene el formato de texto plano, pero ofrece esquemas de colores distintos (verde sobre negro o marr&#243;n sobre beige), as&#237; como la funci&#243;n de esconder secciones o de comentar trozos de c&#243;digo para desactivarlo de manera temporal. </p>
<p>Para los usuarios m&#225;s avanzados, que precisen realizar transformaciones de naturaleza compleja, se recomienda el uso del <link target="https://www.oxygenxml.com/">Oxygen XML Editor</link>, si bien no es ni gratuito ni de c&#243;digo abierto.</p>
</div><div type="3"><head>Procesadores de XSL</head>
<p>Tras instalar VSCode en el sistema, hace falta instalar un <emph>procesador de XSL</emph>.
Hay tres maneras de utilizar una hoja de estilo para transformar documentos XML:</p>
<ul>
<li>mediante un navegador web, que incluye un procesador XSL b&#225;sico;</li>
<li>mediante un procesador XSL incluido en un editor de XML; o</li>
<li>mediante un procesador XSL independiente, que se corre desde la l&#237;nea de comandos (o como un <emph>binding</emph> desde otro lenguaje de programaci&#243;n).</li>
</ul>
<p>Hasta hace poco, la primera opci&#243;n habr&#237;a sido la m&#225;s c&#243;moda para aprender a trabajar con XSL.
Sin embargo, los navegadores web han introducido restricciones de seguridad que hacen m&#225;s dif&#237;cil la transformaci&#243;n y el procesamiento de documentos XML locales.
A fin de evitar este problema, podr&#237;as instalar complementos (<emph>addons</emph>) en Google Chrome o en Mozilla Firefox, o modificar directamente sus pol&#237;ticas de seguridad, para permitir que se corran las transformaciones.
Sin embargo, esto tiene el inconveniente de hacer vulnerable el navegador a ciertos tipos de ataque inform&#225;tico.
Por esta raz&#243;n, evitaremos tomar este camino.</p>
<p>La segunda opci&#243;n requiere la instalaci&#243;n de un editor especializado como Oxygen XML Editor o Altova XMLSpy.
Sin embargo, puesto que no son editores gratuitos ni de c&#243;digo abierto, tampoco tomaremos este camino aqu&#237;.</p>
<p>Nos queda la tercera opci&#243;n.
Utilizaremos un procesador XSL gratuito y de c&#243;digo abierto llamado <link target="https://www.saxonica.com/download/java.xml">Saxon-HE</link>, desarrollada por Michael Kay, uno de los especialistas m&#225;s renombrados en el campo de XML, XSL, XPath, XQuery y tecnolog&#237;as relacionadas.
Saxon-HE es la versi&#243;n "casera" (<emph>Home Edition</emph>) del procesador XSL Saxon.
<link target="https://www.saxonica.com/">Saxonica</link>, la casa de software de Michael Kay, tambi&#233;n tiene para la venta ediciones del procesador Saxon mucho m&#225;s potentes, adecuadas para proyectos gran envergadura y requisitos t&#233;cnicos.
Sin embargo, para nuestros fines &#8212;y de hecho para la gran mayor&#237;a de proyectos que requieren transformaci&#243;n de XML por medio de XSLT&#8212;, la edici&#243;n Saxon-HE es m&#225;s que suficiente.</p>
<div type="4"><head>Instalaci&#243;n de Saxon-HE</head>
<p>Saxon-HE es una aplicaci&#243;n de Java (de hecho, su nombre t&#233;cnico completo es "SaxonJ-HE").
Eso significa que tu sistema operativo debe tener instalada una m&#225;quina virtual de Java (Java Virtual Machine o Java VM) para poder ejecutar Saxon-HE.
La versi&#243;n 11 de Saxon-HE, a la fecha la &#250;ltima, requiere por lo menos la versi&#243;n Java SE 8 (JDK 1.8).
Debes asegurarte de que est&#233; instalada en tu sistema.
Si no lo est&#225;, deber&#225;s instalarla t&#250; mismo.</p>
<p>Para verificar si ya lo est&#225;, deber&#225;s usar la l&#237;nea de comandos de tu sistema operativo.
Para ello, abre tu emulador de terminal (en adelante, el "terminal").
Si est&#225;s en Microsoft Windows, puedes usar para ello o bien <link target="https://docs.microsoft.com/es-es/powershell/">PowerShell</link> o bien <link target="https://git-scm.com/downloads">Git Bash</link>.
Si est&#225;s en Mac OS, puedes usar la aplicaci&#243;n <link target="https://support.apple.com/guide/terminal/welcome/mac">Terminal.app</link> (incluida por defecto en el sistema).
Y si est&#225;s en Linux, puedes usar cualquiera de los terminales instalados por defecto.</p>
<p>Si est&#225;s en Windows, escribe ahora el siguiente comando en tu terminal:</p>
<pre><code class="language-sh" xml:id="code_transformacion-datos-xml-xsl_3" type="block" corresp="code_transformacion-datos-xml-xsl_3.txt"></code></pre>
<p>En MacOS y Linux deber&#225;s escribir lo siguiente:</p>
<pre><code class="language-sh" xml:id="code_transformacion-datos-xml-xsl_4" type="block" corresp="code_transformacion-datos-xml-xsl_4.txt"></code></pre>
<p>(f&#237;jate en el doble gui&#243;n <code type="inline">--</code>).</p>
<p>Si Java no est&#225; instalado, ver&#225;s un mensaje de error como el siguiente:</p>
<pre><code class="language-sh" xml:id="code_transformacion-datos-xml-xsl_5" type="block" corresp="code_transformacion-datos-xml-xsl_5.txt"></code></pre>
<p>Pero si Java s&#237; est&#225; instalado, obtendr&#225;s algo como esto:</p>
<pre><code class="language-sh" xml:id="code_transformacion-datos-xml-xsl_6" type="block" corresp="code_transformacion-datos-xml-xsl_6.txt"></code></pre>
<p>Ahora bien, si la versi&#243;n de Java es inferior a 1.8, o si simplemente no est&#225; instalado, deber&#225;s bajar e instalar la versi&#243;n m&#225;s reciente.
Para ello, ve a la p&#225;gina oficial de descargas de Java, <link target="https://www.java.com/es/download/">https://www.java.com/es/download/</link>, y baja la versi&#243;n apropiada a nuestro sistema operativo.
Luego de instalarla, deber&#225;s reiniciar tu computador a fin de que las variables globales, que le informan al sistema d&#243;nde est&#225; el ejecutable de Java, hayan sido correctamente aplicadas.
Hecho esto, verifica de nuevo en la l&#237;nea de comandos la versi&#243;n de Java.
(Si ya has instalado la versi&#243;n m&#225;s reciente y con todo te aparece un mensaje de error indicando que no est&#225; instalada, deber&#225;s ajustar manualmente la variable <code type="inline">PATH</code> en tu  sistema.
Para ello, revisa <link target="https://stackoverflow.com/questions/16811332/cannot-run-java-from-the-windows-powershell-command-prompt">esta explicaci&#243;n</link>.)</p>
<p>A continuaci&#243;n deber&#225;s descargar e instalar Saxon-HE.
Puede bajarlo del repositorio de SourceForge de Saxonica en esta direcci&#243;n:
<link target="https://sourceforge.net/projects/saxon/files/Saxon-HE/11/Java/">https://sourceforge.net/projects/saxon/files/Saxon-HE/11/Java/</link>
Busca en la lista la versi&#243;n m&#225;s reciente.
(A la fecha de hoy esta es la versi&#243;n 11.2.)
Descarga entonces el archivo <code type="inline">SaxonHE11-2J.zip</code> (o el m&#225;s reciente) y descompr&#237;melo en alguna carpeta de tu equipo. (No olvides d&#243;nde qued&#243;.)
Ahora abre el terminal ah&#237; mismo y ejecuta el siguiente comando (ten en cuenta que el nombre del ejecutable &#8212;<code type="inline">saxon-he-11.2.jar</code>&#8212; puede ser diferente para ti):</p>
<pre><code class="language-sh" xml:id="code_transformacion-datos-xml-xsl_7" type="block" corresp="code_transformacion-datos-xml-xsl_7.txt"></code></pre>
<p>(el par&#225;metro <code type="inline">-t</code> le dice a Saxon que muestre su versi&#243;n, as&#237; como otra informaci&#243;n &#250;til). </p>
<p>Por ejemplo, en Windows obtendr&#225;s:</p>
<pre><code class="language-sh" xml:id="code_transformacion-datos-xml-xsl_8" type="block" corresp="code_transformacion-datos-xml-xsl_8.txt"></code></pre>
<p>Ahora bien, dado que hemos descomprimido Saxon en una carpeta cualquiera (en <code type="inline">C:\Users\usuario\Downloads</code>, en nuestro ejemplo), solo podremos correr Saxon desde ah&#237;.
Esto quiere decir que si estamos en otra carpeta en nuestro sistema, no podremos correr simplemente la instrucci&#243;n <code type="inline">java -jar saxon-he-11.2.jar</code> para empezar a trabajar, puesto que el ejecutable <code type="inline">saxon-he-11.2.jar</code> no estar&#225; disponible ah&#237;.
Esto no es necesariamente un problema.
Tan solo debes asegurarte de que los documentos XML y XSL que vayas a utilizar en tus transformaciones se encuentren siempre <emph>en la misma carpeta</emph> del ejecutable de Saxon.
Los ejemplos de c&#243;digo de l&#237;nea de comandos que mostraremos aqu&#237; presupondr&#225;n que tal es el caso.<ref type="footnotemark" target="#A2"/></p>
</div></div></div><div type="2"><head>C&#243;mo elegir y preparar datos en XML</head>
<p>Para empezar a transformar un documento XML, primero es necesario obtener un archivo <emph>bien formado</emph>.<ref type="footnotemark" target="#2"/>
Muchas bases de datos hist&#243;ricas disponibles en l&#237;nea est&#225;n modeladas en XML y, a veces, ofrecen sus datos en abierto.
Para realizar este tutorial utilizaremos la base de datos <link target="http://www.scissorsandpaste.net">Scissors and Paste</link>.</p>
<p>La base de datos <emph>Scissors and Paste</emph> es una colecci&#243;n colaborativa, en continuo crecimiento, que contiene noticias procedentes de peri&#243;dicos brit&#225;nicos e imperiales de los siglos XVIII y XIX. Los dos objetivos originales del proyecto eran facilitar la comparaci&#243;n de reediciones aparecidas en distintos peri&#243;dicos y detectar temas similares en distintas publicaciones inglesas. Como muchas bases de datos XML, <emph>Scissors and Paste</emph> contiene datos (el texto), informaci&#243;n sobre el formato (como las cursivas o las justificaci&#243;n de los p&#225;rrafos) y metadatos.<ref type="footnotemark" target="#3"/>
Los metadatos recogen la paginaci&#243;n de la noticia, la fecha de impresi&#243;n, algunos detalles adicionales sobre el peri&#243;dico, los temas principales y una lista con las personas y lugares mencionados.</p>
<p>En 2015, la base de datos alcanz&#243; las 350 noticias con metadatos. Aunque quiz&#225;s algunos investigadores quieran acceder a toda la informaci&#243;n, la mayor&#237;a est&#225;n interesados en una porci&#243;n de los datos como el a&#241;o de publicaci&#243;n o el tema principal de la noticia. Gracias al uso de XSL, es posible filtrar la informaci&#243;n innecesaria u ordenar el material de un modo que sea m&#225;s &#250;til para investigar. Por ejemplo, como imagin&#225;bamos en la introducci&#243;n, quiz&#225;s nos ser&#237;a de utilidad preparar una lista de publicaciones o bien una tabla con las fechas, los t&#237;tulos y la paginaci&#243;n de las noticias humor&#237;sticas contenidas en la base de datos. En ambos casos, podemos obtener los resultados sin muchos problemas utilizando hojas de estilo XSL. </p>
<p>Para empezar a trabajar con la base de datos <emph>Scissors and Paste</emph>, descarga el archivo <link target="/assets/transforming-xml-with-xsl/master.zip"><code type="inline">master.zip</code></link>.
Descomprime el archivo ZIP para obtener la carpeta llamada <code type="inline">scissorsandpaste-master</code>.
Puedes descomprimirlo haciendo doble clic desde el explorador de archivos (en Windows, MacOS o Linux) o usando un programa especial para ello.</p>
<p>La carpeta contiene tres &#237;tems principales:</p>
<ul>
<li>el archivo <code type="inline">TEISAP.XML</code>: la base de datos XML</li>
<li>la carpeta <code type="inline">Transformers</code>: una colecci&#243;n de hojas de estilo XSL</li>
<li>la carpeta <code type="inline">Outputs</code>: archivos derivados de la base de datos mediante las hojas de estilo XSL</li>
</ul>
<p>Tambi&#233;n encontrar&#225;s ah&#237; los siguientes documentos:</p>
<ul>
<li>el archivo <code type="inline">Template_TEISAP.xml</code>, una plantilla para los investigadores que quieran contribuir con m&#225;s noticias</li>
<li>el archivo <code type="inline">README.md</code> con informaci&#243;n sobre la base de datos</li>
<li>el archivo <code type="inline">cite.md</code> que explica c&#243;mo citar la base de datos</li>
<li>el archivo <code type="inline">license.md</code> con los t&#233;rminos de uso</li>
</ul>
<p>Al finalizar este tutorial, te recomendamos explorar las otras hojas de estilo XSL contenidas en la carpeta <code type="inline">Transformers</code> y los archivos generados con ellas; de esta manera podr&#225;s descubrir otras posibilidades y crear archivos adaptados a tus necesidades.</p>
<p>La informaci&#243;n contenida en el archivo <code type="inline">TEISAP.XML</code> ha sido codificada seg&#250;n las recomendaciones de la <link target="https://tei-c.org/">Text-Encoding Initiative</link> (TEI), gran parte de la cual corresponde a los metadatos.</p>
<p>Sin embargo, en este tutorial utilizaremos una versi&#243;n simplificada que cubre los datos hist&#243;ricos m&#225;s importantes.<ref type="footnotemark" target="#4"/>
Deber&#225;s descargar el archivo
<link target="/assets/transforming-xml-with-xsl/SAPsimple_es.xml"><code type="inline">SAPsimple_es.xml</code></link>.
Haz una copia de &#233;l en la misma carpeta donde antes hab&#237;as descomprimido el ejecutable de Saxon.
Ahora &#225;brelo en el editor VSCode y examina su contenido.</p>
<figure><desc>Figura 1: Una primera mirada a un documento XML</desc><graphic url="transformacion-datos-xml-xsl-1.png"/></figure>
<p>La primera l&#237;nea del archivo XML es la siguiente:</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_9" type="block" corresp="code_transformacion-datos-xml-xsl_9.txt"></code></pre>
<p>Esta l&#237;nea indica la versi&#243;n de XML utilizada (1.0) y el m&#233;todo de codificaci&#243;n del texto (<link target="https://es.wikipedia.org/wiki/UTF-8">UTF-8</link>). En la segunda l&#237;nea se encuentra la etiqueta de apertura <code type="inline">&lt;ra&#237;z&gt;</code> y, al final, la etiqueta de cierre <code type="inline">&lt;/ra&#237;z&gt;</code>.
Esto quiere decir que <code type="inline">&lt;ra&#237;z&gt;</code>, como su nombre lo indica, es el elemento ra&#237;z que contiene todos los art&#237;culos de peri&#243;dicos, cada uno etiquetado con un elemento <code type="inline">&lt;registro&gt;</code>. Antes de continuar, ubica la etiqueta de cierre <code type="inline">&lt;/registro&gt;</code>.</p>
<p>Dentro de cada registro hay varios elementos hijos. La Text Encoding Initiative permite anidar centenares de elementos para modelar datos de muy distinta naturaleza. Adem&#225;s, la gracia de XML es que puedes dar nombre a tus elementos nuevos con <link target="https://www.w3schools.com/xml/xml_elements.asp">bastante libertad</link>. En la base de datos <emph>Scissors and Paste</emph> cada registro contiene los siguientes elementos:</p>
<ul>
<li><code type="inline">&lt;identificador&gt;</code>: n&#250;mero de identificaci&#243;n del registro</li>
<li><code type="inline">&lt;t&#237;tulo&gt;</code>: t&#237;tulo del peri&#243;dico</li>
<li><code type="inline">&lt;ciudad&gt;</code>: ciudad del peri&#243;dico</li>
<li><code type="inline">&lt;provincia&gt;</code>: provincia o regi&#243;n del peri&#243;dico</li>
<li><code type="inline">&lt;pa&#237;s&gt;</code>: pa&#237;s del peri&#243;dico</li>
<li><code type="inline">&lt;fecha&gt;</code>: fecha del art&#237;culo en formato ISO<ref type="footnotemark" target="#5"/></li>
<li><code type="inline">&lt;a&#241;o&gt;</code>: a&#241;o de la publicaci&#243;n</li>
<li><code type="inline">&lt;mes&gt;</code>: mes de la publicaci&#243;n</li>
<li><code type="inline">&lt;d&#237;a&gt;</code>: d&#237;a de la publicaci&#243;n</li>
<li><code type="inline">&lt;secci&#243;nPalabrasClave&gt;</code>: secci&#243;n que contiene las palabras claves</li>
<li><code type="inline">&lt;palabraClave&gt;</code>: palabra clave que describe el art&#237;culo</li>
<li><code type="inline">&lt;titular&gt;</code>: titular del art&#237;culo (opcional)</li>
<li><code type="inline">&lt;texto&gt;</code>: secci&#243;n que contiene el art&#237;culo</li>
<li><code type="inline">&lt;p&gt;</code>: p&#225;rrafo de texto</li>
</ul>
<p>Tal es, pues, la tipolog&#237;a de datos que utilizaremos para crear otros archivos derivados.</p>
</div><div type="2"><head>C&#243;mo crear y probar tus hojas de estilo XSL</head>
<p>Ha llegado la hora de crear una archivo XSL para transformar el documento XML.
Para ello, abre el editor VSCode, crea un archivo nuevo en blanco y gu&#225;rdalo con el nombre <code type="inline">miestilo.xsl</code>.
De nuevo, aseg&#250;rate de que el archivo se haya guardado en el mismo directorio que contiene tanto el archivo <code type="inline">SAPsimple_es.xml</code> como el ejecutable de Saxon.</p>
<p>La primeras tres l&#237;neas de tu archivo XSL ser&#225;n las siguientes:</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_10" type="block" corresp="code_transformacion-datos-xml-xsl_10.txt"></code></pre>
<p>La primera l&#237;nea declara que este es un documento XML versi&#243;n 1.0, codificado como UTF-8.
(&#161;Nota que un documento XSL es en &#250;ltimas un tipo especial de documento XML!)
La segunda l&#237;nea declara que se trata de la versi&#243;n 1.0 de XSL y que el uso del <link target="https://es.wikipedia.org/wiki/Espacio_de_nombres_XML">espacio de nombres</link> (<emph>namespace</emph>, en ingl&#233;s) es el est&#225;ndar establecido por el <link target="http://www.w3.org/">Consorcio World Wide Web</link>, cuya URI (<emph>Uniform Resource Identifier</emph>) figura en la instrucci&#243;n.
Finalmente, la tercera l&#237;nea le indica al procesador XSL que queremos generar un archivo de texto plano.
(Tambi&#233;n podr&#237;as haber puesto <code type="inline">xml</code> o <code type="inline">html</code>, en lugar de <code type="inline">text</code>, para generar un documento XML o uno HTML, respectivamente.)</p>
<p>Cada vez que se abre un <code type="inline">&lt;elemento&gt;</code>, es necesario cerrarlo con la etiqueta <code type="inline">&lt;/elemento&gt;</code> (comoquiera que se llame).
De lo contrario, se producir&#225; un error de sintaxis y el archivo no ser&#225; bien formado.
Por lo tanto, a&#241;ade ahora la siguiente l&#237;nea al final de tu hoja de estilos XSL:</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_11" type="block" corresp="code_transformacion-datos-xml-xsl_11.txt"></code></pre>
<p>La siguiente parte de tu hoja de estilo XSL ser&#225; la plantilla principal &#8212;las instrucciones de formato&#8212; para tu <emph>output</emph>.
En una l&#237;nea nueva, inmediatamente despu&#233;s de <code type="inline">&lt;xsl:output method="text"/&gt;</code>, escribe</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_12" type="block" corresp="code_transformacion-datos-xml-xsl_12.txt"></code></pre>
<p>Dentro de estas dos etiquetas pondr&#225;s todas las instrucciones relativas al formato deseado.</p>
<p>El valor del atributo <code type="inline">match</code> (que puede traducirse como "hacer coincidir" o "emparejar") contiene una barra <code type="inline">/</code>, porque queremos que la instrucci&#243;n se aplique a <emph>todo el contenido</emph> del documento XML.
Podr&#237;amos haber escrito en su lugar <code type="inline">ra&#237;z</code> para indicar que solo queremos utilizar los datos contenidos en el elemento <code type="inline">&lt;ra&#237;z&gt;</code>.
Sin embargo, esto podr&#237;a crear algunos problemas, as&#237; que es mejor que usemos la barra <code type="inline">/</code> en la instrucci&#243;n principal.</p>
<p>Tras esto, tu archivo <code type="inline">miestilo.xsl</code> deber&#237;a tener este aspecto:</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_13" type="block" corresp="code_transformacion-datos-xml-xsl_13.txt"></code></pre>
<p>Guarda tu archivo. En lo que sigue, aseg&#250;rate de guardarlo antes de correr cualquier transformaci&#243;n nueva.</p>
<p>Dentro de la instrucci&#243;n que acabamos de crear, escribe <code type="inline">&lt;xsl:value-of select="ra&#237;z"/&gt;</code>. No es necesario introducir una l&#237;nea nueva, ni tampoco sangrarla a la derecha; pero si lo haces, ser&#225; m&#225;s f&#225;cil de leer.
Te habr&#225;s dado cuenta de que no hemos incluido una etiqueta de cierre <code type="inline">&lt;/xsl:value-of&gt;</code>; esto se debe a que la instrucci&#243;n <code type="inline">&lt;xsl:value-of select="ra&#237;z"/&gt;</code> no tiene contenido y ya est&#225; "auto-cerrada" gracias a la barra <code type="inline">/</code> situada al final.</p>
<p>Tu archivo <code type="inline">miestilo.xsl</code> deber&#225; verse as&#237;:</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_14" type="block" corresp="code_transformacion-datos-xml-xsl_14.txt"></code></pre>
<p>Ahora vamos a transformar nuestro documento XML <code type="inline">SAPsimple_es.xml</code> en texto plano, utilizando el la hoja de estilos XSL que acabamos de crear.
Para ello, ub&#237;cate en la l&#237;nea de comandos y ejecuta esto:</p>
<pre><code class="language-sh" xml:id="code_transformacion-datos-xml-xsl_15" type="block" corresp="code_transformacion-datos-xml-xsl_15.txt"></code></pre>
<p>Al ejecutar este comando, ver&#225;s una gran cantidad de texto desplegarse en el terminal, tanto que no es f&#225;cil leerlo ah&#237; mismo.
El par&#225;metro <code type="inline">-xsl:</code> proporciona el nombre de la hoja de estilos XSL que ser&#225; utilizada para transformar el documento XML, cuyo nombre es proporcionado por el par&#225;metro <code type="inline">-s:</code> (de <emph>source</emph>, "fuente").
Si quieres guardar el texto que Saxon ha arrojado, debes usar el par&#225;metro <code type="inline">-o:</code> (de <emph>output</emph>, "salida"), seguido de un nombre de archivo, por ejemplo as&#237;:</p>
<pre><code class="language-sh" xml:id="code_transformacion-datos-xml-xsl_16" type="block" corresp="code_transformacion-datos-xml-xsl_16.txt"></code></pre>
<p>(Ese ser&#225; siempre el comando que debes correr en el terminal para transformar un XML por medio de una hoja de estilos XSLT. Deber&#225;s ejecutarlo <emph>cada vez</emph> que quieras realizar una transformaci&#243;n. En otras palabras, no bastar&#225; con que hagas cambios en tu hoja de estilos para que se produzca la transformaci&#243;n; siempre deber&#225;s ejecutar Saxon para llevarla a cabo.)</p>
<p>Ahora puedes abrir el archivo <emph>salida.txt</emph> en VSCode para inspeccionarlo.
El resultado deber&#237;a ser el texto con los saltos de l&#237;nea existentes, pero <emph>sin</emph> los elementos XML, tal como se percibe en la siguiente imagen:</p>
<figure><desc>Figura 2: Salida del texto inicial</desc><graphic url="transformacion-datos-xml-xsl-2.png"/></figure>
</div><div type="2"><head>C&#243;mo poblar los resultados de tus transformaciones</head>
<p>La l&#237;nea de c&#243;digo <code type="inline">&lt;xsl:value-of select="ra&#237;z"/&gt;</code> selecciona e imprime la base de datos entera en formato de texto plano y la arroja como salida de la transformaci&#243;n. Si examinas los componentes de la l&#237;nea, sabr&#225;s por qu&#233;:</p>
<ul>
<li>
<p><code type="inline">xsl:value-of</code>: sirve para seleccionar e imprimir el valor de un elemento, es decir, el <emph>texto</emph> contenido entre la etiqueta de inicio y de cierre.</p>
</li>
<li>
<p><code type="inline">select="ra&#237;z"</code>: indica el nombre del elemento que deber&#237;a seleccionarse e imprimirse; en este caso, este elemento la ra&#237;z del documento XML, que incidentalmente se llama aqu&#237; <code type="inline">&lt;ra&#237;z&gt;</code> (aunque pudo haberse llamado de cualquier otro modo).
A menos que declares lo contrario, si apuntas hacia un elemento padre, el procesador tambi&#233;n seleccionar&#225; el contenido de los todos elementos que est&#233;n en &#233;l.
Por lo tanto, al apuntar al elemento <code type="inline">&lt;ra&#237;z&gt;</code>, obtenemos el texto contenido en los elementos <code type="inline">&lt;identificador&gt;</code>, <code type="inline">&lt;t&#237;tulo&gt;</code>, etc.
(T&#233;cnicamente hablando <code type="inline">select</code> es un <emph>atributo</emph> del elemento <code type="inline">&lt;xsl:value-of&gt;</code>, y el <emph>valor</emph> de ese atributo es <code type="inline">ra&#237;z</code> aqu&#237;.)</p>
</li>
</ul>
</div><div type="2"><head>C&#243;mo seleccionar e imprimir valores</head>
<p>Si quieres seleccionar e imprimir el valor de un cierto elemento, sustituye el nombre <code type="inline">ra&#237;z</code> por el del elemento que quieras. Intent&#233;moslo.
En la hoja de estilos XSL, reemplaza <code type="inline">ra&#237;z</code> por <code type="inline">t&#237;tulo</code> en la l&#237;nea apropiada, as&#237;:</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_17" type="block" corresp="code_transformacion-datos-xml-xsl_17.txt"></code></pre>
<p>Guarda el archivo, ejecuta de nuevo el comando de transformaci&#243;n en el terminal y examina el resultado en VSCode.
(VSCode autom&#225;ticamente refrescar&#225; la ventana cada vez que detecta que un archivo ha sido actualizado.)</p>
<p>&#191;No funcion&#243;? Eso es porque el procesador XSL no sabe d&#243;nde ubicar los elementos <code type="inline">&lt;t&#237;tulo&gt;</code>. Veamos por qu&#233;.</p>
<div type="3"><head>Padres e hijos</head>
<p>El elemento <code type="inline">&lt;t&#237;tulo&gt;</code> no est&#225; situado en el nivel m&#225;s alto de la jerarqu&#237;a, as&#237; que debemos explicarle al procesador c&#243;mo llegar hasta el elemento que queremos.
El lenguaje con que se hace esto se conoce como <link target="https://es.wikipedia.org/wiki/XPath">XPATH</link> y funciona de una manera similar al modo como se estructuran las rutas de las carpetas en un computador.
Sustituye <code type="inline">t&#237;tulo</code> por <code type="inline">ra&#237;z/registro/t&#237;tulo</code>. La hoja de estilos XSL quer&#237;a entonces as&#237;:</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_18" type="block" corresp="code_transformacion-datos-xml-xsl_18.txt"></code></pre>
<p>Gu&#225;rdala, corre la transformaci&#243;n y examina el resultado en VSCode de nuevo.</p>
<p>Ahora deber&#237;as obtener "Caledonian Mercury", es decir, el t&#237;tulo del primer registro en el documento XML.
Sin embargo, tenemos m&#225;s de 300 elementos <emph>t&#237;tulo</emph>.
&#191;Qu&#233; ha ocurrido?
Es muy sencillo: como no hemos especificado cu&#225;l t&#237;tulo quer&#237;amos imprimir, el procesador ha asumido que solo nos interesaba el primero. Una vez lo selecciona y lo imprime, se detiene.<ref type="footnotemark" target="#A3"/></p>
</div><div type="3"><head>Bucles con <code type="inline">for-each</code></head>
<p>Para un ser humano quiz&#225;s parezca normal querer el contenido de <emph>todos</emph> los elementos <code type="inline">&lt;t&#237;tulo&gt;</code> en la base de datos XML, pero el procesador no sabe esto por defecto.
Para remediar la situaci&#243;n, debemos repetir la operaci&#243;n una y otra vez por medio de un <emph>bucle <code type="inline">for</code></emph>.
Adem&#225;s de seleccionar todos y cada uno de los elementos, los bucles <code type="inline">for</code> nos permiten controlar con mucha precisi&#243;n c&#243;mo hacer esto.
El bucle le indica al procesador XSL que debe procesar todo el documento XML y llevar a cabo la transformaci&#243;n indicada cada vez que una cierta condici&#243;n sea se cumpla.</p>
<p>As&#237; pues, crea una nueva l&#237;nea despu&#233;s de <code type="inline">&lt;xsl:template match="/"&gt;</code> e inserta <code type="inline">&lt;xsl:for-each select="ra&#237;z/registro"&gt;</code>. Esta instrucci&#243;n le indica al procesador que para cada elemento <code type="inline">&lt;registro&gt;</code> situado dentro del elemento <code type="inline">&lt;ra&#237;z&gt;</code> debe realizar una determinada acci&#243;n.</p>
<p>A continuaci&#243;n, elimina <code type="inline">ra&#237;z/registro</code> del valor del atributo <code type="inline">@select</code> en el elemento <code type="inline">&lt;xsl:value-of&gt;</code> y deja solo <code type="inline">t&#237;tulo</code>.
La raz&#243;n de esto es que ya estamos adentro del contexto <code type="inline">ra&#237;z/registro</code> (cuando lo seleccionamos con el elemento <code type="inline">&lt;xsl:for-each select="ra&#237;z/registro"&gt;</code>)
Tras <code type="inline">&lt;xsl:value-of&gt;</code>, hay que terminar la operaci&#243;n con la etiqueta de cierre <code type="inline">&lt;/xsl:for-each&gt;</code>.</p>
<p>El archivo resultante ser&#225; el siguiente:</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_19" type="block" corresp="code_transformacion-datos-xml-xsl_19.txt"></code></pre>
<p>Ahora el elemento <code type="inline">&lt;xsl:template&gt;</code> contiene tres l&#237;neas de c&#243;digo:</p>
<ol>
<li>una etiqueta de inicio para el bucle</li>
<li>una instrucci&#243;n para seleccionar un <code type="inline">&lt;t&#237;tulo&gt;</code> e imprimir su contenido</li>
<li>una etiqueta de cierre para el bucle</li>
</ol>
<p>Guarda la hoja de estilos XLS, corre la transformaci&#243;n en el terminar y examina el resultado en VSCode.
Deber&#237;as obtener una &#250;nica l&#237;nea largu&#237;sima de texto con el valor de cada uno de los elementos <code type="inline">&lt;t&#237;tulo&gt;</code>. </p>
<p>Puedes mejorar la forma como se imprime indic&#225;ndole al procesador que a&#241;ada un salto de l&#237;nea tras cada entrada.
Para ello, justo despu&#233;s de la l&#237;nea <code type="inline">&lt;xsl:value-of select="t&#237;tulo"/&gt;</code> en tu archivo XSL, a&#241;ade <code type="inline">&lt;xsl:text&gt;&amp;#xA;&lt;/xsl:text&gt;</code> para crear un salto de l&#237;nea.
<code type="inline">&amp;#xA;</code> es el c&#243;digo <link target="https://es.wikipedia.org/wiki/Nueva_l%C3%ADnea">hexadecimal ISO 10646</link> con el que se representa un salto de l&#237;nea. <ref type="footnotemark" target="#A4"/>
Con el elemento <code type="inline">&lt;xsl:text&gt;</code> especificamos que queremos imprimir el contenido como texto plano.</p>
<p>Dependiendo del tipo de <emph>output</emph> que se haya escogido (con el elemento <code type="inline">&lt;xsl:output&gt;</code>), algunos caracteres especiales, espec&#237;ficamente los espacios m&#250;ltiples o los saltos de l&#237;nea, pueden no visualizarse correctamente si se introducen por s&#237; solos.
El uso de elementos <code type="inline">&lt;xsl:text&gt;</code> garantiza que tu texto se visualizar&#225; exactamente como lo deseas.</p>
<p>El c&#243;digo completo de nuestra hoja de estilos XSL ser&#225; entonces este:</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_20" type="block" corresp="code_transformacion-datos-xml-xsl_20.txt"></code></pre>
<p>Guarda el archivo, ejecuta de nuevo el comando de transformaci&#243;n en el terminal y examina el resultado en VSCode.
Ahora deber&#237;as ver impreso el valor de los t&#237;tulos de todos los registros contenidos en el documento.</p>
<div type="4"><head>Ejercicio A</head>
<blockquote>
<p>Nota: algunas soluciones posibles para estos ejercicios se encuentran al final del tutorial.</p>
</blockquote>
<p>Imprime un inventario de los registros que contenga el identificador, el t&#237;tulo y la fecha de cada registro. </p>
</div><div type="4"><head>Ejercicio B</head>
<p>Imprime el texto de todos los art&#237;culos, precedido por el identificador entre corchetes cuadrados (<code type="inline">[]</code>).</p>
</div></div><div type="3"><head>Atributos</head>
<p>En un elemento, no siempre se almacena la informaci&#243;n dentro su <emph>contenido</emph> (esto es, aquello que va entre sus etiquetas de apertura y de cierre).
Algunos datos pueden almacenar como valores de <emph>atributos</emph> de ese elemento.
Por ejemplo, el elemento <code type="inline">&lt;fecha&gt;</code> tiene un atributo llamado <code type="inline">cu&#225;ndo</code> que contiene el valor de la fecha del art&#237;culo, as&#237;:</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_21" type="block" corresp="code_transformacion-datos-xml-xsl_21.txt"></code></pre>
<p>Ahora bien, para obtener el valor contenido en el atributo <code type="inline">cu&#225;ndo</code> hay que hacer referencia a este atributo utilizando el valor <code type="inline">@cu&#225;ndo</code> (nota la arroba <code type="inline">@</code> que precede su nombre), as&#237;</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_22" type="block" corresp="code_transformacion-datos-xml-xsl_22.txt"></code></pre>
<p>lo que significa: selecciona e imprime el valor del atributo <code type="inline">cu&#225;ndo</code> del elemento <code type="inline">&lt;fecha&gt;</code>.</p>
<div type="4"><head>Ejercicio C</head>
<p>Crea un inventario de registros en el que se liste el t&#237;tulo del peri&#243;dico seguido de la fecha de publicaci&#243;n.</p>
</div></div></div><div type="2"><head>C&#243;mo ordenar resultados</head>
<p>Esta base de datos XML fue escrita seg&#250;n se iba recolectando la informaci&#243;n, sin organizar los registros por fecha o t&#237;tulo.
A fin de organizarlos, podemos a&#241;adir un elemento <code type="inline">&lt;xsl:sort&gt;</code> (literalmente, <emph>ordena</emph> o <emph>clasifica</emph>) al principio de la repetici&#243;n en bucle, es decir, inmediatamente despu&#233;s del elemento <code type="inline">&lt;xsl:for-each&gt;</code>.
Este elemento tiene varios atributos opcionales que modifican c&#243;mo los datos se ordenan en el documento resultante:</p>
<ul>
<li><code type="inline">select</code>: contiene el nombre del elemento que sirve como criterio para ordenar los datos</li>
<li><code type="inline">order</code>: define si los datos se ordenan de manera ascendiente (con el valor <code type="inline">ascending</code>) o descendiente (con el valor <code type="inline">descending</code>)</li>
<li><code type="inline">data-type</code>: informa al procesador XSL si los datos son de texto (con el valor <code type="inline">textual</code>) o num&#233;ricos (con <code type="inline">number</code>)</li>
</ul>
<p>Por ejemplo, podemos escribir la siguiente instrucci&#243;n para ordenar los datos a partir del elemento <code type="inline">&lt;identificador&gt;</code> en orden descendiente, es decir de mayor a menor:</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_23" type="block" corresp="code_transformacion-datos-xml-xsl_23.txt"></code></pre>
<p>Vale aclarar que es posible ordenar los resultados utilizando un cierto elemento, incluso si no se lo desea imprimir.</p>
<div type="3"><head>Ejercicio D</head>
<p>Imprime el texto de todos los art&#237;culos, ordenados de m&#225;s a menos recientes.
Para ello, utiliza el elemento <code type="inline">&lt;xsl:sort&gt;</code> y trata las fechas como si fueran texto (<code type="inline">text</code>).</p>
</div></div><div type="2"><head>C&#243;mo filtrar resultados</head>
<p>Hasta el momento hemos impreso todos los registros contenidos en el documento XML.
Ahora bien, si solo queremos seleccionar unos cuantos, necesitaremos filtrar los resultados mediante condiciones.
Esto se consigue utilizando el elemento <code type="inline">&lt;xsl:if&gt;</code> (literalmente, <emph>si</emph>) y a&#241;adiendo la condici&#243;n deseada en el atributo <code type="inline">test</code>.
Si se cumple la condici&#243;n, el procesador llevar&#225; a cabo la instrucci&#243;n contenida en <code type="inline">&lt;xsl:if&gt;</code>.
Si no la cumple, lo ignorar&#225; y seguir&#225; adelante.</p>
<p>As&#237;, para imprimir los identificadores de los registros del a&#241;o 1789, podemos usar el siguiente c&#243;digo:</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_24" type="block" corresp="code_transformacion-datos-xml-xsl_24.txt"></code></pre>
<p>Si queremos excluir el a&#241;o 1789, en cambio, utilizaremos la expresi&#243;n <code type="inline">fecha/a&#241;o!=1789'</code> (donde <code type="inline">!=</code> significa: <emph>no igual a</emph>).</p>
<div type="3"><head>Ejercicio E</head>
<p>A modo de recapitulaci&#243;n, crea una lista de registros fechados a partir de 1789 ordenada del m&#225;s reciente al m&#225;s antiguo y que contenga el identificador, el t&#237;tulo y la fecha separados por comas; cada registro deber&#225; mostrarse tras un salto de l&#237;nea.</p>
<p>Si lo deseas, puedes especificar que el archivo de salida sea un archivo de <link target="https://es.wikipedia.org/wiki/Valores_separados_por_comas">Valores separados por comas (CSV)</link>, que puede abrirse y manipularse como una hoja de c&#225;lculo con Microsoft Excel o LibreOffice Calc.
Para hacer eso, tan solo especif&#237;calo en la l&#237;nea de comandos cuando realices la transformaci&#243;n:</p>
<pre><code class="language-sh" xml:id="code_transformacion-datos-xml-xsl_25" type="block" corresp="code_transformacion-datos-xml-xsl_25.txt"></code></pre>
</div></div><div type="2"><head>Conclusi&#243;n</head>
<p>Esta lecci&#243;n ha cubierto el funcionamiento principal de XSL.
Con la informaci&#243;n proporcionada, resulta f&#225;cil generar varios <emph>outputs</emph> en distintos formatos: texto plano, valores separados por coma o por tabulaciones, o Markdown.
Tambi&#233;n ser&#237;a posible crear p&#225;ginas web cambiando valor el atributo <code type="inline">method</code> en el elemento <code type="inline">&lt;xsl:output&gt;</code> de <code type="inline">text</code> a <code type="inline">html</code>, y envolviendo las instrucciones <code type="inline">&lt;xsl:value-of&gt;</code> con los elementos HTML pertinentes.</p>
<p>Existen muchas m&#225;s instrucciones con las que transformar documentos XML a otros formatos y estructuras.
Aunque algunas transformaciones m&#225;s avanzadas requieren un procesador XSL 2.0 o 3.0, las explicaciones de este tutorial satisfacen las necesidades m&#225;s comunes de los historiadores.
Para los usuarios m&#225;s experimentados, recomendamos explorar el directorio <code type="inline">Transformers</code> de la base de datos <emph>Scissors and Paste</emph> a fin de ver m&#225;s ejemplos de c&#243;mo transformar datos estructurados con lenguaje XML.</p>
</div><div type="2"><head>Posibles soluciones a los ejercicios</head>
<div type="3"><head>Introducci&#243;n (fuentes primarias)</head>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_26" type="block" corresp="code_transformacion-datos-xml-xsl_26.txt"></code></pre>
<p>El punto (<code type="inline">.</code>) en el elemento XSL <code type="inline">&lt;xsl:value-of select="."/&gt;</code> es la forma de referirnos al elemento actual en el contexto.
En este caso nos referimos al elemento seleccionado con la instrucci&#243;n <code type="inline">&lt;xsl:for-each select="texto/p"&gt;</code>, es decir, el elemento <code type="inline">&lt;p&gt;</code> hijo de <code type="inline">&lt;texto&gt;</code>.
Si en su lugar tuvi&#233;ramos <code type="inline">p</code>, no seleccionar&#237;amos nada, pues no existe ning&#250;n <code type="inline">texto/p/p</code>.</p>
</div><div type="3"><head>Ejercicio A</head>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_27" type="block" corresp="code_transformacion-datos-xml-xsl_27.txt"></code></pre>
</div><div type="3"><head>Ejercicio B</head>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_28" type="block" corresp="code_transformacion-datos-xml-xsl_28.txt"></code></pre>
<p>Para eliminar la sangr&#237;a del texto que precede al identificador entre corchetes, necesitar&#225;s hacerte cargo directo del espaciado introduciendo saltos de l&#237;nea tras el identificador y cada p&#225;rrafo, as&#237;:</p>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_29" type="block" corresp="code_transformacion-datos-xml-xsl_29.txt"></code></pre>
</div><div type="3"><head>Ejercicio C</head>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_30" type="block" corresp="code_transformacion-datos-xml-xsl_30.txt"></code></pre>
<p><code type="inline">&amp;#32;</code> es el c&#243;digo HEX equivalente a un espacio.
Aunque es posible a&#241;adir un espacio en la instrucci&#243;n, es mejor utilizar el c&#243;digo hexadecimal para asegurarnos que se mantendr&#225; en el documento generado.
Tambi&#233;n es posible utilizar una coma o cualquier otro separador.</p>
</div><div type="3"><head>Ejercicio D</head>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_31" type="block" corresp="code_transformacion-datos-xml-xsl_31.txt"></code></pre>
</div><div type="3"><head>Ejercicio E</head>
<pre><code class="language-xml" xml:id="code_transformacion-datos-xml-xsl_32" type="block" corresp="code_transformacion-datos-xml-xsl_32.txt"></code></pre>
</div></div><div type="2"><head>Bibliograf&#237;a recomendada</head>
<ul>
<li>Hunter, David <emph>et al</emph>. <emph>Beginning XML</emph>, 4a ed. Indianapolis, IN: Wiley, 2007. Impreso.</li>
<li>Kay, Michael, <emph>XSLT 2.0 and XPATH 2.0: Programmer's Reference</emph>. Indianapolis, IN: Wiley, 2011. Impreso.</li>
<li>Kelly, David J. <emph>XSLT Jumpstarter: Level the Learning Curve and Put Your XML to Work</emph>. Raleigh, NC: Peloria Press, May 2015. Impreso.</li>
<li>Mangano, Sal. <emph>XSLT Cookbook</emph>, 2a ed. Sebstopol, CA: O'Reilly, 2006. Impreso.</li>
<li>Riley, Jenn. <link target="https://www.niso.org/node/12366"><emph>Understanding Metadata: What is Metadata, and What is For?</emph></link> NISO, 2017. Web</li>
<li>Tennison, Jeni. <emph>Beginning XSLT 2.0. From Novice to Professional</emph>. Nueva York: Apress, 2005. Impreso.</li>
<li>Tidwell, Doug. <emph>XSLT</emph>, 2a ed. Sebstopol, CA: O'Reilly, 2008. Impreso</li>
</ul>
</div><div type="2"><head>Notas</head>
<p><note id="1"> Nota del traductor: Seg&#250;n <link target="https://es.wikipedia.org/wiki/Base_de_datos_XML">Wikipedia</link>, una base de datos XML es un programa "que da persistencia a datos almacenados en formato XML. Estos datos pueden ser interrogados, exportados y serializados". Pueden distinguirse dos tipos: bases de datos habilitadas (por ejemplo, una basee de datos relacional cl&#225;sica que acepta XML como formato de entrada y salida) y bases de datos nativas (es decir, que utilizan documentos XML como unidad de almacenamiento) como <link target="https://exist-db.org/exist/apps/homepage/index.html">eXist</link> o <link target="https://basex.org/">BaseX</link>. En este tutorial, sin embargo, la autora, a menudo, no distingue entre el continente (el programario) y el contenido de la base de datos XML (los documentos).</note></p>
<p><note id="2"> Nota del traductor: La <link target="https://tei-c.org/release/doc/tei-p5-doc/de/html/SG.html#SG132">Text Encoding Initiative</link> considera que un documento XML est&#225; bien formado cuando cumple tres reglas: (1) un solo elemento (o elemento ra&#237;z) contiene todo el documento; (2) todos los elementos est&#225;n contenidos en el elemento ra&#237;z; y (3) las etiquetas de apertura y cierre marcan, respectivamente, el inicio y el fin de todos los elementos. Para m&#225;s detalles sobre el funcionamiento de XML, aconsejamos consultar Hunter <emph>et al</emph>. (2007). </note></p>
<p><note id="3"> Nota del traductor: La National Information Standards Organization (NISO), nacida en Estados Unidos en 1983 en el &#225;mbito de las bibliotecas, define los metadatos como "la informaci&#243;n creada, almacenada y compartida para describir objetos y que nos permite interactuar con &#233;stos a fin de obtener conocimiento" (Riley, 2017).</note></p>
<p><note id="4"> Nota del traductor: En la versi&#243;n espa&#241;ola de este tutorial, hemos traducido al espa&#241;ol los nombres de los elementos (pero no su contenido) y hemos adaptado las instrucciones XSL para que coincidan con los utilizados en el archivo fuente (<emph>input</emph>). En adelante, daremos por sentado que est&#225;s utilizando el archivo XML <emph><code type="inline">SAPsimple_es.xml</code></emph>.</note></p>
<p><note id="5"> Nota del traductor: M&#225;s informaci&#243;n en <link target="https://es.wikipedia.org/wiki/ISO_8601">Wikipedia</link> y en la p&#225;gina web de <link target="https://www.iso.org/home.html">International Organization for Standardization</link>. ISO es una organizaci&#243;n internacional fundada en 1947 y establecida en Ginebra que tiene por misi&#243;n la creaci&#243;n y mantenimiento de est&#225;ndares.</note></p>
<p><note id="A1"> El lenguaje XSL tiene dos ramas: (1) <emph>XSL Formatting Objects</emph> (XSL:FO), que contiene instrucciones de formato para producir un documento PDF a partir de un documento XML; y (2) <emph>Extensible Stylesheet Language Transformations</emph> (XSLT), es contiene instrucciones para transformar un documento XML en otros documentos (XML, HTML, XHTML y texto plano). En este tutorial solo se discute la segunda.</note></p>
<p><note id="A2"> Otra posibilidad es que ubiquemos el ejecutable de Saxon en una carpeta que ya est&#233; incluida en la variable global de sistema <code type="inline">PATH</code> (o que cambiemos dicha variable para que incluya la carpeta que hemos escogido para Saxon). Quienes tengan inter&#233;s pueden consultar estas p&#225;ginas que explican c&#243;mo hacerlo en <link target="https://www.computerhope.com/issues/ch000549.htm">Windows</link>, <link target="https://stackoverflow.com/questions/22465332/setting-path-environment-variable-in-osx-permanently">MacOS</link> y <link target="https://opensource.com/article/17/6/set-path-linux">Linux</link>.</note></p>
<p><note id="A3"> Desde la versi&#243;n 2.0 de XSLT, la instrucci&#243;n <code type="inline">&lt;xsl:value-of&gt;</code> selecciona <emph>todas</emph> las ocurrencias de la expresi&#243;n en el documento XML. (Al respecto, v&#233;ase <link target="https://www.w3.org/TR/2021/REC-xslt20-20210330/#changes">aqu&#237;</link>.) Si quieres intentarlo, debes cambiar el valor del atributo <code type="inline">@version</code> de <code type="inline">1.0</code> a <code type="inline">2.0</code> (o a <code type="inline">3.0</code>) en la l&#237;nea <code type="inline">&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;</code> de la hoja de estilos XSL.</note></p>
<p><note id="A4"> En lugar de usar la entidad <code type="inline">&amp;#xA;</code>, puedes reemplazar la l&#237;nea con este c&#243;digo:</note>
<code type="inline">xml &lt;xsl:text&gt; &lt;/xsl:text&gt; </code>
(F&#237;jate en la l&#237;nea en blanco como contenido del elemento <code type="inline">&lt;xsl:text&gt;</code>.)
Ambas expresiones son equivalentes, aunque esta segunda ocupa m&#225;s espacio (y es m&#225;s evidente) que la primera.</p>
</div></body>
  </text>
</TEI>
