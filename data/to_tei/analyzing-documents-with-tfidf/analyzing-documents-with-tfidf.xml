<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:id="analyzing-documents-with-tfidf">
  <teiHeader>
 <fileDesc>
  <titleStmt>
   <title>Analyzing Documents with TF-IDF</title>
  <author role="original_author">Matthew J. Lavin</author><editor role="reviewers"><persName>Quinn Dombrowski</persName><persName>Catherine Nygren</persName></editor><editor role="editors">Zoe LeBlanc</editor></titleStmt>
  <publicationStmt>
   <idno type="doi">10.46430/phen0082</idno><date type="published">05/13/2019</date><p>Lesson reviewed and published in Programming Historian.</p>
  </publicationStmt>
  <sourceDesc>
  <p>Born digital, in a markdown format. This lesson is original. Available translations are the following:<ref type="translations" target="#analyse-de-documents-avec-tfidf"/></p></sourceDesc>
 </fileDesc>
 <profileDesc><abstract><p>This lesson focuses on a foundational natural language processing and information retrieval method called Term Frequency - Inverse Document Frequency (tf-idf). This lesson explores the foundations of tf-idf, and will also introduce you to some of the questions and concepts of computationally oriented text analysis.</p></abstract><textClass><keywords><term xml:lang="en">distant-reading</term></keywords></textClass></profileDesc>
</teiHeader>
  <text xml:lang="en">
    <body>
      <div type="2"><head>Overview</head>
<p>This lesson focuses on a core natural language processing and information retrieval method called Term Frequency - Inverse Document Frequency (<hi rend="bold">tf-idf</hi>). You may have heard about <hi rend="bold">tf-idf</hi> in the context of topic modeling, machine learning, or or other approaches to text analysis. <hi rend="bold">Tf-idf</hi> comes up a lot in published work because it's both a <ref target="https://en.wikipedia.org/wiki/Text_corpus">corpus</ref> exploration method and a pre-processing step for many other text-mining measures and models.</p>
<p>Looking closely at tf-idf will leave you with an immediately applicable text analysis method. This lesson will also introduce you to some of the questions and concepts of computationally oriented text analysis. Namely, this lesson addresses how you can isolate a document&#8217;s most important words from the kinds of words that tend to be highly frequent across a set of documents in that language. In addition to tf-idf, there are a number of computational methods for determining which words or phrases characterize a set of documents, and I highly recommend Ted Underwood's 2011 blog post as a supplement.<ref type="footnotemark" target="#note_1"/></p>
</div>
      <div type="2"><head>Preparation</head>
<div type="3"><head>Suggested Prior Skills</head>
<list type="unordered">
<item>Prior familiarity with Python or a similar programming language. Code for this lesson is written in Python 3.6, but you can run <hi rend="bold">tf-idf</hi> in several different versions of Python, using one of several packages, or in various other programming languages. The precise level of code literacy or familiarity recommended is hard to estimate, but you will want to be comfortable with basic types and operations. To get the most out of this lesson, it is recommended that you work your way through something like <ref target="https://www.codecademy.com/learn/learn-python">Codeacademy's "Introduction to Python" course</ref>, or that you complete some of the <ref target="/en/lessons/introduction-and-installation">introductory Python lessons on the <emph>Programming Historian</emph></ref>.</item>
<item>In lieu of the above recommendation, you should <ref target="https://www.learnpython.org/">review Python's basic types</ref> (string, integer, float, list, tuple, dictionary), working with variables, writing loops in Python, and working with object classes/instances.</item>
<item>Experience with Excel or an equivalent spreadsheet application if you wish to examine the linked spreadsheet files. You can also use the pandas library in python to view the CSVs.</item>
</list>
</div><div type="3"><head>Before You Begin</head>
<list type="unordered">
<item>Install the Python 3 version of Anaconda. Installing Anaconda is covered in <ref target="/en/lessons/text-mining-with-extracted-features">Text Mining in Python through the HTRC Feature Reader</ref>. This will install Python 3.6 (or higher), the <ref target="https://scikit-learn.org/stable/install.html">Scikit-Learn library</ref> (which we will use for <hi rend="bold">tf-idf</hi>), and the dependencies needed to run a <ref target="https://jupyter.org/">Jupyter Notebook</ref>.</item>
<item>It is possible to install all these dependencies without Anaconda (or with a lightweight alternative like <ref target="https://docs.conda.io/en/latest/miniconda.html">Miniconda</ref>). For more information, see the section below titled <ref target="#alternatives-to-anaconda">"Alternatives to Anaconda"</ref></item>
</list>
</div><div type="3"><head>Lesson Dataset</head>
<p><hi rend="bold">Tf-idf</hi>, like many computational operations, is best understood by example. To this end, I've prepared a dataset of 366 <emph>New York Times</emph> historic <ref target="https://en.wikipedia.org/wiki/Obituary">obituaries</ref> scraped from <ref target="https://archive.nytimes.com/www.nytimes.com/learning/general/onthisday/">https://archive.nytimes.com/www.nytimes.com/learning/general/onthisday/</ref>. On each day of the year, <emph>The New York Times</emph> featured an obituary of someone born on that day.</p>
<p>Lesson files, including, this dataset, can be downloaded from <ref target="/assets/tf-idf/lesson-files.zip">lesson-files.zip</ref>. The dataset is small enough that you should be able to open and read some if not all of the files. The original data is also available in the 'obituaries' folder, containing the '.html' files downloaded from the 2011 "On This Day" website and a folder of '.txt' files that represent the body of each obituary. These text files were generated using a <ref target="https://docs.python.org/3/library/intro.html">Python library</ref> called <ref target="https://www.crummy.com/software/BeautifulSoup/">BeautifulSoup</ref>, which is covered in another <emph>Programming Historian</emph> lesson (see <ref target="/en/lessons/intro-to-beautiful-soup">Intro to BeautifulSoup</ref>).</p>
<p>This obituary corpus is an historical object in its own right. It represents, on some level, how the questions of inclusion and representation might affect both the decision to publish an obituary, and the decision to highlight a particular obituary many years later. The significance of such decisions has been further highlighted in recent months by <emph>The New York Times</emph> itself. In March 2018, the newspaper began publishing obituaries for "overlooked women".<ref type="footnotemark" target="#note_2"/> In the words of Amisha Padnani and Jessica Bennett, "who gets remembered &#8212; and how &#8212; inherently involves judgment. To look back at the obituary archives can, therefore, be a stark lesson in how society valued various achievements and achievers." Viewed through this lens, the dataset provided here stands not as a representative sample of historic obituaries but, rather, a snapshot of who <emph>The New York Times</emph> in 2010-2011 considered worth highlighting. You'll notice that many of the historic figures are well known, which suggests a self-conscious effort to look back at the history of <emph>The New York Times</emph> and select obituaries based on some criteria.<ref type="footnotemark" target="#note_3"/></p>
</div><table>
<row>
<cell role="label">Rank</cell>
<cell role="label">Term</cell>
<cell role="label">Count</cell>
</row>
<row>
<cell>10</cell>
<cell>vexations</cell>
<cell>6.21</cell>
</row>
<row>
<cell>9</cell>
<cell>plume</cell>
<cell>6.21</cell>
</row>
<row>
<cell>8</cell>
<cell>ironclad</cell>
<cell>6.21</cell>
</row>
<row>
<cell>7</cell>
<cell>mark</cell>
<cell>8.64</cell>
</row>
<row>
<cell>6</cell>
<cell>nellie</cell>
<cell>9.92</cell>
</row>
<row>
<cell>5</cell>
<cell>bly</cell>
<cell>12.42</cell>
</row>
<row>
<cell>4</cell>
<cell>seaman</cell>
<cell>14.88</cell>
</row>
<row>
<cell>3</cell>
<cell>she</cell>
<cell>16.22</cell>
</row>
<row>
<cell>2</cell>
<cell>her</cell>
<cell>22.74</cell>
</row>
<row>
<cell>1</cell>
<cell>cochrane</cell>
<cell>24.85</cell>
</row>
</table><table>
<row>
<cell role="label">Rank</cell>
<cell role="label">Term</cell>
<cell role="label">Count</cell>
</row>
<row>
<cell>10</cell>
<cell>to</cell>
<cell>4</cell>
</row>
<row>
<cell>9</cell>
<cell>was</cell>
<cell>4</cell>
</row>
<row>
<cell>8</cell>
<cell>cochrane</cell>
<cell>4</cell>
</row>
<row>
<cell>7</cell>
<cell>at</cell>
<cell>8</cell>
</row>
<row>
<cell>6</cell>
<cell>she</cell>
<cell>10</cell>
</row>
<row>
<cell>5</cell>
<cell>and</cell>
<cell>13</cell>
</row>
<row>
<cell>4</cell>
<cell>in</cell>
<cell>14</cell>
</row>
<row>
<cell>3</cell>
<cell>her</cell>
<cell>15</cell>
</row>
<row>
<cell>2</cell>
<cell>of</cell>
<cell>16</cell>
</row>
<row>
<cell>1</cell>
<cell>the</cell>
<cell>21</cell>
</row>
</table></div>
      <div type="2"><head>Procedure</head>
<table>
<row>
<cell role="label">Index</cell>
<cell role="label">Term</cell>
<cell role="label">Count</cell>
<cell role="label">Df</cell>
<cell role="label">Idf</cell>
<cell role="label">Tf-idf</cell>
</row>
<row>
<cell>30</cell>
<cell>character</cell>
<cell>1</cell>
<cell>89</cell>
<cell>2.40555218</cell>
<cell>2.40555218</cell>
</row>
<row>
<cell>29</cell>
<cell>career</cell>
<cell>1</cell>
<cell>223</cell>
<cell>1.49371580</cell>
<cell>1.49371580</cell>
</row>
<row>
<cell>28</cell>
<cell>by</cell>
<cell>3</cell>
<cell>349</cell>
<cell>1.04742869</cell>
<cell>3.14228608</cell>
</row>
<row>
<cell>27</cell>
<cell>but</cell>
<cell>1</cell>
<cell>343</cell>
<cell>1.06472019</cell>
<cell>1.06472019</cell>
</row>
<row>
<cell>26</cell>
<cell>born</cell>
<cell>1</cell>
<cell>342</cell>
<cell>1.06763140</cell>
<cell>1.06763140</cell>
</row>
<row>
<cell>25</cell>
<cell>body</cell>
<cell>1</cell>
<cell>112</cell>
<cell>2.17797403</cell>
<cell>2.17797403</cell>
</row>
<row>
<cell>24</cell>
<cell>bly</cell>
<cell>2</cell>
<cell>1</cell>
<cell>6.21221467</cell>
<cell>12.42442933</cell>
</row>
<row>
<cell>23</cell>
<cell>bell</cell>
<cell>1</cell>
<cell>24</cell>
<cell>3.68648602</cell>
<cell>3.68648602</cell>
</row>
<row>
<cell>22</cell>
<cell>began</cell>
<cell>1</cell>
<cell>241</cell>
<cell>1.41642412</cell>
<cell>1.41642412</cell>
</row>
<row>
<cell>21</cell>
<cell>beat</cell>
<cell>1</cell>
<cell>33</cell>
<cell>3.37900132</cell>
<cell>3.37900132</cell>
</row>
<row>
<cell>20</cell>
<cell>be</cell>
<cell>1</cell>
<cell>332</cell>
<cell>1.09721936</cell>
<cell>1.09721936</cell>
</row>
<row>
<cell>19</cell>
<cell>baxter</cell>
<cell>1</cell>
<cell>4</cell>
<cell>5.29592394</cell>
<cell>5.29592394</cell>
</row>
<row>
<cell>18</cell>
<cell>barrel</cell>
<cell>1</cell>
<cell>7</cell>
<cell>4.82592031</cell>
<cell>4.82592031</cell>
</row>
<row>
<cell>17</cell>
<cell>bankruptcy</cell>
<cell>1</cell>
<cell>8</cell>
<cell>4.70813727</cell>
<cell>4.70813727</cell>
</row>
<row>
<cell>16</cell>
<cell>balloon</cell>
<cell>1</cell>
<cell>2</cell>
<cell>5.80674956</cell>
<cell>5.80674956</cell>
</row>
<row>
<cell>15</cell>
<cell>avenue</cell>
<cell>2</cell>
<cell>68</cell>
<cell>2.67125534</cell>
<cell>5.34251069</cell>
</row>
<row>
<cell>14</cell>
<cell>at</cell>
<cell>8</cell>
<cell>362</cell>
<cell>1.01095901</cell>
<cell>8.08767211</cell>
</row>
<row>
<cell>13</cell>
<cell>asylum</cell>
<cell>1</cell>
<cell>2</cell>
<cell>5.80674956</cell>
<cell>5.80674956</cell>
</row>
<row>
<cell>12</cell>
<cell>ascension</cell>
<cell>1</cell>
<cell>6</cell>
<cell>4.95945170</cell>
<cell>4.95945170</cell>
</row>
<row>
<cell>11</cell>
<cell>as</cell>
<cell>2</cell>
<cell>357</cell>
<cell>1.02482886</cell>
<cell>2.04965772</cell>
</row>
<row>
<cell>10</cell>
<cell>around</cell>
<cell>2</cell>
<cell>149</cell>
<cell>1.89472655</cell>
<cell>3.78945311</cell>
</row>
<row>
<cell>9</cell>
<cell>and</cell>
<cell>13</cell>
<cell>364</cell>
<cell>1.00546449</cell>
<cell>13.07103843</cell>
</row>
<row>
<cell>8</cell>
<cell>an</cell>
<cell>1</cell>
<cell>352</cell>
<cell>1.03889379</cell>
<cell>1.03889379</cell>
</row>
<row>
<cell>7</cell>
<cell>american</cell>
<cell>1</cell>
<cell>277</cell>
<cell>1.27774073</cell>
<cell>1.27774073</cell>
</row>
<row>
<cell>6</cell>
<cell>all</cell>
<cell>1</cell>
<cell>310</cell>
<cell>1.16556894</cell>
<cell>1.16556894</cell>
</row>
<row>
<cell>5</cell>
<cell>air</cell>
<cell>1</cell>
<cell>80</cell>
<cell>2.51091269</cell>
<cell>2.51091269</cell>
</row>
<row>
<cell>4</cell>
<cell>ago</cell>
<cell>1</cell>
<cell>161</cell>
<cell>1.81776551</cell>
<cell>1.81776551</cell>
</row>
<row>
<cell>3</cell>
<cell>age</cell>
<cell>1</cell>
<cell>224</cell>
<cell>1.48926145</cell>
<cell>1.48926145</cell>
</row>
<row>
<cell>2</cell>
<cell>against</cell>
<cell>1</cell>
<cell>189</cell>
<cell>1.65833778</cell>
<cell>1.65833778</cell>
</row>
<row>
<cell>1</cell>
<cell>afternoon</cell>
<cell>1</cell>
<cell>66</cell>
<cell>2.70066923</cell>
<cell>2.70066923</cell>
</row>
</table><table>
<row>
<cell role="label">Index</cell>
<cell role="label">Term</cell>
<cell role="label">Count</cell>
<cell role="label">Df</cell>
</row>
<row>
<cell>30</cell>
<cell>character</cell>
<cell>1</cell>
<cell>89</cell>
</row>
<row>
<cell>29</cell>
<cell>career</cell>
<cell>1</cell>
<cell>223</cell>
</row>
<row>
<cell>28</cell>
<cell>by</cell>
<cell>3</cell>
<cell>349</cell>
</row>
<row>
<cell>27</cell>
<cell>but</cell>
<cell>1</cell>
<cell>343</cell>
</row>
<row>
<cell>26</cell>
<cell>born</cell>
<cell>1</cell>
<cell>342</cell>
</row>
<row>
<cell>25</cell>
<cell>body</cell>
<cell>1</cell>
<cell>112</cell>
</row>
<row>
<cell>24</cell>
<cell>bly</cell>
<cell>2</cell>
<cell>1</cell>
</row>
<row>
<cell>23</cell>
<cell>bell</cell>
<cell>1</cell>
<cell>24</cell>
</row>
<row>
<cell>22</cell>
<cell>began</cell>
<cell>1</cell>
<cell>241</cell>
</row>
<row>
<cell>21</cell>
<cell>beat</cell>
<cell>1</cell>
<cell>33</cell>
</row>
<row>
<cell>20</cell>
<cell>be</cell>
<cell>1</cell>
<cell>332</cell>
</row>
<row>
<cell>19</cell>
<cell>baxter</cell>
<cell>1</cell>
<cell>4</cell>
</row>
<row>
<cell>18</cell>
<cell>barrel</cell>
<cell>1</cell>
<cell>7</cell>
</row>
<row>
<cell>17</cell>
<cell>bankruptcy</cell>
<cell>1</cell>
<cell>8</cell>
</row>
<row>
<cell>16</cell>
<cell>balloon</cell>
<cell>1</cell>
<cell>2</cell>
</row>
<row>
<cell>15</cell>
<cell>avenue</cell>
<cell>2</cell>
<cell>68</cell>
</row>
<row>
<cell>14</cell>
<cell>at</cell>
<cell>8</cell>
<cell>362</cell>
</row>
<row>
<cell>13</cell>
<cell>asylum</cell>
<cell>1</cell>
<cell>2</cell>
</row>
<row>
<cell>12</cell>
<cell>ascension</cell>
<cell>1</cell>
<cell>6</cell>
</row>
<row>
<cell>11</cell>
<cell>as</cell>
<cell>2</cell>
<cell>357</cell>
</row>
<row>
<cell>10</cell>
<cell>around</cell>
<cell>2</cell>
<cell>149</cell>
</row>
<row>
<cell>9</cell>
<cell>and</cell>
<cell>13</cell>
<cell>364</cell>
</row>
<row>
<cell>8</cell>
<cell>an</cell>
<cell>1</cell>
<cell>352</cell>
</row>
<row>
<cell>7</cell>
<cell>american</cell>
<cell>1</cell>
<cell>277</cell>
</row>
<row>
<cell>6</cell>
<cell>all</cell>
<cell>1</cell>
<cell>310</cell>
</row>
<row>
<cell>5</cell>
<cell>air</cell>
<cell>1</cell>
<cell>80</cell>
</row>
<row>
<cell>4</cell>
<cell>ago</cell>
<cell>1</cell>
<cell>161</cell>
</row>
<row>
<cell>3</cell>
<cell>age</cell>
<cell>1</cell>
<cell>224</cell>
</row>
<row>
<cell>2</cell>
<cell>against</cell>
<cell>1</cell>
<cell>189</cell>
</row>
<row>
<cell>1</cell>
<cell>afternoon</cell>
<cell>1</cell>
<cell>66</cell>
</row>
</table><div type="3"><head>How to Run it in Python 3</head>
<p>In this section of the lesson, I will walk through the steps I followed to calculate <hi rend="bold">tf-idf</hi> scores for all terms in all documents in the lesson's obituary corpus. If you would like to follow along, you can download the lesson files, extract the '.zip' archive, and run the Jupyter Notebook inside of the 'lesson' folder. You can also create a new Jupyter Notebook in that location copy/paste blocks of code from this tutorial as you go. If you are using Anaconda, visit the <ref target="https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/execute.html">Jupyter Notebook Documentation Page</ref> for more information on changing the Jupyter Notebook startup location. As with any programming language, there's more than one way to do each of the steps I discuss below.</p>
<p>My first block of code is designed to retrieve all the filenames for '.txt' files in the 'txt' folder. The following lines of code import the <code rend="inline">Path</code> class from the <code rend="inline">pathlib</code> library and use the <code rend="inline">Path().rglob()</code> method to generate a list of all the files in the 'txt' folder that end with '.txt'. <code rend="inline">pathlib</code> will also join the <code rend="inline">file.parent</code> folder location with each file name to provide full file paths for each file (on MacOS or Windows).</p>
<p>Using this method, I append each text file name to the list called <code rend="inline">all_txt_files</code>. Finally, I return the length of <code rend="inline">all_txt_files</code> to verify that I've found 366 file names. This loop-and-append approach is very common in Python.</p>
<ab><code xml:id="code_analyzing-documents-with-tfidf_0" corresp="code_analyzing-documents-with-tfidf_0.txt" lang="language-python" rend="block"/></ab>
<p>A quick note on variable names. The two most common variable naming patterns prioritize convenience and semantic meaning respectively. For convenience, one might name a variable <hi rend="bold">x</hi> so it's easier and faster to type when referencing it. Semantic variables, meanwhile, attempt to describe function or purpose. By naming my list of all text files <code rend="inline">all_txt_files</code> and the variable representing the number of files <code rend="inline">n_files</code>, I'm prioritizing semantic meaning. Meanwhile, I'm using abbreviations like <code rend="inline">txt</code> for text and <code rend="inline">n</code> for number to save on typing, or using <code rend="inline">all_txt_files</code> instead of <code rend="inline">all_txt_file_names</code> because brevity is still a goal. Underscore and capitalization norms are specified in PEP-8, Python's official style guide, with which you should try to be generally familiar.<ref type="footnotemark" target="#note_9"/></p>
<p>For various resons, we want our files to count up by day and month since there's on file for every day and month of a year. We can use the <code rend="inline">sort()</code> method to put the files in ascending numerical order and print the first file to make sure it's 'txt/0101.txt'.</p>
<ab><code xml:id="code_analyzing-documents-with-tfidf_1" corresp="code_analyzing-documents-with-tfidf_1.txt" lang="language-python" rend="block"/></ab>
<p>Next, we can use our list of file names to load each file and convert them to a format that Python can read and understand as text. In this block of code, I do another loop-and-append operation. This time, I loop my list of file names and open each file. I then use Python's <code rend="inline">read()</code> method to convert each text file to a string (<code rend="inline">str</code>), which is how Python knows to think of the data as text. I append each string, one by one, to a new list called <code rend="inline">all_docs</code>. Crucially, the string objects in this list have the same order as the file names in the <code rend="inline">all_txt_files</code> list.</p>
<ab><code xml:id="code_analyzing-documents-with-tfidf_2" corresp="code_analyzing-documents-with-tfidf_2.txt" lang="language-python" rend="block"/></ab>
<p>This is all the setup work we require. Text processing steps like <ref target="https://en.wikipedia.org/wiki/Lexical_analysis#Tokenization">tokenization</ref> and removing punctuation will happen automatically when we use Scikit-Learn's <code rend="inline">TfidfVectorizer</code> to convert documents from a list of strings to <hi rend="bold">tf-idf</hi> scores. One could also supply a list of stopwords here (commonly used words that you want to ignore). To tokenize and remove stopwords in languages other than English, you may need to preprocess the text with another Python library or supply a custom tokenizer and stopword list when Scikit-Learn's <code rend="inline">TfidfVectorizer</code>. The following block of code imports <code rend="inline">TfidfVectorizer</code> from the Scikit-Learn library, which comes pre-installed with Anaconda. <code rend="inline">TfidfVectorizer</code> is a class (written using object-oriented programming), so I instantiate it with specific parameters as a variable named <code rend="inline">vectorizer</code>. (I&#8217;ll say more about these settings in the section titled <ref target="#scikit-learn-settings">"Scikit-Learn Settings"</ref>.) I then run the object's <code rend="inline">fit_transform()</code> method on my list of strings (a variable called <code rend="inline">all_docs</code>). The stored variable <code rend="inline">X</code> is output of the <code rend="inline">fit_transform()</code> method.</p>
<ab><code xml:id="code_analyzing-documents-with-tfidf_3" corresp="code_analyzing-documents-with-tfidf_3.txt" lang="language-python" rend="block"/></ab>
<p>The <code rend="inline">fit_transform()</code> method above converts the list of strings to something called a <ref target="https://en.wikipedia.org/wiki/Sparse_matrix">sparse matrix</ref>. In this case, the matrix represents <hi rend="bold">tf-idf</hi> values for all texts. Sparse matrices save on memory by leaving out all zero values, but we want access to those, so the next block uses the <code rend="inline">toarray()</code> method to convert the sparse matrices to a <ref target="https://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html">numpy array</ref>. We can print the length of the array to ensure that it's the same length as our list of documents.</p>
<ab><code xml:id="code_analyzing-documents-with-tfidf_4" corresp="code_analyzing-documents-with-tfidf_4.txt" lang="language-python" rend="block"/></ab>
<p>A numpy array is list-like but not exactly a list, and I could fill an entire tutorial discussing the differences, but there's only one aspect of numpy arrays we need to know right now: it converts the data stored in <code rend="inline">transformed_documents</code> to a format where every <hi rend="bold">tf-idf</hi> score for every term in every document is represented. Sparse matrices, in contrast, exclude zero-value term scores.</p>
<p>We want every term represented so that each document has the same number of values, one for each word in the corpus. Each item in <code rend="inline">transformed_documents_as_array</code> is an array of its own representing one document from our corpus. As a result of all this, we essentially have a grid where each row is a document, and each column is a term. Imagine one table from a spreadsheet representing each document, like the tables above, but without column or row labels.</p>
<p>To merge the values with their labels, we need two pieces of information: the order of the documents, and the order in which term scores are listed. The order of these documents is easy because it's the same order as the variable <code rend="inline">all_docs list</code>. The full term list is stored in our <code rend="inline">vectorizer</code> variable, and it's in the same order that each item in <code rend="inline">transformed_documents_as_array</code> stores values. We can use the <code rend="inline">the TFIDFVectorizer</code> class's <code rend="inline">get_feature_names_out()</code> method to get that list, and each row of data (one document's <hi rend="bold">tf-idf</hi> scores) can be rejoined with the term list. (For more details on pandas dataframes, see the lesson <ref target="/en/lessons/visualizing-with-bokeh">"Visualizing Data with Bokeh and Pandas"</ref>.)</p>
<ab><code xml:id="code_analyzing-documents-with-tfidf_5" corresp="code_analyzing-documents-with-tfidf_5.txt" lang="language-python" rend="block"/></ab>
<p>The above block of code has three parts:</p>
<list type="ordered">
<item>
<p>After importing the pandas library, it checks for a folder called 'tf_idf_output' and creates it if it doesn't exist.</p>
</item>
<item>
<p>It takes the list of '.txt' files from my earlier block of code and use it to construct a counterpart '.csv' file path for each '.txt' file. The output_filenames variable will, for example, convert 'txt/0101.txt' (the path of the first '.txt' file) to 'tf_idf_output/0101.csv', and on and on for each file.</p>
</item>
<item>
<p>Using a loop, it merges each vector of <hi rend="bold">tf-idf</hi> scores with the feature names from vectorizer, converts each merged term/score pairs to a pandas dataframe, and saves each dataframe to its corresponding '.csv' file.</p>
</item>
</list>
</div><div type="3"><head>Interpreting Word Lists: Best Practices and Cautionary Notes</head>
<p>After you run the code excerpts above, you will end up with a folder called 'tf_idf_output' with 366 '.csv' files in it. Each file corresponds to an obituary in the 'txt' folder, and each contains a list of terms with <hi rend="bold">tf-idf</hi> scores for that document. As we saw with Nellie Bly's obituary, these term lists can be very suggestive; however, it's important to understand that over-interpreting your results can actually distort your understanding of an underlying text.</p>
<p>In general, it's best to begin with the ideas that these term lists will be helpful for generating hypotheses or research questions. <hi rend="bold">Tf-idf</hi> results but will not necessarily produce definitive claims. For example, I have assembled a quick list of obituaries for late 19th- and early 20th-century figures who all worked for newspapers and magazines and had some connection to social reform. My list includes Nellie Bly, <ref target="https://en.wikipedia.org/wiki/Willa_Cather">Willa Cather</ref>, <ref target="https://en.wikipedia.org/wiki/W._E._B._Du_Bois">W.E.B. Du Bois</ref>, <ref target="https://en.wikipedia.org/wiki/Upton_Sinclair">Upton Sinclair</ref>, <ref target="https://en.wikipedia.org/wiki/Ida_Tarbell">Ida Tarbell</ref>, but there may be other figures in the corpus who fit the same criteria.<ref type="footnotemark" target="#note_10"/></p>
<p>I originally expected to see many shared terms, but I was surprised. Each list is dominated by individualized words (proper names, geographic places, companies, etc.) but I could screen these out using my <hi rend="bold">tf-idf</hi> settings, or just ignore them. Simultaneously, I can look for words overtly indicating each figure's ties to the profession of authorship. (The section of this tutorial titled <ref target="#scikit-learn-settings">Scikit-Learn Settings</ref> says more about how you can treat a named entity or a phrase as a single token.) The following table shows the top 20 <hi rend="bold">tf-idf</hi> terms by rank for each obituary:</p>
<p>| Tf-idf Rank | Nellie Bly | Willa Cather | W.E.B. Du Bois | Upton Sinclair | Ida Tarbell |
| 1 | cochrane | cather | dubois | sinclair | tarbell |
| 2 | her | her | dr | socialist | she |
| 3 | she | she | negro | upton | her |
| 4 | seaman | nebraska | ghana | <hi rend="bold">books</hi> | lincoln |
| 5 | bly | miss | peace | lanny | miss |
| 6 | nellie | forrester | <hi rend="bold">encyclopedia</hi> | social | oil |
| 7 | mark | sibert | communist | budd | abraham |
| 8 | ironclad | twilights | barrington | jungle | mcclure |
| 9 | <hi rend="bold">plume</hi> | willa | fisk | brass | easton |
| 10 | vexations | antonia | atlanta | california | <hi rend="bold">volumes</hi> |
| 11 | phileas | mcclure | folk | <hi rend="bold">writer</hi> | minerva |
| 12 | 597 | <hi rend="bold">novels</hi> | booker | vanzetti | standard |
| 13 | elizabeth | pioneers | successively | macfadden | business |
| 14 | <hi rend="bold">nom</hi> | cloud | souls | sacco | titusville |
| 15 | balloon | <hi rend="bold">book</hi> | council | <hi rend="bold">wrote</hi> | <hi rend="bold">articles</hi> |
| 16 | forgeries | calif | party | meat | bridgeport |
| 17 | mcalpin | <hi rend="bold">novel</hi> | disagreed | <hi rend="bold">pamphlets</hi> | expose |
| 18 | asylum | southwest | harvard | my | trusts |
| 19 | fogg | <hi rend="bold">verse</hi> | <hi rend="bold">arts</hi> | industry | mme
| 20 | verne | <hi rend="bold">wrote</hi> | soviet | <hi rend="bold">novel</hi> | <hi rend="bold">magazine</hi> |</p>
<p>I've used boldface to indicate terms that seem overtly related to authorship or writing. The list includes <emph>articles</emph>, <emph>arts</emph>, <emph>book</emph>, <emph>book</emph>, <emph>books</emph>, <emph>encyclopedia</emph>, <emph>magazine</emph>, <emph>nom</emph>, <emph>novel</emph>, <emph>novels</emph>, <emph>pamphlets</emph>, <emph>plume</emph>, <emph>verse</emph>, <emph>volumes</emph>, <emph>writer</emph>, and <emph>wrote</emph>, but it could be extended to include references to specific magazine or book titles. Setting aside momentarily such complexities, it is striking to me that Cather and Sinclair's lists have so many words for books and writing, whereas Bly, Du Bois and Tarbell's do not.</p>
<p>I could easily jump to conclusions. Cather's identity seems to be tied most to her gender, her sense of place, and her fiction and verse. Sinclair more so with his politics and his writings about meat, industry, and specifically the well known, controversial trial and execution of Nicola Sacco and Bartolomeo Vanzetti. Bly is tied to her pen name, her husband, and her writing about asylums. Du Bois is linked to race and his academic career. Tarbell is described by what she wrote about: namely business, the trusts, Standard Oil, and Abraham Lincoln. Going further, I could argue that gender seems more distinctive for women than it is for men; race is only a top term for the one African American in my set.</p>
<p>Each of these observations forms the basis for a deeper question, but these details aren't enough to make generalizations. Foremost, I need to consider whether my <hi rend="bold">tf-idf</hi> settings are producing effects that would disappear under other conditions; robust results should be stable enough to appear with various settings. (Some of these settings are covered in the <ref target="#scikit-learn-settings">"Scikit-Learn Settings"</ref> section.) Next, I should read at least some of the underlying obituaries to make sure I'm not getting false signals from any terms. If I read Du Bois's obituary, for example, I may discover that mentions of his work "The Encyclopedia of the Negro," contribute at least partially to the overall score of the word <emph>negro</emph>.</p>
<p>Likewise, I can discover that Bly's obituary does include words like <emph>journalism</emph>, <emph>journalistic</emph>, <emph>newspapers</emph>, and <emph>writing</emph>, but the obituary is very short, meaning most words mentioned in it occur only once or twice, which means that words with very high <hi rend="bold">idf</hi> scores are even more likely to top her list. I really want <hi rend="bold">tf</hi> and <hi rend="bold">idf</hi> to be balanced, so I could rule out words that appear in only a few documents, or I could ignore results for obituaries below a certain word count.</p>
<p>Finally, I can design tests to measure directly questions like: were obituaries of African Americans are more likely to mention race? I think the prediction that they did is a good hypothesis, but I should still subject my generalizations to scrutiny before I form conclusions.</p>
</div><div type="3"><head>Some Ways Tf-idf Can Be Used in Computational History</head>
<p>As I have described, <hi rend="bold">tf-idf</hi> has its origins in information retrieval, and the idea of weighting term frequencies against norms in a larger corpus continues to be used to power various aspects of everyday web applications, especially text-based search engines. However, in a cultural analytics or computational history context, <hi rend="bold">tf-idf</hi> is suited for a particular set of tasks. These uses tend to fall into one of three groups.</p>
<div type="4"><head>1. As an Exploratory Tool or Visualization Technique</head>
<p>As I've already demonstrated, terms lists with <hi rend="bold">tf-idf</hi> scores for each document in a corpus can be a strong interpretive aid in themselves, they can help generate hypotheses or research questions. Word lists can also be the building bocks for more sophisticated browsing and visualization strategies. <ref target="http://jonathanstray.com/a-full-text-visualization-of-the-iraq-war-logs">"A full-text visualization of the Iraq War Logs"</ref>, by Jonathan Stray and Julian Burgess, is a good example of this use case.<ref type="footnotemark" target="#note_11"/> Using <hi rend="bold">tf-idf</hi>-transformed features, Stray and Burgess build a network visualization that positions Iraq War logs in relation to their most distinctive keywords. This way of visualizing textual information led Stray to develop <ref target="https://www.overviewdocs.com">the Overview Project</ref>, which provides a dashboard for users to visualize and search thousands of documents at a time. We could use this kind of approach to graph our obituaries corpus and see if there are keyword communities.</p>
</div><div type="4"><head>2. Textual Similarity and Feature Sets</head>
<p>Since <hi rend="bold">tf-idf</hi> will often produce lower scores for high frequency function words and increased scores for terms related to the topical signal of a text, it is well suited for tasks involving textual similarity. A search index will often perform <hi rend="bold">tf-idf</hi> on a corpus and return ranked results to user searches by looking for documents with the highest cosine similarity to the user's search string. The same logic can be used to ask a question like "Which obituary in our corpus is most similar to Nellie Bly's obituary?"</p>
<p>Similarly, we could use <hi rend="bold">tf-idf</hi> to discover the top terms related to a document or a group of documents. For example, I could gather together a selection of obituaries about journalists (Bly included) and combine them into one document before running <hi rend="bold">tf-idf</hi>. The output for that document would now work as a heuristic for terms that are distinctive in my journalism obituaries in the corpus when compared with other obituaries in the corpus. I could use such a term list for a range of other computational tasks.</p>
</div><div type="4"><head>3. As a Pre-processing Step</head>
<p>The above paragraphs gesture at why <hi rend="bold">tf-idf</hi> pre-processing is so often used with machine learning. <hi rend="bold">Tf-idf</hi>-transformed features tend to have more predictive value than raw term frequencies, especially when classifying a supervised machine learning model, in part because it tends to increase the weight of topic words and reduce the weight of high frequency function words. One notable exception to this generalization is authorship attribution, where high frequency function words are highly predictive. As I will show in the <ref target="#scikit-learn-settings">"Scikit-Learn Settings"</ref> section, <hi rend="bold">tf-idf</hi> can also be used to cull machine learning feature lists and, often, building a model with fewer features is desirable.</p>
</div></div><div type="3"><head>Potential Variations of Tf-idf</head>
<div type="4"><head>Scikit-Learn Settings</head>
<p>The Scikit-Learn <code rend="inline">TfidfVectorizer</code> has several internal settings that can be changed to affect the output. In general, these settings all have pros and cons; there's no singular, correct way to preset them and produce output. Instead, it's best to understand exactly what each setting does so that you can describe and defend the choices you've made. The full list of parameters is described in <ref target="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html">Scikit-Learn's documentation</ref>, but here are some of the most important settings:</p>
<div type="5"><head>1. stopwords</head>
<p>In my code, I used <code rend="inline">python stopwords=None</code> but <code rend="inline">python stopwords='english'</code> is available. This setting will filter out words using a <ref target="https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/feature_extraction/_stop_words.py">preselected list</ref> of high frequency function words such as 'the', 'to', and 'of'. Depending on your settings, many of these terms will have low <hi rend="bold">tf-idf</hi> scores regardless because they tend to be found in all documents. For a discussion of some publicly available stop word lists (including Scikit-Learn's), see <ref target="https://aclweb.org/anthology/W18-2502">"Stop Word Lists in Free Open-source Software Packages"</ref>.</p>
</div><div type="5"><head>2. min_df, max_df</head>
<p>These settings control the minimum number of documents a term must be found in to be included and the maximum number of documents a term can be found in in order to be included. Either can be expressed as a decimal between 0 and 1 indicating the percent threshold, or as a whole number that represents a raw count. Setting max_df below .9 will typically remove most or all stopwords.</p>
</div><div type="5"><head>3. max_features</head>
<p>This parameter can be used to winnow out terms by frequency before running tf-idf. It can be especially useful in a machine learning context when you do not wish to exceed a maximum recommended number of term features.</p>
</div><div type="5"><head>4. norm, smooth_idf, and sublinear_tf</head>
<p>Each of these will affect the range of numerical scores that the <hi rend="bold">tf-idf</hi> algorithm outputs. norm supports l1 and l2 normalization, which you can read about on <ref target="https://machinelearningmastery.com/vector-norms-machine-learning/">machinelearningmastery.com</ref>. Smooth-idf adds one to each document frequency score, "as if an extra document was seen containing every term in the collection exactly once." Sublinear_tf applies another scaling transformation, replacing tf with log(tf). For more on <hi rend="bold">tf-idf</hi> smoothing and normalization, see Manning, Raghavan, and Sch&#252;tze.<ref type="footnotemark" target="#note_12"/></p>
</div></div><div type="4"><head>Beyond Term Features</head>
<p>Since the basic idea of <hi rend="bold">tf-idf</hi> is to weight term counts against the number of documents in which terms appear, the same logic can be used on other text-based features. For example, it is relatively straightforward to combine <hi rend="bold">tf-idf</hi> with <ref target="https://nlp.stanford.edu/IR-book/html/htmledition/stemming-and-lemmatization-1.html">stemming or lemmatization</ref>. Stemming and lemmatization are two common ways to group together different word forms/inflections; for example, the stem of both <emph>happy</emph> and <emph>happiness</emph> is <emph>happi</emph>, and the lemma of both is <emph>happy</emph>. After stemming or lemmatization, stem or lemma counts can be substituted for term counts, and the <hi rend="bold">(s/l)f-idf</hi> transformation can be applied. Each stem or lemma will have a higher <hi rend="bold">df</hi> score than each of the words it groups together, so lemmas or stems with many word variants will tend to have lower <hi rend="bold">tf-idf</hi> scores.</p>
<p>Similarly, the <hi rend="bold">tf-idf</hi> transformation can be applied to n-grams. A Fivethirtyeight.com post from March 2016 called <ref target="https://fivethirtyeight.com/features/these-are-the-phrases-each-gop-candidate-repeats-most/">"These Are The Phrases Each GOP Candidate Repeats Most"</ref> uses such an approach to perform the inverse-document frequency calculation on phrases rather than words.<ref type="footnotemark" target="#note_13"/></p>
</div></div><div type="3"><head>Tf-idf and Common Alternatives</head>
<p><hi rend="bold">Tf-idf</hi> can be compared with several other methods of isolating and/or ranking important term features in a document or collection of documents. This section provides a brief mention of four related but distinct measures that target similar but not identical aspects of textual information.</p>
<div type="4"><head>1. Keyness</head>
<p>Keyness is a catchall term for a constellation of statistical measures that attempt to indicate the numerical significance of a term to a document or set of documents, in direct comparison with a larger set of documents or corpus. Depending on how we set up our <hi rend="bold">tf-idf</hi> transformation, it may isolate many of a document's most important features, but <hi rend="bold">tf-idf</hi> is not as precise as the most commonly used measures of keyness. Rather than changing a document's term frequency scores, keyness testing produces a numerical indicator of how statistically typical or atypical the term's usage in a text is. With a <ref target="https://en.wikipedia.org/wiki/Chi-squared_test">Chi-square test</ref>, for example, we can evaluate the relationship of a term frequency to an established norm, and derive a <ref target="https://en.wikipedia.org/wiki/P-value">P-value</ref> indicating the probability of encountering the observed difference in a random sample. For more information on keyness, see Bondi and Scott.<ref type="footnotemark" target="#note_14"/></p>
</div><div type="4"><head>2. Topic Models</head>
<p>Topic modeling and <hi rend="bold">tf-idf</hi> are radically different techniques, but I find that newcomers to digital humanities often want to run topic modeling on a corpus as a first step and, in at least some of those cases, running <hi rend="bold">tf-idf</hi> instead of generating topic models would be preferable.<ref type="footnotemark" target="#note_15"/> <hi rend="bold">Tf-idf</hi> is especially appropriate if you are looking for a way to get a bird's eye view of your corpus early in the exploratory phase of your research because the algorithm is transparent and the results are reproducible. As Ben Schmidt suggests, scholars using topic modeling need to know that "topics may not be as coherent as they assume."<ref type="footnotemark" target="#note_16"/> This is one reason <hi rend="bold">tf-idf</hi> is integrated into <ref target="https://www.overviewdocs.com">the Overview Project</ref>. Topic models can also help scholars explore their corpora, and they have several advantages over other techniques, namely that they suggest broad categories or communities of texts, but this a general advantage of unsupervised clustering methods. Topic models are especially appealing because documents are assigned scores for how well they fit each topic, and because topics are represented as lists of co-occurring terms, which provides a strong sense of how terms relate to groupings. However, the probabilistic model behind topic models is sophisticated, and it's easy to warp your results if you don't understand what you're doing. The math behind <hi rend="bold">tf-idf</hi> is lucid enough to depict in a spreadsheet.</p>
</div><div type="4"><head>3. Automatic Text Summarization</head>
<p>Text summarization is yet another way to explore a corpus. Rada Mihalcea and Paul Tarau, for example, have published on TextRank, "a graph-based ranking model for text processing" with promising applications for keyword and sentence extraction.<ref type="footnotemark" target="#note_17"/> As with topic modeling, TextRank and <hi rend="bold">tf-idf</hi> are altogether dissimilar in their approach to information retrieval, yet the goal of both algorithms has a great deal of overlap. It may be appropriate for your research, especially if your goal is to get a relatively quick a sense of your documents' contents before designing a larger research project.</p>
</div></div></div>
      <div type="2"><head>References and Further Reading</head>
<list type="unordered">
<item>
<p>Beckman, Milo. "These Are The Phrases Each GOP Candidate Repeats Most," <emph>FiveThirtyEight</emph>, March 10, 2016. <ref target="https://fivethirtyeight.com/features/these-are-the-phrases-each-gop-candidate-repeats-most/">https://fivethirtyeight.com/features/these-are-the-phrases-each-gop-candidate-repeats-most/</ref></p>
</item>
<item>
<p>Bennett, Jessica, and Amisha Padnani. "Overlooked," March 8, 2018. <ref target="https://www.nytimes.com/interactive/2018/obituaries/overlooked.html">https://www.nytimes.com/interactive/2018/obituaries/overlooked.html</ref></p>
</item>
<item>
<p>Blei, David M., Andrew Y. Ng, and Michael I. Jordan, "Latent Dirichlet Allocation" <emph>Journal of Machine Learning Research</emph> 3 (January 2003): 993-1022.</p>
</item>
<item>
<p>Bondi, Marina, and Mike Scott, eds. <emph>Keyness in Texts</emph>. Philadelphia: John Benjamins, 2010.</p>
</item>
<item>
<p>Bowles, Nellie. "Overlooked No More: Karen Sparck Jones, Who Established the Basis for Search Engines" <emph>The New York Times</emph>, January 2, 2019. <ref target="https://www.nytimes.com/2019/01/02/obituaries/karen-sparck-jones-overlooked.html">https://www.nytimes.com/2019/01/02/obituaries/karen-sparck-jones-overlooked.html</ref></p>
</item>
<item>
<p>Documentation for TfidfVectorizer. <ref target="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html">https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html</ref></p>
</item>
<item>
<p>Grimmer, Justin and King, Gary, Quantitative Discovery from Qualitative Information: A General-Purpose Document Clustering Methodology (2009). APSA 2009 Toronto Meeting Paper. Available at SSRN: <ref target="https://ssrn.com/abstract=1450070">https://ssrn.com/abstract=1450070</ref></p>
</item>
<item>
<p>"Ida M. Tarbell, 86, Dies in Bridgeport" <emph>The New York Times</emph>, January 7, 1944, 17. <ref target="https://www.nytimes.com">https://www.nytimes.com</ref></p>
</item>
<item>
<p>Manning, C.D., P. Raghavan, and H. Sch&#252;tze, <emph>Introduction to Information Retrieval</emph>. Cambridge: Cambridge University Press, 2008.</p>
</item>
<item>
<p>Mihalcea, Rada, and Paul Tarau. "Textrank: Bringing order into text." In Proceedings of the 2004 conference on empirical methods in natural language processing. 2004.</p>
</item>
<item>
<p>"Nellie Bly, Journalist, Dies of Pneumonia" <emph>The New York Times</emph>, January 28, 1922, 11. <ref target="https://www.nytimes.com">https://www.nytimes.com</ref></p>
</item>
<item>
<p>Salton, G. and M.J. McGill, <emph>Introduction to Modern Information Retrieval</emph>. New York: McGraw-Hill, 1983.</p>
</item>
<item>
<p>Schmidt, Ben. "Do Digital Humanists Need to Understand Algorithms?" <emph>Debates in the Digital Humanities 2016</emph>. Online edition. Minneapois: University of Minnesota Press. <ref target="http://dhdebates.gc.cuny.edu/debates/text/99">http://dhdebates.gc.cuny.edu/debates/text/99</ref></p>
</item>
<item>
<p>--. "Words Alone: Dismantling Topic Models in the Humanities," <emph>Journal of Digital Humanities</emph>. Vol. 2, No. 1 (2012): n.p. <ref target="http://journalofdigitalhumanities.org/2-1/words-alone-by-benjamin-m-schmidt/">http://journalofdigitalhumanities.org/2-1/words-alone-by-benjamin-m-schmidt/</ref></p>
</item>
<item>
<p>Sp&#228;rck Jones, Karen. "A Statistical Interpretation of Term Specificity and Its Application in Retrieval." Journal of Documentation 28, no. 1 (1972): 11&#8211;21.</p>
</item>
<item>
<p>Stray, Jonathan, and Julian Burgess. "A Full-text Visualization of the Iraq War Logs," December 10, 2010 (Update April 2012). <ref target="http://jonathanstray.com/a-full-text-visualization-of-the-iraq-war-logs">http://jonathanstray.com/a-full-text-visualization-of-the-iraq-war-logs</ref></p>
</item>
<item>
<p>Underwood, Ted. "Identifying diction that characterizes an author or genre: why Dunning's may not be the best method," <emph>The Stone and the Shell</emph>, November 9, 2011. <ref target="https://tedunderwood.com/2011/11/09/identifying-the-terms-that-characterize-an-author-or-genre-why-dunnings-may-not-be-the-best-method/">https://tedunderwood.com/2011/11/09/identifying-the-terms-that-characterize-an-author-or-genre-why-dunnings-may-not-be-the-best-method/</ref></p>
</item>
<item>
<p>--. "The Historical Significance of Textual Distances", Preprint of LaTeCH-CLfL Workshop, COLING, Santa Fe, 2018. <ref target="https://arxiv.org/abs/1807.00181">https://arxiv.org/abs/1807.00181</ref></p>
</item>
<item>
<p>van Rossum,  Guido, Barry Warsaw, and Nick Coghlan. "PEP 8 -- Style Guide for Python Code." July 5, 2001. Updated July 2013. <ref target="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</ref></p>
</item>
<item>
<p>Whitman, Alden. "Upton Sinclair, Author, Dead; Crusader for Social Justice, 90" <emph>The New York Times</emph>, November 26, 1968, 1, 34. <ref target="https://www.nytimes.com">https://www.nytimes.com</ref></p>
</item>
<item>
<p>"W. E. B. DuBois Dies in Ghana; Negro Leader and Author, 95" <emph>The New York Times</emph>, August 28, 1963, 27. <ref target="https://www.nytimes.com">https://www.nytimes.com</ref></p>
</item>
<item>
<p>"Willa Cather Dies; Noted Novelist, 70" <emph>The New York Times</emph>, April 25, 1947, 21. <ref target="https://www.nytimes.com">https://www.nytimes.com</ref></p>
</item>
</list>
<div type="3"><head>Alternatives to Anaconda</head>
<p>If you are not using Anaconda, you will need to cover the following dependencies:</p>
<list type="ordered">
<item>Install Python 2 or 3 (preferably Python 3.6 or later)</item>
<item>Recommended: install and run a virtual environment</item>
<item>Install the Scikit-Learn library and its dependencies (see <ref target="http://scikit-learn.org/stable/install.html">http://scikit-learn.org/stable/install.html</ref>).</item>
<item>Install Jupyter Notebook and its dependencies</item>
</list>
</div></div>
      <div type="2"><head>Endnotes</head>
<p><ref type="footnotemark" target="#note_1"/> : Underwood, Ted. "Identifying diction that characterizes an author or genre: why Dunning's may not be the best method," <emph>The Stone and the Shell</emph>, November 9, 2011. <ref target="https://tedunderwood.com/2011/11/09/identifying-the-terms-that-characterize-an-author-or-genre-why-dunnings-may-not-be-the-best-method/">https://tedunderwood.com/2011/11/09/identifying-the-terms-that-characterize-an-author-or-genre-why-dunnings-may-not-be-the-best-method/</ref></p>
<p><ref type="footnotemark" target="#note_2"/> : Bennett, Jessica, and Amisha Padnani. "Overlooked," March 8, 2018. <ref target="https://www.nytimes.com/interactive/2018/obituaries/overlooked.html">https://www.nytimes.com/interactive/2018/obituaries/overlooked.html</ref></p>
<p><ref type="footnotemark" target="#note_3"/> : This dataset is from a version of <emph>The New York Times</emph> "On This Day" website that hasn't been updated since January 31, 2011, and it has been replaced by a newer, sleeker blog located at <ref target="https://learning.blogs.nytimes.com/on-this-day/">https://learning.blogs.nytimes.com/on-this-day/</ref>. What's left on the older "On This Day" Website is a static .html file for each day of the year (0101.html, 0102.html, etc.), including a static page for February 29th (0229.html). Content appears to have been overwritten whenever it was last updated, so there are no archives of content by year. Presumably, the "On This Day" entries for January 1 - January 31 were last updated on their corresponding days in 2011. Meanwhile, February 1 - December 31 were probably last updated on their corresponding days in 2010. The page representing February 29 was probably last updated on February 29, 2008.</p>
<p><ref type="footnotemark" target="#note_4"/> : Sp&#228;rck Jones, Karen. "A Statistical Interpretation of Term Specificity and Its Application in Retrieval." <emph>Journal of Documentation</emph> vol. 28, no. 1 (1972): 16.</p>
<p><ref type="footnotemark" target="#note_5"/> : Bowles, Nellie. "Overlooked No More: Karen Sp&#228;rck Jones, Who Established the Basis for Search Engines" <emph>The New York Times</emph>, January 2, 2019. <ref target="https://www.nytimes.com/2019/01/02/obituaries/karen-sparck-jones-overlooked.html">https://www.nytimes.com/2019/01/02/obituaries/karen-sparck-jones-overlooked.html</ref></p>
<p><ref type="footnotemark" target="#note_6"/> : "Nellie Bly, Journalist, Dies of Pneumonia" <emph>The New York Times</emph>, January 28, 1922, 11. <ref target="https://www.nytimes.com">https://www.nytimes.com</ref></p>
<p><ref type="footnotemark" target="#note_7"/> : Documentation for TfidfVectorizer. <ref target="https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html">https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html</ref></p>
<p><ref type="footnotemark" target="#note_8"/> : Schmidt, Ben. "Do Digital Humanists Need to Understand Algorithms?" <emph>Debates in the Digital Humanities 2016</emph>. Online edition. (Minneapois: University of Minnesota Press): n.p. <ref target="http://dhdebates.gc.cuny.edu/debates/text/99">http://dhdebates.gc.cuny.edu/debates/text/99</ref></p>
<p><ref type="footnotemark" target="#note_9"/> : van Rossum,  Guido, Barry Warsaw, and Nick Coghlan. "PEP 8 -- Style Guide for Python Code." July 5, 2001. Updated July 2013. <ref target="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</ref></p>
<p><ref type="footnotemark" target="#note_10"/> : "Ida M. Tarbell, 86, Dies in Bridgeport" <emph>The New York Times</emph>, January 7, 1944, 17. <ref target="https://www.nytimes.com">https://www.nytimes.com</ref>; "Nellie Bly, Journalist, Dies of Pneumonia" <emph>The New York Times</emph>, January 28, 1922, 11. <ref target="https://www.nytimes.com">https://www.nytimes.com</ref>; "W. E. B. DuBois Dies in Ghana; Negro Leader and Author, 95" <emph>The New York Times</emph>, August 28, 1963, 27. <ref target="https://www.nytimes.com">https://www.nytimes.com</ref>; Whitman, Alden. "Upton Sinclair, Author, Dead; Crusader for Social Justice, 90" <emph>The New York Times</emph>, November 26, 1968, 1, 34. <ref target="https://www.nytimes.com">https://www.nytimes.com</ref>; "Willa Cather Dies; Noted Novelist, 70" <emph>The New York Times</emph>, April 25, 1947, 21. <ref target="https://www.nytimes.com">https://www.nytimes.com</ref></p>
<p><ref type="footnotemark" target="#note_11"/> : Stray, Jonathan, and Julian Burgess. "A Full-text Visualization of the Iraq War Logs," December 10, 2010 (Update April 2012). <ref target="http://jonathanstray.com/a-full-text-visualization-of-the-iraq-war-logs">http://jonathanstray.com/a-full-text-visualization-of-the-iraq-war-logs</ref></p>
<p><ref type="footnotemark" target="#note_12"/> : Manning, C.D., P. Raghavan, and H. Sch&#252;tze, <emph>Introduction to Information Retrieval</emph>. (Cambridge: Cambridge University Press, 2008): 118-120.</p>
<p><ref type="footnotemark" target="#note_13"/> : Beckman, Milo. "These Are The Phrases Each GOP Candidate Repeats Most," <emph>FiveThirtyEight</emph>, March 10, 2016. <ref target="https://fivethirtyeight.com/features/these-are-the-phrases-each-gop-candidate-repeats-most/">https://fivethirtyeight.com/features/these-are-the-phrases-each-gop-candidate-repeats-most/</ref></p>
<p><ref type="footnotemark" target="#note_14"/> : Bondi, Marina, and Mike Scott, eds. <emph>Keyness in Texts</emph>. (Philadelphia: John Benjamins, 2010).</p>
<p><ref type="footnotemark" target="#note_15"/> : <hi rend="bold">Tf-idf</hi> is not typically a recommended pre-processing step when generating topic models. See <ref target="https://datascience.stackexchange.com/questions/21950/why-we-should-not-feed-lda-with-tfidf">https://datascience.stackexchange.com/questions/21950/why-we-should-not-feed-lda-with-tfidf</ref></p>
<p><ref type="footnotemark" target="#note_16"/> : Schmidt, Ben. "Words Alone: Dismantling Topic Models in the Humanities," <emph>Journal of Digital Humanities</emph>. Vol. 2, No. 1 (2012): n.p. <ref target="http://journalofdigitalhumanities.org/2-1/words-alone-by-benjamin-m-schmidt/">http://journalofdigitalhumanities.org/2-1/words-alone-by-benjamin-m-schmidt/</ref></p>
<p><ref type="footnotemark" target="#note_17"/> : Mihalcea, Rada, and Paul Tarau. "Textrank: Bringing order into text." In <emph>Proceedings of the 2004 conference on empirical methods in natural language processing</emph>. 2004.</p>
</div>
    </body>
  </text>
</TEI>
