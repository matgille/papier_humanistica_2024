<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:id="intro-to-linked-data">
  <teiHeader>
 <fileDesc>
  <titleStmt>
   <title>Introduction to the Principles of Linked Open Data</title>
  <author role="original_author">Jonathan Blaney</author><editor role="reviewers"><persName>Terhi Nurmikko-Fuller</persName><persName>Matthew Lincoln</persName></editor><editor role="editors">Adam Crymble</editor></titleStmt>
  <publicationStmt>
   <idno type="doi">10.46430/phen0068</idno><date type="published">05/07/2017</date><p>Lesson reviewed and published in Programming Historian.</p>
  </publicationStmt>
  <sourceDesc>
  <p>Born digital, in a markdown format. This lesson is original. Available translations are the following:<ref type="translations" target="#introducao-dados-abertos-conectados #introduccion-datos-abiertos-enlazados"/></p></sourceDesc>
 </fileDesc>
 <profileDesc><abstract><p>Introduces core concepts of Linked Open Data, including URIs, ontologies, RDF formats, and a gentle intro to the graph query language SPARQL.
</p></abstract><textClass><keywords><term xml:lang="en">lod</term></keywords></textClass></profileDesc>
</teiHeader>
  <text xml:lang="en">
    <body>
      <div type="2"><head>Introduction and Lesson Scope</head>
<p>This lesson offers a brief and concise introduction to <ref target="https://en.wikipedia.org/wiki/Linked_data#Linked_open_data">Linked Open Data</ref> (LOD). No prior knowledge is assumed. Readers should gain a clear understanding of the concepts behind linked open data, how it is used, and how it is created. The tutorial is split into five parts, plus further reading:</p>
<list type="ordered">
<item>Linked open data: what is it?</item>
<item>The role of the <ref target="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">Uniform Resource Identifier</ref> (URI)</item>
<item>How LOD organises knowledge: <ref target="https://en.wikipedia.org/wiki/Ontology_(information_science)">ontologies</ref></item>
<item>The <ref target="https://en.wikipedia.org/wiki/Resource_Description_Framework">Resource Description Framework</ref> (RDF) and data formats</item>
<item>Querying linked open data with <ref target="https://en.wikipedia.org/wiki/SPARQL">SPARQL</ref></item>
<item>Further reading and resources</item>
</list>
<p>The tutorial should take a couple of hours to complete, and you may find it helpful to re-read sections to solidify your understanding. Technical terms have been linked to their corresponding page on Wikipedia, and you are encouraged to pause and read about terms that you find challenging. After having learned some of the key principles of LOD, the best way to improve and solidify that knowledge is to practise. This tutorial provides opportunities to do so. By the end of the course you should understand the basics of LOD, including key terms and concepts.</p>
<p>If you need to learn how to explore LOD using the query language <ref target="https://en.wikipedia.org/wiki/SPARQL">SPARQL</ref>, I recommend Matthew Lincoln's <ref target="/lessons/graph-databases-and-SPARQL">'Using SPARQL to access Linked Open Data'</ref>, which follows on practically from the conceptual overview offered in this lesson.</p>
<p>In order to provide readers with a solid grounding in the basic principles of LOD, this tutorial will not be able to offer a comprehensive coverage of all LOD concepts. The following two LOD concepts will <emph>not</emph> be the focus of this lesson:</p>
<list type="ordered">
<item>The <ref target="https://en.wikipedia.org/wiki/Semantic_Web">semantic web</ref> and <ref target="https://en.wikipedia.org/wiki/Semantic_reasoner">semantic reasoning</ref> of <ref target="https://en.wikipedia.org/wiki/Data_set">datasets</ref>. A semantic reasoner would deduce that George VI is the brother or half-brother of Edward VIII, given the fact that a) Edward VIII is the son of George V and b) George VI is the son of George V. This tutorial does not focus on this type of task.</item>
<item>Creating and uploading linked open datasets to the <ref target="http://linkeddatacatalog.dws.informatik.uni-mannheim.de/state/">linked data cloud</ref>. Sharing your LOD is an important principle, which is encouraged below. However, the practicalities of contributing your LOD to the linked data cloud are beyond the scope of this lesson. Some resources that can help you get started with this task are available at the end of this tutorial.</item>
</list>
</div>
      <table>
<row>
<cell role="label">the subject</cell>
<cell role="label">the predicate</cell>
<cell role="label">the object</cell>
</row>
<row>
<cell>person 64183282</cell>
<cell>representedInUKParliament</cell>
<cell>"blackburn1955-current"</cell>
</row>
</table>
      <div type="2"><head>The role of the Uniform Resource Identifier (URI)</head>
<p>An essential part of LOD is the <ref target="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">Uniform Resource Identifier</ref>, or URI. The URI is a reliably unique way of representing an entity (a person, an object, a relationship, etc), in a fashion that is usable by everyone in the world.</p>
<p>In the previous section we used two different numbers to identify our two different Jack Straws.</p>
<ab><code xml:id="code_intro-to-linked-data_6" corresp="code_intro-to-linked-data_6.txt" rend="block"/></ab>
<p>The problem is that around the world there are many databases that contain people with these numbers, and they're probably all different people. Outside of our immediate context these numbers don't identify unique individuals. Let's try to fix that. Here are these same identifiers but as URIs:</p>
<ab><code xml:id="code_intro-to-linked-data_7" corresp="code_intro-to-linked-data_7.txt" rend="block"/></ab>
<p>Just as the unique number disambiguated our two Jack Straws, the full URI above helps us disambiguate between all of the different authority files out there. In this case, it's clear that we are using VIAF as our authority file. You have already seen this form of disambuguation many times on the web. There are many websites round the world with pages called <code rend="inline">/home</code> or <code rend="inline">/faq</code>. But there is no confusion because the <ref target="https://en.wikipedia.org/wiki/Domain_name">domain</ref> (the first part of the <ref target="https://en.wikipedia.org/wiki/Uniform_Resource_Locator">Uniform Resource Locator</ref> (URL) - eg. <code rend="inline">bbc.co.uk</code>) is unique and thus all pages that are part of that domain are unique from other <code rend="inline">/faq</code> pages on other websites. In the address <code rend="inline">http://www.bbc.co.uk/faqs</code> it is the <code rend="inline">bbc.co.uk</code> part which makes the subsequent pages unique. This is so obvious to people who use the web all the time that they don't think about it. You probably also know that if you want to start a website called <code rend="inline">bbc.co.uk</code> you can't, because that name has already been registered with the appropriate authority, which is the <ref target="https://en.wikipedia.org/wiki/Domain_Name_System">Domain Name System</ref>. The registration guarantees uniqueness. URIs also have to be unique.</p>
<p>While the examples above look like URLs, it is also possible to construct a URI that looks nothing like a URL. We have many ways of uniquely identifying people and things and we rarely think or worry about it. Barcodes, passport numbers, and even your postal address are all designed to be unique. Mobile phone numbers are frequently put up as shop signs precisely because they are unique. All of these could be used as URIs.</p>
<p>When we wanted to create URIs for the entities described by the '<ref target="http://www.history.ac.uk/projects/digital/tobias">Tobias</ref>' project, we chose a URL-like structure, and chose to use our institutional webspace, setting aside <code rend="inline">data.history.ac.uk/tobias-project/</code> as a place dedicated to hosting these URIs. By putting it at <code rend="inline">data.history.ac.uk</code> rather than <code rend="inline">history.ac.uk</code>, there was a clear separation between URIs and the pages of the website. For example, one of the URIs from the Tobias project was <ref target="http://data.history.ac.uk/tobias-project/person/15601">http://data.history.ac.uk/tobias-project/person/15601</ref>. While the format of the abovementioned URIs is the same as a URL, they do not link to web pages (try pasting it of them into a web browser). Many people new to LOD find this confusing. All URLs are URIs but not all URIs are URLs. A URI can describe anything at all, whereas URL describes the location of something on the web. So a URL tells you the location of a web page or a file or something similar. A URI just does the job of identifying something. Just as the International Standard Book Number, or <ref target="https://www.iso.org/standard/36563.html">ISBN</ref> <code rend="inline">978-0-1-873354-6</code> uniquely identifies a hardback edition of <emph>Baptism, Brotherhood and Belief in Reformation Germany</emph> by Kat Hill, but doesn't tell you where to get a copy. For that you would need something like a library <ref target="https://en.wikipedia.org/wiki/Accession_number_(library_science)">shelfmark</ref>, which gives you an exact location on a shelf of a specific library.</p>
<p>There is a little bit of jargon around URIs. People talk about whether they are, or are not, <ref target="https://en.wikipedia.org/wiki/Reference_(computer_science)">dereferenceable</ref>. That just means <emph>can it be turned from an abstract reference into something else?</emph> For example, if you paste a URI into the address bar of a browser, will it return something? The VIAF URI for historian Simon Schama is:</p>
<ab><code xml:id="code_intro-to-linked-data_8" corresp="code_intro-to-linked-data_8.txt" rend="block"/></ab>
<p>If you put that into the browser you will get back a web page about Simon Schama which contains structured data about him and his publishing history. This is very handy - for one thing, it's not obvious from the URI who or even what is being referred to. Similarly, if we treated a mobile phone number (with international code) as the URI for a person then it should be dereferenceable. Someone might answer the phone, and it might even be Schama.</p>
<p>But this is not essential. Lots of URIs are not dereferenceable, as in the example above from the Tobias project. You can't find it anywhere; it is a convention.</p>
<p>The VIAF example leads us on to another important thing about URIs: don't make them up unless you have to. People and organisations have
been making concerted efforts to construct good URI lists and LOD isn't going to work effectively if people duplicate that work by creating new URIs unnecessarily. For example VIAF has the support of many international libraries. If you want to construct URIs for people, VIAF is a very good choice. If you can't find some people in VIAF, or other authority lists, only then might you need to make up your own.</p>
</div>
      <table>
<row>
<cell role="label">pupilID</cell>
<cell role="label">teacherID</cell>
</row>
<row>
<cell>72</cell>
<cell>40</cell>
</row>
<row>
<cell>56</cell>
<cell>28</cell>
</row>
<row>
<cell>49</cell>
<cell>28</cell>
</row>
<row>
<cell>35</cell>
<cell>17</cell>
</row>
<row>
<cell>31</cell>
<cell>17</cell>
</row>
</table>
      <div type="2"><head>RDF and data formats</head>
<p>LOD uses a standard, defined by the <ref target="https://www.w3.org/">World Wide Web Consortium</ref>, or W3C, called <emph><ref target="https://en.wikipedia.org/wiki/Resource_Description_Framework">Resource Description Framework</ref></emph>, or just RDF. Standards are useful as long as they are widely adopted - think of the metre or standard screw sizes - even if they are essentially arbitrary. RDF has been widely adopted as the LOD standard.</p>
<p>You will often hear LOD referred to simply as RDF. We've delayed talking about RDF until now because it's rather abstract. RDF is a <ref target="https://en.wikipedia.org/wiki/Data_model">data model</ref> that describes how data is structured on a theoretical level. So the insistence on using triples (rather than four parts, or two or nine, for example) is a rule in RDF. But when it comes to more practical matters you have some choices about implementation. So RDF tells you what you have to do but not exactly how you have to do it. These choices break down into two areas: how you write things down (serialisation) and the relationships your triples describe.</p>
<div type="3"><head>Serialisation</head>
<p><ref target="https://en.wikipedia.org/wiki/Serialization">Serialisation</ref> is the technical term for 'how you write things down'. Standard Chinese (Mandarin) can be written in traditional characters, simplified characters or Pinyin romanisation and the language itself doesn't change. Similarly RDF can be written in various forms. Here we'll look at two (there are others, but for simplicity's sake, we will focus on these):</p>
<list type="ordered">
<item><ref target="https://en.wikipedia.org/wiki/Turtle_(syntax)">Turtle</ref></item>
<item><ref target="https://en.wikipedia.org/wiki/RDF/XML">RDF/XML</ref>.</item>
</list>
<p>Recognising what serialisation you are looking at means that you can then choose appropriate tools designed for that format. For example, RDF can come serialised in <ref target="https://en.wikipedia.org/wiki/XML">XML</ref> format. You can then use a tool or code library designed for parsing that particular format, which is helpful if you already know how to work with it. Recognising the format also gives you the right keywords for searching online for help. Many resources offer their LOD databases for download and you may be able to choose which serialisation you want to download.</p>
<div type="4"><head>Turtle</head>
<p>'Turtle' is a play on words. 'Tur' is short for 'terse', and 'tle' - is short for 'triple language'. Turtle is a pleasantly simple way of writing triples.</p>
<p>Turtle uses aliases or a shortcuts known as <ref target="https://www.w3.org/TeamSubmission/turtle/#sec-tutorial">prefixes</ref>, which saves us having to write out full URIs every time. Let's go back to the URI we invented in the previous section:</p>
<ab><code xml:id="code_intro-to-linked-data_12" corresp="code_intro-to-linked-data_12.txt" rend="block"/></ab>
<p>We don't want to type this out every time we refer to this person (Jack Straw, you'll remember). So we just have to announce our shortcut:</p>
<ab><code xml:id="code_intro-to-linked-data_13" corresp="code_intro-to-linked-data_13.txt" rend="block"/></ab>
<p>Then Jack is <code rend="inline">toby:15601</code>, which replaces the long URI and is easier on the eye. I have chosen 'toby', but could just as easily chosen any string of letters.</p>
<p>Let's now move from Jack Straw to William Shakespeare and use Turtle to describe some stuff about his works. We'll need to decide on the authority files to use, a process which, as mentioned above, is best gleaned from looking at other LOD sets. Here we'll use <ref target="https://en.wikipedia.org/wiki/Dublin_Core">Dublin Core</ref>, a library <ref target="https://en.wikipedia.org/wiki/Metadata">metadata</ref> standard, as one of our prefixes, the <ref target="https://en.wikipedia.org/wiki/Library_of_Congress_Control_Number">Library of Congress Control Number</ref> authority file for another, and the last one (VIAF) should be familiar to you. Together these three authority files provide unique identifiers for all of the entities I plan to use in this example.:</p>
<ab><code xml:id="code_intro-to-linked-data_14" corresp="code_intro-to-linked-data_14.txt" rend="block"/></ab>
<p>Note the spacing of the full point after the last line. This is Turtle's way of indicating the end. You don't technically have to have the space, but it does make it easier to read after a long string of characters.</p>
<p>In the above example, lccn:n82011242 represents Macbeth; dc:creator links Macbeth to its author; viaf:96994048 represents William Shakespeare.</p>
<p>Turtle also allows you to list triples without bothering to repeat each URI when you've only just used it. Let's add the date when scholars think Macbeth was written, using the Dublin Core attribute-value pair: <code rend="inline">dc:created 'YYYY'</code>:</p>
<ab><code xml:id="code_intro-to-linked-data_15" corresp="code_intro-to-linked-data_15.txt" rend="block"/></ab>
<p>Remember the structure of the triple, discussed in section 1? There we gave this example:</p>
<ab><code xml:id="code_intro-to-linked-data_16" corresp="code_intro-to-linked-data_16.txt" rend="block"/></ab>
<p>The key thing is that the predicate connects the subject and the object. It describes the relationship between them. The subject comes first in the triple, but that's a matter of choice, as we discussed with the example of people who were taught the piano by Liszt.</p>
<p>You can use a semicolon if the subject is the same but the predicate and object are different, or a comma if the subject and predicate are the same and only the object is different.</p>
<ab><code xml:id="code_intro-to-linked-data_17" corresp="code_intro-to-linked-data_17.txt" rend="block"/></ab>
<p>Here we're saying that Shakespeare (96994048) and John Fletcher (12323361) were both the creators of the work <emph>The Two Noble Kinsmen</emph>.</p>
<p>When we looked at ontologies earlier I suggested you have a look at the examples from <ref target="http://web.archive.org/web/20170718143925/http://musicontology.com/docs/getting-started.html">the Music Ontology</ref>. I hope they didn't put you off. Have a look again now. This is still complicated stuff, but do they make more sense now?</p>
<p>One of the most approachable ontologies is Friend of a Friend, or <ref target="https://en.wikipedia.org/wiki/FOAF_(ontology)">FOAF</ref>. This is designed to describe people, and is perhaps for that reason, fairly intuitive. If, for example, you want to write to tell me that this course is the best thing you've ever read, here is my email address expressed as triples in FOAF:</p>
<ab><code xml:id="code_intro-to-linked-data_18" corresp="code_intro-to-linked-data_18.txt" rend="block"/></ab>
</div><div type="4"><head>RDF/XML</head>
<p>By contrast with Turtle, RDF/XML can look a bit weighty. To begin with, let's just convert one triple from the Turtle above, the one that says that Shakespeare was the creator of <emph>The Two Noble Kinsmen</emph>:</p>
<ab><code xml:id="code_intro-to-linked-data_19" corresp="code_intro-to-linked-data_19.txt" rend="block"/></ab>
<p>In RDF/XML, with the prefixes declared inside the XML snippet, this is:</p>
<ab><code xml:id="code_intro-to-linked-data_20" corresp="code_intro-to-linked-data_20.txt" lang="language-xml" rend="block"/></ab>
<p>The RDF/XML format has the same basic information as Turtle, but is written very differently, drawing on the principles of nested XML tags.</p>
<p>Let's move on to a different example to show how RDF/XML combines triples and, at the same time, introduce <ref target="https://en.wikipedia.org/wiki/Simple_Knowledge_Organization_System">Simple Knowledge Organization System</ref> (SKOS), which is designed for encoding thesauri or taxonomies.</p>
<ab><code xml:id="code_intro-to-linked-data_21" corresp="code_intro-to-linked-data_21.txt" rend="block"/></ab>
<p>Here we are saying that the SKOS concept <code rend="inline">21250</code>, abdication, has a preferred label of "abdication". The way it works is that the subject element (including the abdication part, which is an attribute value in XML terms) has the predicate and object nested inside it. The nested element is the predicate and <ref target="https://en.wikipedia.org/wiki/Tree_(data_structure)#Terminology">the leaf node</ref>, is the object. This example is taken from a project to publish a <ref target="http://www.history.ac.uk/projects/digital/tobias">thesaurus of British and Irish History</ref>.</p>
<p>Just as with Turtle, we can add more triples.  So let's declare that the narrower term in our subject hierarchy, one down from <emph>Abdication</emph> is going to be <emph>Abdication crisis (1936)</emph>.</p>
<ab><code xml:id="code_intro-to-linked-data_22" corresp="code_intro-to-linked-data_22.txt" rend="block"/></ab>
<p>Remember how predicates and objects are nested inside the subject? Here we've done that twice with the same subject, so we can make this less verbose by nesting both sets of predicates and objects inside the one subject:</p>
<ab><code xml:id="code_intro-to-linked-data_23" corresp="code_intro-to-linked-data_23.txt" rend="block"/></ab>
<p>If you're familiar with XML this will be like mother's milk to you. If you're not you might prefer a format like Turtle. But the advantage here is that in creating my RDF/XML you can use the usual tools available with XML, like dedicated XML editors and parsers, to check that your RDF/XML is correctly formatted. If you're not an XML person I recommend Turtle, for which you can use an <ref target="http://www.easyrdf.org/converter">online tool</ref> to check your syntax is correct.</p>
</div></div></div>
      <div type="2"><head>Querying RDF with SPARQL</head>
<p>For this final section we will interrogate some LOD and see what you can do with it.</p>
<p>The query language we use for LOD is called <ref target="https://en.wikipedia.org/wiki/SPARQL">SPARQL</ref>. It's one of those recursive acronyms beloved of techie people: <emph>SPARQL Protocol and Query Language</emph>.</p>
<p>As I mentioned at the beginning, <emph>Programming Historian</emph> has <ref target="/lessons/graph-databases-and-SPARQL">a complete lesson</ref>, by Matthew Lincoln, on using SPARQL. My final section here is just an overview of the basic concepts, and if SPARQL piques your interest, you can get a thorough grounding from Lincoln's tutorial.</p>
<p>We're going to run our SPARQL queries on <ref target="https://en.wikipedia.org/wiki/SPARQL">DBpedia</ref>, which is a huge LOD set derived from Wikipedia. As well as being full of information that is very difficult to find through the usual Wikipedia interface, it has several SPARQL "end points" - interfaces where you can type in SPARQL queries and get results from DBpedia's triples.</p>
<p>The SPARQL query end point I use is called <ref target="http://dbpedia.org/snorql/">snorql</ref>. These end points occasionally seem to go offline, so if that should be the case, try searching for <emph>dbpedia sparql</emph> and you should find a similar replacement.</p>
<p>If you go to the snorql URL above you will see at first that a number of prefixes have already been declared for us, which is handy. You'll recognise some of the prefixes now too.</p>
<figure><desc>snorql's default query box, with some prefixes declared for you</desc><graphic url="intro-to-linked-data-fig1.png"/></figure>
<p>In the query box below the prefix declarations you should see:</p>
<ab><code xml:id="code_intro-to-linked-data_24" corresp="code_intro-to-linked-data_24.txt" rend="block"/></ab>
<p>If you've ever written a database query in Structured Query Language, <ref target="https://en.wikipedia.org/wiki/SQL">better known as SQL</ref>, this will look pretty familiar and it will help you to learn SPARQL. If not, don't worry. The keywords used here, SELECT and WHERE are not case sensitive, but some parts of a SPARQL query can be (see below), so I recommend that you stick to the given case throughout the queries in this course.</p>
<p>Here <code rend="inline">SELECT</code> means <emph>return something</emph> and <code rend="inline">*</code> means <emph>give me everything</emph>. <code rend="inline">WHERE</code> introduces a condition, which is where we will put the details of what kinds of thing we want the query to return.</p>
<p>Let's start with something simple to see how this works. Paste (or, better, type out) this into the query box:</p>
<ab><code xml:id="code_intro-to-linked-data_25" corresp="code_intro-to-linked-data_25.txt" rend="block"/></ab>
<p>Hit 'go' and, if you left the drop-down box as 'browse' you should get two columns labelled "b" and "c". (Note that here, searching for a string, case does matter: lyndal_roper will get you no results.)</p>
<figure><desc>top of results lists for a query for all triples with 'Lyndal_Roper' as subject</desc><graphic url="intro-to-linked-data-fig2.png"/></figure>
<p>So what just happened? And how did I know what to type?</p>
<p>I didn't, really, and that is one of the issues with SPARQL end points. When getting to know a dataset you have to try things and find out what terms are used. Because this comes from <emph>Wikipedia</emph>, and I was interested in what information on historians I could find, I went to the <emph>Wikipedia</emph> page for the historian <ref target="https://en.wikipedia.org/wiki/Lyndal_Roper">Lyndal Roper</ref>.</p>
<p>The part at the end of the URL is <code rend="inline">Lyndal_Roper</code> and I concluded that this string is likely to be how Roper is referred to in DBpedia. Because I don't know what else might be in triples that mention Roper I use <code rend="inline">?a</code> and <code rend="inline">?b</code>: these are just place-holders: I could equally well have typed <code rend="inline">?whatever</code> and <code rend="inline">?you_like</code> and the columns would have had those headings. When you want to be more precise about what you are returning, it will be more important to label columns meaningfully.</p>
<p>Try your own SPARQL query now: choose a <emph>Wikipedia</emph> page and copy the end part of the URL, after the final slash, and put it in place of Lyndal_Roper. Then hit 'go'.</p>
<p>From the information you get back from these results it's possible to generate more precise queries. This can be a bit hit-and-miss, at least for me, so don't worry if some don't work.</p>
<p>Back to the results for the query I ran a moment ago:</p>
<ab><code xml:id="code_intro-to-linked-data_26" corresp="code_intro-to-linked-data_26.txt" rend="block"/></ab>
<p>I can see a long list in the column labelled <emph>c</emph>. These are all the attributes Roper has in <emph>DBpedia</emph> and will help us to find other people with these attributes. For example I can see <code rend="inline">http://dbpedia.org/class/yago/Historian110177150</code>. Can I use this to get a list of historians? I'm going to put this into my query but in third place (because that's where it was when I found it in the Lyndal Roper results. My query looks like this:</p>
<ab><code xml:id="code_intro-to-linked-data_27" corresp="code_intro-to-linked-data_27.txt" rend="block"/></ab>
<p>I've made a small change here. If this query works at all then I expect my historians to be in the first column, because 'historian' doesn't look like it could be a predicate: it doesn't function like a verb in a sentence; so I'm going to call my first results column 'historian_name' and my second (which I don't know anything about) 'predicate'.</p>
<p>Run the query. Does it work for you? I get a big list of historians.</p>
<figure><desc>historians, according to DBpedia</desc><graphic url="intro-to-linked-data-fig3.png"/></figure>
<p>So this works for creating lists, which is useful, but it would much more powerful to combine lists, to get intersections of sests. I found a couple more things that might be interesting to query in Lyndal Roper's DBpedia attributes: <ref target="http://dbpedia.org/class/yago/WikicatBritishHistorians">http://dbpedia.org/class/yago/WikicatBritishHistorians</ref> and <ref target="http://dbpedia.org/class/yago/WikicatWomenHistorians">http://dbpedia.org/class/yago/WikicatWomenHistorians</ref>. It's very easy to combine these by asking a for a variable to be returned (in our case this is <code rend="inline">?name</code>) and then using that in multiple lines of a query. Note as well the space and full point at the end of the first line beginning with <code rend="inline">?name</code>:</p>
<ab><code xml:id="code_intro-to-linked-data_28" corresp="code_intro-to-linked-data_28.txt" rend="block"/></ab>
<p>It works! I get five results. At the time of writing, there are five British, women historians in <emph>DBpedia</emph>...</p>
<figure><desc>British historians who are women, according to DBpedia</desc><graphic url="intro-to-linked-data-fig4.png"/></figure>
<p>Only five British women historians? Of course there are, in reality, many more than that, as we could easily show by substituting the name of, say, Alison Weir in our first Lyndal Roper query. This brings us to the problem with <emph>Dbpedia</emph> that I mentioned earlier: it's not very consistently marked up with structural information of the type <emph>DBpedia</emph> uses. Our query can list some British women historians but it turns out that we can't use it to generate a meaningful list of people in this category. All we've found is the people in entries in <emph>Wikipedia</emph> that someone has decided to categorise as "British historian" and "woman historian".</p>
<p>With SPARQL on <emph>DBpedia</emph> you have to be careful of the inconsistencies of crowd-sourced material. You could use SPARQL in exactly the same way on a more curated dataset, for example the UK government data: <ref target="">https://data-gov.tw.rpi.edu//sparql</ref> and expect to get more robust results (there is a brief tutorial for this dataset here: <ref target="">https://data-gov.tw.rpi.edu/wiki/A_crash_course_in_SPARQL</ref>).</p>
<p>However, despite its inconsistencies, <emph>DBpedia</emph> is a great place to learn SPARQL. This has only been an a brief introduction but there is much more in <ref target="/lessons/graph-databases-and-SPARQL">Using SPARQL to access Linked Open Data</ref>.</p>
</div>
      <div type="2"><head>Further reading and resources</head>
<list type="unordered">
<item>Dean Allemang and James Hendler, <emph>Semantic Web for the Working Ontologist</emph>, 2nd edn, Elsevier, 2011</item>
<item>Tim Berners-Lee <ref target="https://www.w3.org/DesignIssues/LinkedData.html">Linked Data</ref></item>
<item>Bob DuCharme, <emph>Learning SPARQL</emph>, O'Reilly, 2011</item>
<item><ref target="http://www.snee.com/bobdc.blog/">Bob DuCharme's blog</ref> is also worth reading</item>
<item>Richard Gartner, <emph>Metadata: Shaping Knowledge from Antiquity to the Semantic Web</emph>, Springer, 2016</item>
<item>Seth van Hooland and Ruben Verborgh, <emph>Linked Data for Libraries, Archives and Museums</emph>, 2015</item>
<item>Also see the book's <ref target="http://freeyourmetadata.org/">companion website</ref></item>
<item>Matthew Lincoln <ref target="/lessons/graph-databases-and-SPARQL">'Using SPARQL to access Linked Open Data'</ref></item>
<item><ref target="http://linkeddata.org/guides-and-tutorials">Linked Data guides and tutorials</ref></item>
<item>Dominic Oldman, Martin Doerr and Stefan Gradmann, 'Zen and the Art of Linked Data: New Strategies for a Semantic Web of Humanist * Knowledge', in <emph>A New Companion to Digital Humanities</emph>, edited by Susan Schreibman et al.</item>
<item>Max Schmachtenberg, Christian Bizer and Heiko Paulheim, <ref target="http://linkeddatacatalog.dws.informatik.uni-mannheim.de/state/">State of the LOD Cloud 2017</ref></item>
<item>David Wood, Marsha Zaidman and Luke Ruth, <emph>Linked Data: Structured data on the Web</emph>, Manning, 2014</item>
</list>
</div>
      <div type="2"><head>Acknowlegements</head>
<p>I'd like to thank my two peer reviewers, Matthew Lincoln and Terhi Nurmikko-Fuller, and my editor, Adam Crymble, for generously spending time helping me to improve this course with numerous suggestions, clarification and corrections. This tutorial is based on one written as part of the 'Thesaurus of British and Irish History as SKOS' <ref target="http://www.history.ac.uk/projects/digital/tobias">(Tobias) project</ref>, funded by the <ref target="http://www.ahrc.ac.uk/">AHRC</ref>. It has been revised for the <emph>Programming Historian</emph>.</p>
</div>
    </body>
  </text>
</TEI>
