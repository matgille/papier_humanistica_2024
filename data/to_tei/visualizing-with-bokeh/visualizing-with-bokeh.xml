<TEI xmlns="https://tei-c.org/ns/1-0/">
  <metadata>
  <title>Visualizing Data with Bokeh and Pandas</title>
  <authors>Charlie Harper</authors>
  <date>2018-07-27</date>
  <reviewers>Zoe LeBlanc,Ben Schmidt</reviewers>
  <editors>James Baker,Ian Milligan</editors>
  <difficulty>2</difficulty>
  <activity>analyzing</activity>
  <topics>python,data-manipulation,mapping,data-visualization</topics>
  <abstract>In this lesson you will learn how to visually explore and present data in Python by using the Bokeh and Pandas libraries.</abstract>
  <review-ticket>https://github.com/programminghistorian/ph-submissions/issues/152</review-ticket>
  <layout>lesson</layout>
  <avatar_alt>Men with torches in an antique tomb</avatar_alt>
  <doi>10.46430/phen0081</doi>
</metadata>
  <text>
    <body>
      <div n="1"><head>Contents</head>
</div>
      <div n="1"><head>Overview</head>
<p>The ability to load raw data, sample it, and then visually explore and present it is a valuable skill across disciplines. In this tutorial, you will learn how to do this in Python by using the Bokeh and Pandas libraries. Specifically, we will work through visualizing and exploring aspects of WWII bombing runs conducted by Allied powers.</p>
<p>At the end of the lesson you will be able to:</p>
<ul>
<li>Load tabular CSV data</li>
<li>Perform basic data manipulation, such as aggregating and sub-sampling raw data</li>
<li>Visualize quantitative, categorical, and geographic data for web display</li>
<li>Add varying types of interactivity to your visualizations</li>
</ul>
<p>To reach these goals, we'll work through a variety of visualization examples using THOR, a dataset that describes historical bombing operations.</p>
<div n="2"><head>The WWII THOR Dataset</head>
<p>The Theater History of Operations Reports (THOR) lists aerial bombing operations during World War I, World War II, the Korean War, and the Vietnam War undertaken by the United States and Allied Powers. The records were compiled from declassified documents by Lt. Col. Jenns Robertson. THOR is made publicly available through a partnership between the US Department of Defense and <link target="https://data.world/datamil">data.world</link>.</p>
<p>Each row in the THOR dataset contains information on a single mission or bombing run. This information can include the mission date, takeoff and target locations, the target type, aircraft involved, and the types and weights of bombs dropped on the target. The <link target="https://data.world/datamil/thor-data-dictionary">THOR data dictionary</link> provides detailed information on the structure of the dataset.</p>
<p>For this tutorial, we'll use a modified version of the WWII THOR dataset. The original, full-version of the dataset consists of 62 columns of information digitized from the paper forms. To make this dataset more manageable for our purposes, this has been reduced to 19 columns that include core mission information and bombing data. These columns are discussed below when we first load the data. The unabridged dataset is available for download <link target="https://data.world/datamil/world-war-ii-thor-data">here</link>.</p>
<p>The dataset used in this tutorial is contained in <link target="https://github.com/programminghistorian/ph-submissions/tree/gh-pages/assets/visualizing-with-bokeh/thor_wwii.csv">thor_wwii.csv</link>. This file is required to complete most of the examples below.</p>
<p>We'll use Bokeh and Pandas to address some of the following questions:</p>
<ul>
<li>What types and weights of munitions were dropped during World War II (WWII)? What patterns can we discern in the use of different types of munitions?</li>
<li>How did the types and weights of munitions dropped change over the course of WWII? How do these changes correspond to major military events?</li>
<li>What targets were munitions dropped on during the war? Were particular types of munitions limited to certain theaters of operations or targets?</li>
</ul>
</div><div n="2"><head>Other Possible Datasets</head>
<p>If this dataset doesn't fit your interests or if you'd like more practice after completing this tutorial, here are a few other interesting datasets that you might wish to use with Bokeh and Pandas:</p>
<ul>
<li>
<p><link target="https://data.world/history/scottish-witchcraft/">Scottish Witchcraft Trials</link>: A multi-table set of data on over 4,000 people accused of witchcraft between 1536 and 1736.</p>
</li>
<li>
<p><link target="https://data.world/history/civil-unrest-event-data">Civil Unrest Events</link>: A single table cataloging over 60,000 events of civil unrest across the world since the end of World War II.</p>
</li>
<li>
<p><link target="https://www.slavevoyages.org/voyage/database">Trans-Atlantic Slave Trade Database</link>: Searchable and customizable tabular data on 36,000 slaving voyages that transported over 10 million slaves from the 16th to 19th centuries.</p>
</li>
</ul>
<p>All three datasets contain comparable quantitative, qualitative, and temporal data to those found in the THOR dataset. The Civil Unrest Events and Trans-Atlantic Slave Trade datasets both contain spatial data, though this is lacking from the Scottish Witchcraft Trials data.</p>
</div></div>
      <div n="1"><head>Getting Started</head>
<div n="2"><head>Prerequisites</head>
<p>This tutorial can be completed using any operating systems. It requires Python 3 and a web browser. You may use any text editor to write your code.</p>
<p>This tutorial assumes that you have a basic knowledge of the Python language and its associated data structures, particularly lists.</p>
<p>If you work in Python 2, you will need to create a virtual environment for Python 3, and even if you work in Python 3, creating a virtual environment for this tutorial is good practice.</p>
</div><div n="2"><head>Creating a Python 3 Virtual Environment</head>
<p>A Python virutal environment is an isolated environment in which you can install libraries and execute code. Many different virtual evironments can be created to work with different versions of Python and Python libraries. Virtual environments are useful because they ensure you have only the necessary libraries installed and that you do not encounter version conflicts. An additional benefit of virtual environments is that you can pass them to others so that you know your code will execute on another machine.</p>
<p><link target="https://conda.io/miniconda.html">Miniconda</link> is one easy way to create virtual environments that is simple to install across operating systems. You should download Miniconda and follow the instructions for <link target="https://conda.io/projects/conda/en/stable/user-guide/install/windows.html">Windows</link>, <link target="https://conda.io/projects/conda/en/stable/user-guide/install/macos.html">Mac</link>, or <link target="https://conda.io/projects/conda/en/stable/user-guide/install/linux.html">Linux</link> as appropriate for your operating system.</p>
<p>Once you have downloaded and installed Miniconda for your operating system, you can check that it has installed correctly by opening a command line and typing:</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_0" type="block" corresp="code_visualizing-with-bokeh_0.txt"></code></pre>
<p>If you see version information similar to the following, then Miniconda has installed correctly.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_1" type="block" corresp="code_visualizing-with-bokeh_1.txt"></code></pre>
<p>We'll use Miniconda to create a Python 3 virtual environment named <emph>bokeh-env</emph> for this tutorial. In the command line type the following:</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_2" type="block" corresp="code_visualizing-with-bokeh_2.txt"></code></pre>
<p>Say 'yes' when you are prompted to install new packages.</p>
<p>To activate the <emph>bokeh-env</emph> virtual environment, the command differs slightly depending on your operating system.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_3" type="block" corresp="code_visualizing-with-bokeh_3.txt"></code></pre>
<p>Your command line should now show that you are in the <emph>bokeh-env</emph> virtual environment.</p>
<p>When you would like to leave the virtual environment, you can type the command appropriate for your operating system.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_4" type="block" corresp="code_visualizing-with-bokeh_4.txt"></code></pre>
</div><div n="2"><head>Installing Packages</head>
<p>In your activated <emph>bokeh-env</emph> virtual environment, issue the following command to install the python packages for this tutorial.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_5" type="block" corresp="code_visualizing-with-bokeh_5.txt"></code></pre>
<p>To get the exact versions used to write this tutorial (note: these may not be the most recent versions of each python package) you can pass the following version numbers to <code type="inline">pip</code>.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_6" type="block" corresp="code_visualizing-with-bokeh_6.txt"></code></pre>
</div><div n="2"><head>Running Code Examples</head>
<div class="alert alert-info">
<p>At this point in the lesson, you have a choice of two ways to experiment with "Running Code Examples". You can either proceed in the command line and do the coding by hand, or run the Jupyter notebook provided <link target="https://github.com/programminghistorian/ph-submissions/tree/gh-pages/assets/visualizing-with-bokeh/visualizing-with-bokeh.ipynb">here</link>. Beginners who simply want to get a sense of how the code  operates, rather than write it themselves, may find the Jupyter notebook option especially helpful.</p>
</div>
<p>It is easiest first to create a single directory and save each code example as a <emph>.py</emph> within it. When you are ready to run the code file, navigate to this directory in your command prompt and make sure your virtual environment is activated. Remember that you can always activate the environment with the following command appropriate for your operating system.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_7" type="block" corresp="code_visualizing-with-bokeh_7.txt"></code></pre>
<p>Within the virtual environment, you can run your code by typing:</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_8" type="block" corresp="code_visualizing-with-bokeh_8.txt"></code></pre>
<p>A Jupyter Notebook containing the code used in this tutorial is also <link target="https://github.com/programminghistorian/ph-submissions/tree/gh-pages/assets/visualizing-with-bokeh/visualizing-with-bokeh.ipynb">available</link> in case you prefer to work through the tutorial without installing a virtual environment. You can learn more about Jupyter Notebook <link target="http://jupyter.org">here</link>. If you have created a virtual environment using Miniconda, as discussed above, you can install Jupyter Notebook in the environment by typing <code type="inline">conda install jupyter</code></p>
</div></div>
      <div n="1"><head>The Basics of Bokeh</head>
<div n="2"><head>What is Bokeh?</head>
<p>Bokeh is a library for creating interactive data visualizations in a web browser. It offers a concise, human-readable syntax, which allows for rapidly presenting data in an aesthetically pleasing manner. If you've worked with visualization in Python before, it's likely that you have used <link target="https://matplotlib.org">matplotlib</link>. It's worth briefly mentioning how Bokeh differs from matplotlib, and when one might be preferred to the other.</p>
<p>Matplotlib has existed since 2002 and has long been a standard of Python data visualization. Bokeh emerged in 2013. This difference in age means that Matplotlib matured long before Bokeh was released; however, in a short period of time, Bokeh has reached a high level of maturity.</p>
<p>The intended uses of matplotlib and Bokeh are quite different. Matplotlib creates static graphics that are useful for quick and simple visualizations, or for creating publication quality images. Bokeh creates visualizations for display on the web (whether locally or embedded in a webpage) and most importantly, the visualizations are meant to be highly interactive. Matplotlib does not offer either of these features.</p>
<p>If would you like to visually interact with your data in an exploratory manner or you would like to distribute interactive visual data to a web audience, Bokeh is the library for you! If your main interest is producing finalized visualizations for publication, matplotlib may be better, although Bokeh does offer a way to create static graphics.</p>
<p>With this differences in mind, as we work through the lesson, I'll emphasize the interactive aspects that make Bokeh useful for exploring and disseminating historical data and that set it apart from other libraries like matplotlib.</p>
</div><div n="2"><head>Your First Plot</head>
<p>First, create a new file called <code type="inline">my_first_plot.py</code> in the same directory as  <code type="inline">wwii_thor.csv</code> and then open it up in a text editor. We'll be adding lines to this file to run.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_9" type="block" corresp="code_visualizing-with-bokeh_9.txt"></code></pre>
<p>To implement and use Bokeh, we first import some basics that we need from the <code type="inline">bokeh.plotting</code> module.</p>
<p><code type="inline">figure</code> is the core object that we will use to create plots. <code type="inline">figure</code> handles the styling of plots, including title, labels, axes, and grids, and it exposes methods for adding data to the plot. The <code type="inline">output_file</code> function defines how the visualization will be rendered (namely to an html file) and the <code type="inline">show</code> function will be invoked when the plot is ready for output. <code type="inline">show</code> tells Bokeh that all of the data has been added to the plot and it is time to render it.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_10" type="block" corresp="code_visualizing-with-bokeh_10.txt"></code></pre>
<p>Bokeh recommends that <code type="inline">output_file</code>, to which we pass a file name, be called at the start of your script, immediately after imports. An alternative output function to be aware of is <code type="inline">output_notebook</code> which is used to show plots in-line in a Jupyter Notebook. To learn more about installing and using Jupyter notebooks, see <link target="https://jupyter.readthedocs.io/en/latest/">Jupyter's documentation</link>.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_11" type="block" corresp="code_visualizing-with-bokeh_11.txt"></code></pre>
<p>Next we'll create some data to plot. Data in Bokeh can take on different forms, but at its simplest, data is just a list of values. We create one list for our x-axis and one for our y-axis.</p>
<p>With our output format and data fixed, we can instantiate a <code type="inline">figure</code> and  add the data to it.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_12" type="block" corresp="code_visualizing-with-bokeh_12.txt"></code></pre>
<p>{% include alert.html text="<code type="inline">p</code> is a common variable name for a <code type="inline">figure</code> object, since a figure is a type of plot." %}</p>
<p>After instantiating the figure, we call the <code type="inline">circle</code> , <code type="inline">line</code>, and <code type="inline">triangle</code> methods to plot our data. These types of methods are known as a <emph>glyph method</emph>. The term <emph>glyph</emph> in Bokeh refers to the lines, circles, bars, and other shapes that are added to plots to display data.</p>
<p>If we wanted, we could just keep adding glyphs to the plot! In addition to the <code type="inline">circle</code>, <code type="inline">line</code>,   and <code type="inline">triangle</code> glyphs, there are many others, including:  <code type="inline">asterisk</code>, <code type="inline">circle_cross</code>, <code type="inline">circle_x</code>, <code type="inline">cross</code>, <code type="inline">diamond</code>, <code type="inline">diamond_cross</code>, <code type="inline">inverted_triangle</code>, <code type="inline">square</code>, <code type="inline">square_cross</code>, <code type="inline">square_x</code>, and <code type="inline">x</code>.</p>
<p>When calling a glyph method, at a minimum, we must pass the data we would like to plot, but frequently we might add styling arguments. Here, we set a size, color, and legend name for each glyph.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_13" type="block" corresp="code_visualizing-with-bokeh_13.txt"></code></pre>
<p>We will also add our first piece of code that brings some interactivity to the plot. By setting a <code type="inline">click_policy</code> on our legend, a user can now click on each legend entry (e.g. circle, line, triangle) to show/hide that piece of data! The <code type="inline">click_policy</code> can also be set to <code type="inline">mute</code> instead of <code type="inline">hide</code>. This would mute the color of that data on clicking rather than hide it completely.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_14" type="block" corresp="code_visualizing-with-bokeh_14.txt"></code></pre>
<p>Calling <code type="inline">show</code> and passing the instantiated <code type="inline">figure</code> will output the results to our html file. Now let's run this code!</p>
<p>In your command line, make sure you're in the directory where you've saved the file and then run the file with the <code type="inline">python</code> command.</p>
<pre><code xml:id="code_visualizing-with-bokeh_15" type="block" corresp="code_visualizing-with-bokeh_15.txt"></code></pre>
<figure><desc>Plotting a Single Glyph</desc><graphic url="visualizing-with-bokeh-1.png"/></figure>
<p>A web browser will now appear showing the html file with your visualization. The red circles, blue line, and gold triangles are the result of our glyph method calls. Clicking the legend in the upper right corner will show/hide each glyph type. Note that Bokeh has automatically handled the creation of the grid-lines and tick labels.</p>
<p>Along the right-hand side, the default toolbar is also displayed. The tools include drag, box zoom, wheel zoom, save, reset, and help. Using these tools, a user can pan along the plot or zoom in on interesting portions of the data. Since this is a stand-alone HTML page, which includes a reference to BokehJS, it can be immediately passed to a co-worker for exploration or posted to the web.</p>
</div></div>
      <div n="1"><head>Bokeh and Pandas: Exploring the WWII THOR Dataset</head>
<p>In the previous example, we manually created two short Python lists for our x and y data. What happens when you have real-world data with tens-of-thousands of rows and dozens of columns stored in an external format? Pandas, a widely-used data science library, is ideally suited to this type of data and integrates seamlessly with Bokeh to create interactive visualizations of data.</p>
<div n="2"><head>Pandas Overview</head>
<p>For the purposes of this tutorial, I will only touch on the basic functions of Pandas that are necessary to produce our visualizations. <link target="https://pandas.pydata.org/pandas-docs/stable/10min.html">10 Minutes to Pandas</link> and <link target="https://pandas.pydata.org/pandas-docs/stable/tutorials.html#lessons-for-new-pandas-users">Lessons for New Pandas Users</link> are excellent introductions that I would recommend for expanding your knowledge beyond the very basics touched on here.</p>
<p>Pandas has quickly become the <emph>de facto</emph> Python library for data and data science workflows; integration with other major data science and machine learning libraries has only fueled a rise in popularity.<ref type="footnotemark" target="#1"/> Pandas provides functionality to quickly and efficiently read, write, and modify datasets for analysis. To accomplish this, Pandas provides data structures that hold different dimensionalities of data. The <code type="inline">DataFrame</code> holds 2-dimensional data in the manner of a spreadsheet with rows and columns. It's through this object that we'll interact with our WWII THOR dataset. Let's first examine the Pandas <code type="inline">DataFrame</code> by loading our csv data into one.</p>
</div><div n="2"><head>Loading Data in Pandas</head>
<p>To begin with, create a new file called <code type="inline">loading_data.py</code>.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_16" type="block" corresp="code_visualizing-with-bokeh_16.txt"></code></pre>
<p>We start by importing the Pandas library and then calling <code type="inline">read_csv()</code> and passing a filename to it. Note that the Pandas library is aliased as <emph>pd</emph>. This alias is a convention followed in the <link target="https://pandas.pydata.org/pandas-docs/stable/">Pandas official documentation</link> and is widely used by the Pandas community. For this reason, I'll use the <emph>pd</emph> alias throughout the tutorial.</p>
<p>In this code, <code type="inline">read_csv</code> creates a <code type="inline">DataFrame</code> that holds the rows/columns of our csv data. By convention, the variable name <emph>df</emph> is used to represent the loaded dataframe in tutorials and basic code examples. <link target="https://pandas.pydata.org/pandas-docs/stable/api.html#input-output">Many other methods</link> exist for reading data formats other than csv in Pandas, such as JSON, SQL tables, Excel files, and HTML.</p>
<p>When running this code, <code type="inline">print(df)</code> will output an abridged representation of the loaded data.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_17" type="block" corresp="code_visualizing-with-bokeh_17.txt"></code></pre>
<p>This shows that we have 178,281 records of missions with 19 columns per record. To see what the 19 columns are in full, we can access the dataframe's  <code type="inline">columns</code> object by replacing <code type="inline">print(df)</code> in the above code with:</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_18" type="block" corresp="code_visualizing-with-bokeh_18.txt"></code></pre>
<p>The output should look like:</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_19" type="block" corresp="code_visualizing-with-bokeh_19.txt"></code></pre>
<p>Some of these column names are self explanatory, but it's worth pointing out the following: MSNDATE (mission date), NAF (numbered airforce responsible for mission), AC_ATTACKING (number of aircraft), TONS_HE (high-explosives), TONS_IC (incendiary devices), TONS_FRAG (fragmentation bombs).</p>
<p>When it comes to accessing data within a <code type="inline">DataFrame</code>, in this tutorial we use one basic approach: indexing. Here to access a single column we pass a string to our dataframe's indexer: e.g. <code type="inline">df['MSNDATE']</code>.  To access multiple columns, we pass a list of names to our dataframe's indexer: e.g. <code type="inline">df[['MSNDATE', 'THEATER']]</code>.</p>
</div><div n="2"><head>The Bokeh ColumnDataSource</head>
<p>Now that we've learned how to create a Bokeh plot and how to load tabular data into Pandas, it's time to learn how to link Pandas' <code type="inline">DataFrame</code> with Bokeh visualizations. The Bokeh object <code type="inline">ColumnDataSource</code> provides this integration.</p>
<p>The object's constructor accepts a Pandas <code type="inline">DataFrame</code> as an argument. After it is created, the <code type="inline">ColumnDataSource</code> can then be passed to glyph methods via the <code type="inline">source</code> parameter and other parameters, such as our x and y data, can then reference column names within our source. Let's go through an example of this.</p>
<p>Using our THOR dataset, we'll create a scatter plot of the number of attacking aircraft versus the tons of munitions dropped. We will use a new file called <code type="inline">column_datasource.py</code> to do this. We'll also take this opportunity to learn about Bokeh's interactive hover feature.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_20" type="block" corresp="code_visualizing-with-bokeh_20.txt"></code></pre>
<p>Here, we import Pandas, the <code type="inline">figure</code> object and basic functions from <code type="inline">bokeh.plotting</code>, and the <code type="inline">ColumnDataSource</code> object from <code type="inline">bokeh.models</code>.  We're also going to expand our knowledge of interactions in this example by adding a hover feature that is facilitated by the <code type="inline">HoverTool</code></p>
<p>We then immediately set our output file following Bokeh's recommended best practices. Finally, we call Pandas <code type="inline">read_csv</code> method to load our csv into a <code type="inline">DataFrame</code>.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_21" type="block" corresp="code_visualizing-with-bokeh_21.txt"></code></pre>
<p>Since we don't want to plot all 170,000+ rows in our scatterplot (which would require a longer processing time to generate and would create a confusing plot due to the volume of overlapping data), we randomly sample 50 rows using the dataframe's <code type="inline">sample</code> method.  We then pass this sample to the <code type="inline">ColumnDataSource</code> constructor and store this in a variable called <code type="inline">source</code>.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_22" type="block" corresp="code_visualizing-with-bokeh_22.txt"></code></pre>
<p>Next, we create our <code type="inline">figure</code> object and call the <code type="inline">circle</code> glyph method to plot our data. This is where the <code type="inline">source</code> variable that holds our <code type="inline">ColumnDataSource</code> comes into play. It's passed as our <code type="inline">source</code> argument to the glyph method and the column names holding the number of attacking aircraft (AC_ATTACKING) and tons of munitions dropped (TOTAL_TONS) are passed as our <code type="inline">x</code> and <code type="inline">y</code> arguments.</p>
<p>Interestingly, when we use a <code type="inline">ColumnDataSource</code> we're not limited to just using column names for <code type="inline">x</code> and <code type="inline">y</code> parameters. We can also pass a column name for other parameters such as <code type="inline">size</code>, <code type="inline">line_color</code>, or <code type="inline">fill_color</code>. This allows styling options to be determined by columns in the datasource itself! If you'd like to see this in action, in the code above, change <code type="inline">size=10</code> to <code type="inline">size='TONS_HE'</code>. The size of each dot will then reflect the tons of high explosives used.</p>
<p>{% include alert.html text="Throughout the tutorial, I often pass arguments by name where they could more succinctly be passed by position. This is helpful, in my opinion, for the reader to keep track of what arguments are being passed" %}</p>
<p>Next we add a title and label our axes.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_23" type="block" corresp="code_visualizing-with-bokeh_23.txt"></code></pre>
<p>We can also, at this stage, learn a bit more about the strong interactive, customizable nature of Bokeh plots. In our first Bokeh plot we saw the default Bokeh toolbar, but Bokeh allows us to customize our plot by adding new interactive tools to it.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_24" type="block" corresp="code_visualizing-with-bokeh_24.txt"></code></pre>
<p>Bokeh supports <link target="https://docs.bokeh.org/en/latest/docs/reference/plotting.html">many plotting tools</link>, but I introduce <code type="inline">HoverTool</code> here because it's particularly useful for data exploration and interaction. <code type="inline">HoverTool</code> allows you to set a <code type="inline">tooltips</code> property which takes a list of <link target="https://www.w3schools.com/python/python_tuples.asp">tuples</link>. The first part of the tuple is a display name and the second is a column name from your <code type="inline">ColumnDataSource</code> prefaced with <code type="inline">@</code>. Once we've instantiated this tool, we add it to the plot using the <code type="inline">add_tool</code> method. We'll see how this looks in a moment.</p>
<p>Finally, we make sure to add the line to show the plot. Now we can run <code type="inline">column_datasource.py</code> and interact with our data in the browser.</p>
<figure><desc>Plotting with the ColumnDataSource and More Styling Options</desc><graphic url="visualizing-with-bokeh-2.png"/></figure>
<p>Note that because we are randomly sampling the data, our plot will look different each time we run the code.</p>
<p>At the top and along the axes of the plot, we see the labels that we added. There is also a new tool in the toolbar. This is the hover tool that we added. To see it in action, hover over any data point in the scatterplot. A window will pop up showing the columns we set in our <code type="inline">tooltip</code> property!</p>
<p>Before moving to the next section of the lesson, try returning to the example above and adding/removing other variables and changing display names.</p>
</div></div>
      <div n="1"><head>Categorical Data and Bar Charts: Munitions Dropped by Country</head>
<p>In the preceding example, we plotted quantitative data. Frequently, though, we want to plot categorical data. Categorical data, in contrast to quantitative, is data that can be divided into groups, but that does not necessarily have a numerical aspect to it. For example, while your height is numerical, your hair color is categorical. From the perspective of our dataset, features like attacking country hold categorical data, while features like the weight of munitions hold quantitative data.</p>
<p>In this section, we'll learn how to use categorical data as our x-axis values in Bokeh and how to use the <code type="inline">vbar</code> glyph method to create a vertical bar chart (an <code type="inline">hbar</code> glyph method functions similarly to create a horizontal bar chart). In addition, we'll learn about preparing categorical data in Pandas by grouping data. Further, we'll add to our knowledge of Bokeh styling and the hover tool.</p>
<p>To work through this information, we'll create a bar chart that shows the total tons of munitions dropped by each country listed in our csv.</p>
<p>We start by creating a new file called <code type="inline">munitions_by_country.py</code> and adding some initial code.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_25" type="block" corresp="code_visualizing-with-bokeh_25.txt"></code></pre>
<p>First, we import the Pandas library and the basic elements from Bokeh (i.e. <code type="inline">figure</code>, <code type="inline">output_file</code>, <code type="inline">show</code>, and <code type="inline">ColumnDataSource</code>). We also make two new imports: <code type="inline">Spectral5</code> is a pre-made five color pallette, one of Bokeh's many <link target="https://docs.bokeh.org/en/latest/docs/reference/palettes.html#bokeh-palettes">pre-made color palettes</link>, and <code type="inline">factor_cmap</code> is a helper method for mapping colors to bars in a bar-charts.</p>
<p>After the imports, we set our <code type="inline">output_file</code>  and load the thor_wwii.csv file into a <code type="inline">DataFrame</code>.</p>
<p>We now need to get from the 170,000+ records of individual missions to one record per attacking country with the total munitions dropped.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_26" type="block" corresp="code_visualizing-with-bokeh_26.txt"></code></pre>
<p>Pandas lets us do this in a single line of code by using the <code type="inline">groupby</code> dataframe method. This method accepts a column by which to group the data and one or more aggregating methods that tell Pandas how to group the data together. The output is a new dataframe.</p>
<p>Let's take this one piece at a time. The <code type="inline">groupby('COUNTRY_FLYING_MISSION')</code> sets the column that we are grouping on. In other words, this says that we want the resulting dataframe to have one row per unique entry in the column <code type="inline">COUNTRY_FLYING_MISSION</code>. Since we don't care about aggregating all 19 columns in the dataframe, we choose just the tons of munitions columns with the indexer, <code type="inline">['TOTAL_TONS', 'TONS_HE', 'TONS_IC', 'TONS_FRAG']</code>. Finally, we use the <code type="inline">sum</code> method to let Pandas know how to aggregate all of the different rows. Other methods also exist for aggregating, such as <code type="inline">count</code>, <code type="inline">mean</code>, <code type="inline">max</code>, and <code type="inline">min</code>.</p>
<p>If you execute <code type="inline">print(grouped)</code>, you'll see that Pandas has grouped by the five unique countries in our dataset and summed the total tons dropped by each. You can also see the dataset has some problems: South Africa and New Zealand dropped more high explosives than the total tons column. Problems like this are typical of large, manually-created datasets and this is a great reminder why is so important to explore and visualize your data before creating research results.</p>
<pre><code xml:id="code_visualizing-with-bokeh_27" type="block" corresp="code_visualizing-with-bokeh_27.txt"></code></pre>
<p>To plot this data, let's convert to kilotons by dividing by 1000.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_28" type="block" corresp="code_visualizing-with-bokeh_28.txt"></code></pre>
<p>This is a convenience that we'll continue to use in future examples.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_29" type="block" corresp="code_visualizing-with-bokeh_29.txt"></code></pre>
<p>Now, we need to make a <code type="inline">ColumnDataSource</code> from our grouped data and create a <code type="inline">figure</code>. Since our x-axis will list the five countries (rather than numerical data) we need to tell the figure how to handle the x-axis.</p>
<p>To do this, we create a list of countries from our source object, using <code type="inline">source.data</code> and the column name as key. The list of countries is then passed as the <code type="inline">x_range</code> to our <code type="inline">figure</code> constructor. Because this is a list of text data, the figure knows the x-axis is categorical and it also knows what possible values our x range can take (i.e. AUSTRALIA, GREAT BRITAIN, etc.).</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_30" type="block" corresp="code_visualizing-with-bokeh_30.txt"></code></pre>
<p>Now we plot our data as individually colored bars and add basic labels. To color our bars we use the <code type="inline">factor_cmap</code> helper function. This creates a special color map that matches an individual color to each category (i.e. what Bokeh calls a <emph>factor</emph>). The color map is then passed as the color argument to our <code type="inline">vbar</code> glyph method.</p>
<p>For the data in our glyph method, we're passing a source and again referencing column names. Instead of using a <code type="inline">y</code> parameter, however, the <code type="inline">vbar</code> method takes a <code type="inline">top</code> parameter. A <code type="inline">bottom</code> parameter can equally be specified, but if left out, its default value is 0.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_31" type="block" corresp="code_visualizing-with-bokeh_31.txt"></code></pre>
<p>We add a hover tool again, but now we see that we can use multiple data variables in a single line and add in our own text so the hover popup will list the kilotons of each type of explosive. The <code type="inline">hover.mode</code> is new. Three modes exist for the hover tool: <code type="inline">mouse</code>, <code type="inline">vline</code>, and <code type="inline">hline</code>. These tell the hover tool when to show the popup. <code type="inline">mouse</code> is the default value and shows a popup when directly over a glyph. <code type="inline">vline</code> and <code type="inline">hline</code> tell the popup to show when a vertical or horizontal line crosses a glyph. With <code type="inline">vline</code> set here, anytime your mouse passes through an imaginary vertical line extending from each bar, a popup will show.</p>
<figure><desc>A Bar Chart with Categorical Data and Coloring</desc><graphic url="visualizing-with-bokeh-3.png"/></figure>
<p>{% include alert.html text="If you have a chance, it's worth exploring Bokeh's <link target="https://docs.bokeh.org/en/latest/docs/reference/palettes.html#bokeh-palettes">color palettes</link>. In the above example, try rewriting the code to use something other than <code type="inline">Spectral5</code>, such as <code type="inline">Inferno5</code> or <code type="inline">RdGy5</code>. To take it one step further, you can try your hand at using built-in palettes in any example that uses color." %}</p>
</div>
      <div n="1"><head>Stacked Bar Charts and Sub-sampling Data: Types of Munitions Dropped by Country</head>
<p>Because the previous plot shows that the USA and Great Britain account for the overwhelming majority of bombings, we now focus on these two countries and learn how to make a stacked bar chart that shows the types of munitions each country used.</p>
<p>We'll start a new file called <code type="inline">munitions_by_country_stacked.py</code></p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_32" type="block" corresp="code_visualizing-with-bokeh_32.txt"></code></pre>
<p>In addition to our standard imports, this time we use a three-color Spectral palette, one color for each type of explosive (High Explosive, Incendiary, and Fragmentation).</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_33" type="block" corresp="code_visualizing-with-bokeh_33.txt"></code></pre>
<p>Since the x-axis is again categorical, we'll need to group and aggregate our data. This time, though, we need to exclude any records hat don't have a COUNTRY_FLYING_MISSION with a value of GREAT BRITAIN or USA. To do that, we filter our dataframe.</p>
<p>For each row in <code type="inline">df</code>, the <code type="inline">isin</code> function checks whether COUNTRY_FLYING_MISSION has a value of USA or GREAT BRITAIN. If it does, the corresponding value in the variable <code type="inline">filter</code> is <code type="inline">True</code> and if not the value is <code type="inline">False</code></p>
<p>When applied to our dataframe via <code type="inline">df[filter]</code>, a new dataframe is created in which rows with a <code type="inline">True</code>  value are kept and rows with a <code type="inline">False</code> value are discarded. After the filter has been applied here, executing <code type="inline">df.shape</code> shows that 125,526 rows remain of an original 178,281.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_34" type="block" corresp="code_visualizing-with-bokeh_34.txt"></code></pre>
<p>Now that we have reduced the dataframe to show only records for the USA and Great Britain, we group our data with <code type="inline">groupby</code> and aggregate the three columns that hold bomb types with <code type="inline">sum</code>.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_35" type="block" corresp="code_visualizing-with-bokeh_35.txt"></code></pre>
<p>As in the previous example, we create a source object from our grouped data and make sure our figure uses categorical data for the x-axis by setting the <code type="inline">x_range</code> to the list of countries.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_36" type="block" corresp="code_visualizing-with-bokeh_36.txt"></code></pre>
<p>To create the stacked bar chart, we call the <code type="inline">vbar_stack</code> glyph method. Rather than passing a single column name to a <code type="inline">y</code> parameter, we instead pass a list of column names as <code type="inline">stackers</code>. The order of this list determines the order that the columns will be stacked from bottom to top (after you've worked through this example, try switching the column order to see what happens). The <code type="inline">legend</code> argument supplies text for each stacker and the <code type="inline">Spectral3</code> palette provides colors for each stacker.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_37" type="block" corresp="code_visualizing-with-bokeh_37.txt"></code></pre>
<p>We add basic styling and labeling, and then output the plot.</p>
<figure><desc>A Stacked Bar Chart with Categorical Data and Coloring</desc><graphic url="visualizing-with-bokeh-4.png"/></figure>
</div>
      <div n="1"><head>Time-Series and Annotations: Bombing Operations over Time</head>
<p>Let's now explore the use of incendiary and fragmentation explosive a little more by seeing if there's any trend in their use over time versus the total munitions dropped. As you have had some time to get used to Bokeh's syntax, let's dive right in with a full code example in a new file named <code type="inline">my_first_timeseries.py</code>.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_38" type="block" corresp="code_visualizing-with-bokeh_38.txt"></code></pre>
<p>Take a minute to seriously look through this code and see what you recognize. Two items should stand out as new.</p>
<p>First, the statement <code type="inline">df['MSNDATE'] = pd.to_datetime(df['MSNDATE'], format='%m/%d/%Y')</code> makes sure our MSNDATE column is a datetime. This is important because often data loaded from a csv file will not be properly typed as datetime. Supplying the <code type="inline">format</code> argument is not required, but doing so significantly speeds up the process.</p>
<p>Second, we pass the argument <code type="inline">x_axis_type='datetime'</code> to our figure constructor to tell it that our x data will be datetimes. Otherwise, Bokeh works seamlessly with time data just like any other type of numerical data!</p>
<p>Looking at the output, though, you might notice a major issue.</p>
<figure><desc>A Basic Time-Series Plot</desc><graphic url="visualizing-with-bokeh-5.png"/></figure>
<p>This data is volatile and hard-to-read because it is too fine-grained for our needs. Having daily data over the course of five years is great, but plotting it as such obscures trends in the data. To successfully plot time-series data and look for long-term trends, we need a way to change the time-scale we're looking at so that, for example, we can plot data summarized by weeks, months, or years.</p>
<p>Thankfully, Pandas offers a quick and easy way to do this. By modifying a single line of code in the above example, we can <emph>resample</emph> our time-series data to any valid unit of time.</p>
<div n="2"><head>Resampling Time-Series Data</head>
<p>Resampling time-series data can involve either upsampling (creating more records) or downsampling (creating fewer records). For example, a list of daily temperatures could be upsampled to a list of hourly temperatures or downsampled to a list of weekly temperatures. We'll only be downsampling in this tutorial, but upsampling is very useful when you're trying to match a sporadically-measured dataset with one that's more periodically measured.</p>
<p>To resample our data, we use a Pandas <code type="inline">Grouper</code> object, to which we pass the column name holding our datetimes and a code representing the desired resampling frequency. In the case of our data, the statement <code type="inline">pd.Grouper(key='MSNDATE', freq='M') </code> will be used to resample our MSNDATE column by <emph>M</emph>onth. We could equally resample by <emph>W</emph>eek, <emph>Y</emph>ear, <emph>H</emph>our, and <link target="http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases">so forth</link>. These frequency designations can also be prefaced with numbers so that, for example, <code type="inline">freq='2W'</code> resamples at two week intervals!</p>
<p>To complete the process of resampling and plotting our data, we pass the above <code type="inline">Grouper</code> object to our <code type="inline">groupby</code> function in place of the raw column name. The <code type="inline">groupby</code> statement from the previous code example should now look like this:</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_39" type="block" corresp="code_visualizing-with-bokeh_39.txt"></code></pre>
<p>Rerunning the above code sample will produce a much cleaner plot with obvious trends. The plot now shows four points of interest:</p>
<ul>
<li>First, in both the Spring of 1944 and 1945, the scale of Allied bombing operations reached greater intensity.</li>
<li>Second, there is a smaller spike in the summer of 1945 during the acceleration of bombings against the Japanese after Germany's surrender.</li>
<li>Third, four spikes in the use of incendiary weapons appear that could further explored.</li>
<li>Fourth and finally, there are a few small spikes in the use of fragmentation bombs, the use of which then effectively stops after the surrender of Germany.</li>
</ul>
<figure><desc>A Time-Series Plot with Data Resampled to Months</desc><graphic url="visualizing-with-bokeh-6.png"/></figure>
</div><div n="2"><head>Annotating Trends in Plots</head>
<p>Let's look more closely now at the bombings in Europe in 1944 and 1945 to see what trends there are with fragmentation and incendiary munitions. We will also point out some of these trends in our plot with annotations. To do this, we'll filter our dataset so that we work only with bombings in the European Theater of Operations (ETO), resample the data at one-month intervals (<code type="inline">freq='M'</code>), and then plot the results in the same manner as before.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_40" type="block" corresp="code_visualizing-with-bokeh_40.txt"></code></pre>
<figure><desc>A Time-Series Plot of the ETO with Data Resampled to Months</desc><graphic url="visualizing-with-bokeh-7.png"/></figure>
<p>A few patterns emerge in the ETO data. First we see a very clear escalation of overall bombings leading up to June 6, 1944 and a notable dip during the winter of 1944/1945. Incendiary munitions show three spikes and confirm that the fourth spike seen in the preceding example was directed at the bombing of Japan after Germany's surrender. The pattern of fragmentation bombs is harder to read, but it's now clear that they were only seriously used in the European Theater after D-Day.</p>
<p>{% include alert.html text="Try your hand at resampling this data using any of <link target="http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases">Pandas' time frequencies </link> to see what other trends might emerge. Remember, you can preface these frequencies with numbers as well (e.g. if you were working with historical stock market data, 2Q would give you bi-quarterly data!)" %}</p>
<p>Since we have established that 6 June 1944 and the winter of 1944/1945 mark changes to the bombing patterns in the ETO, let's highlight these trends using Bokeh's annotation features.</p>
<p>To do this, we'll create a <code type="inline">BoxAnnotation</code> and then add these to our <code type="inline">figure</code> before showing it. First, we need to add an additional import statement to our code.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_41" type="block" corresp="code_visualizing-with-bokeh_41.txt"></code></pre>
<p>To create the box, we first need to determine its coordinates. Coordinates for Bokeh annotations can be either absolute (i.e. positioned using screen units), meaning they always stay in one place, or they can be positioned in relation to data. Our annotations will all be positioned using data coordinates.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_42" type="block" corresp="code_visualizing-with-bokeh_42.txt"></code></pre>
<p>The left of the box will be 6 June 1944 (D-Day) and for the right of the box we'll choose the first day of the Battle of the Bulge: 16 December 1944. In this case, the dates follow a month-day-year format, but <code type="inline">to_datetime</code> also works with <link target="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.to_datetime.html">day-first and year-first formats</link>.</p>
<p>We pass these coordinates to the <code type="inline">BoxAnnotation</code> constructor along with some styling arguments. Then, we add it to the our figure using the <code type="inline">add_layout()</code> method.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_43" type="block" corresp="code_visualizing-with-bokeh_43.txt"></code></pre>
<figure><desc>A Time-Series Plot of the ETO with Annotations Added</desc><graphic url="visualizing-with-bokeh-8.png"/></figure>
<p>{% include alert.html text="Try to create a similar plot for the Pacific Theater of Operations (PTO). Annotate the invasion of Iwo Jima (February 19, 1945) and Japan's announcement of surrender (August 15, 1945)." %}</p>
</div></div>
      <div n="1"><head>Spatial Data: Mapping Target Locations</head>
<p>In this final part of the lesson we'll look at the spatial components of fragmentation bombs.</p>
<p>Bokeh provides <link target="https://docs.bokeh.org/en/latest/docs/reference/tile_providers.html">built-in tile providers</link> that render base maps of the world. These are contained in the <code type="inline">bokeh.tile_providers</code> module. For this example, we'll use the CartoDB Tile Service (CARTODBPOSITRON).</p>
<p>We'll also be using functions imported from the <code type="inline">pyproj</code> library. Since our coordinates are stored as latitude/longitude, we'll define a custom function to convert them before mapping. Note that although Bokeh is coordinate-system neutral, it uses the Web Mercator projection for mapping, a standard found across web tile providers. The subject of coordinate systems and projections are outside the scope of this tutorial, but the interested reader will find many useful web resources on these topics.</p>
<p>{% include alert.html text="If your own dataset has place names, but not latitude and longitude, don't worry! You can find ways to easily get coordinates from place names in Programming Historian's <link target="/lessons/geocoding-qgis">Geocoding Historical Data using QGIS</link> or <link target="/lessons/mapping-with-python-leaflet#geocoding-with-python">Web Mapping with Python and Leaflet</link>." %}</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_44" type="block" corresp="code_visualizing-with-bokeh_44.txt"></code></pre>
<p>The boilerplate imports and our conversion function are defined. Next, we load our data and apply our conversion function to create new E and N columns that store our Web Mercator easting and northing.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_45" type="block" corresp="code_visualizing-with-bokeh_45.txt"></code></pre>
<p>Because a single target can appear in multiple records, we need to group the data by E and N to get unique target locations. Otherwise, we would map the same target every time it appears in a record.</p>
<p>The <code type="inline">reset_index</code> function applied after aggregating is new here. By default, when Pandas groups these two columns it will make E and N the index for each row in the new dataframe. Since we just want E and N to remain as normal columns for mapping, we call <code type="inline">reset_index</code>.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_46" type="block" corresp="code_visualizing-with-bokeh_46.txt"></code></pre>
<p>To set bounds for our map, we'll set a minimum and maximum value for our plot's <code type="inline">x_range</code> and <code type="inline">y_range</code>. We use the <code type="inline">Range1D</code> object, which represents bounded 1-dimensional data in Bokeh.</p>
<pre><code class="language-python" xml:id="code_visualizing-with-bokeh_47" type="block" corresp="code_visualizing-with-bokeh_47.txt"></code></pre>
<p>Finally, we call <code type="inline">add_tile</code> and pass the tile provider we imported. Then, we use glyph methods just like in any other plot. Here, we call <code type="inline">circle</code> and pass the easting and northing columns as our x and y data.</p>
<figure><desc>A Map of Target Locations</desc><graphic url="visualizing-with-bokeh-9.png"/></figure>
<p>Having plotted which targets in Europe and Asia were bombed with fragmentation bombs, we can now start to examine patterns of destruction with greater detail. In the above code, we also summed incendiary bombs. Try to alter the code to create a map of these targets.</p>
</div>
      <div n="1"><head>Bokeh as a Visualization Tool</head>
<p>Bokeh's strength as a visualization tool lies in its ability to show differing types of data in an interactive and web-friendly manner. This tutorial has only scratched the surface of Bokeh's capabilities and the reader is encourage to delve deeper into the library's workings. A great place to start is the <link target="https://docs.bokeh.org/en/latest/docs/gallery.html">Bokeh gallery</link>, where you can see a variety of visualizations and decide how you might apply these techniques to your own data. If you're more inclined to dive right into further code examples, Bokeh's <link target="https://mybinder.org/v2/gh/bokeh/bokeh-notebooks/master?filepath=tutorial%2F00%20-%20Introduction%20and%20Setup.ipynb">online notebook</link> is an excellent place to start!</p>
</div>
      <div n="1"><head>Further Resources</head>
<ul>
<li><link target="https://docs.bokeh.org/en/latest/docs/user_guide.html">Bokeh User Guide</link></li>
<li><link target="https://docs.bokeh.org/en/latest/docs/gallery.html">Bokeh Gallery</link></li>
<li><link target="https://pandas.pydata.org/pandas-docs/stable/index.html">Pandas Documentation</link></li>
<li><link target="https://www.kdnuggets.com/2017/01/pandas-cheat-sheet.html">Pandas Cheat Sheet</link></li>
<li><link target="https://www.kdnuggets.com/2017/03/bokeh-cheat-sheet.html">Bokeh Cheat Sheet</link></li>
</ul>
<p><note id="1"> David Robinson, 'Why is Python Growing so Quickly?', <emph>Stack Overflow Blog</emph>, 14 September 2017 <link target="https://stackoverflow.blog/2017/09/14/python-growing-quickly/">https://stackoverflow.blog/2017/09/14/python-growing-quickly/</link></note></p>
</div>
    </body>
  </text>
</TEI>
