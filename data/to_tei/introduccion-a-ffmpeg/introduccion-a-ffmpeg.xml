<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:id="introduccion-a-ffmpeg" type="translation">
    <teiHeader>
        <fileDesc>
            <titleStmt>
                <title>Introducción a la transcodificación, edición y visualización de datos audiovisuales con FFmpeg</title>
                <author role="original_author">Dave Rodriguez</author>
                <editor role="reviewers">
                    <persName>Tesla Cariani</persName>
                    <persName>Josh Romphf</persName>
                </editor>
                <author role="translators">
                    <persName>Dave Rodriguez</persName>
                    <persName>Sebastian Fiori</persName>
                </author>
                <editor role="translation-reviewers">
                    <persName>Jennifer Isasi</persName>
                    <persName>José Antonio Motilla</persName>
                </editor>
                <editor role="editors">Brandon Walsh</editor>
            </titleStmt>
            <publicationStmt>
                <distributor>Programming Historian</distributor>
                <date type="translated">12/11/2020</date>
                <idno type="doi">10.46430/phes0049</idno>
                <date type="published">12/20/2018</date>
            </publicationStmt>
            <sourceDesc>
                <p>Born digital, in a markdown format. Original file: <ref type="original_file" target="#introduction-to-ffmpeg"/>.</p>
            </sourceDesc>
        </fileDesc>
        <profileDesc>
            <abstract>
                <p>Esta lección introduce las funciones básicas de FFmpeg, una herramienta libre de línea de comandos utilizada para manipular y analizar materiales audiovisuales.</p>
            </abstract>
            <textClass>
                <keywords>
                    <term xml:lang="en">data-manipulation</term>
                    <term xml:lang="en">data-visualization</term>
                </keywords>
            </textClass>
        </profileDesc>
    </teiHeader>
    <text xml:lang="es">
        <body>
            <div type="2">
                <head>Introducción</head>
                <p>Historicamente, las Humanidades Digitales se han enfocado casi exclusivamente en el analisis de fuentes textuales a través de métodos computacionales (Hockey, 2004). Sin embargo, hay un interés creciente en el campo de la utilización de métodos computacionales para el análisis de materiales audiovisuales de patrimonio cultural, como refleja la creación de la <ref target="https://avindhsig.wordpress.com/">Alianza de Organizaciones de Humanidades Digitales Grupo de Interés Especial: Materiales audiovisuales en Humanidades Digitales</ref> y <ref target="https://figshare.com/articles/AV_in_DH_State_of_the_Field/5680114">el aumento de las presentaciones relacionadas con temas audiovisuales en la conferencia global de AOHD</ref> en los años anteriores. Investigaciones recientes, tal como <ref target="https://distantviewing.org">Distant Viewing TV</ref>, indican un cambio en el campo hacia proyectos relacionados con el uso de técnicas computacionales para ampliar el alcance de los materiales que los y las humanistas digitales pueden explorar. Como afirma Erik Champion, "la audiencia de Humanidades Digitales no siempre está enfocada en la literatura o está interesada en las formas tradicionales de alfabetización" y la aplicación de metodologías digitales para estudiar cultura audiovisual es una faceta emergente y emocionante de las humanidades digitales (Champion, 2017, traducido por el autor). Hay muchas herramientas valiosas, gratuitas y de código abierto disponibles para aquellos interesados en trabajar con materiales audiovisuales (por ejemplo, el tutorial de <emph>Programming Historian</emph>
                    <ref target="/es/lecciones/editar-audio-con-audacity">Editar Audio con Audacity</ref>). Este tutorial presentará otra: FFmpeg.</p>
                <p>
                    <ref target="https://www.ffmpeg.org/about.html">FFmpeg</ref> es el <emph>framework</emph> multimedia de código abierto líder para transcodificar, editar, filtrar y reproducir casi cualquier tipo de formato audiovisual digital (sitio web de FFmpeg - "About"). Muchos programas comunes y sitios web usan FFmpeg para leer y escribir archivos audiovisuales, por ejemplo, VLC, Google Chrome, YouTube y <ref target="https://trac.ffmpeg.org/wiki/Projects">muchos más</ref>. Además de ser una herramienta de programa y de desarrollo web, FFmpeg se puede usar en la interfaz de la línea de comandos para realizar muchas tareas comunes, complejas e importantes, relacionadas con la gestión, modificación y análisis de archivos audiovisuales. Estos tipos de procesos, tales como editar, transcodificar o extraer los metadatos de archivos, generalmente requieren acceso a otro programa (tal como editores de vídeo no lineal, como Adobe Premiere o Final Cut Pro); sin embargo, FFmpeg permite a un usuario operar directamente en archivos audiovisuales sin el uso de interfaces o programa de terceros. Como tal, el conocimiento del <emph>framework</emph> permite a los usuarios manipular materiales audiovisuales para satisfacer sus necesidades con una solución de código abierto y gratuita, que ofrece gran parte de la funcionalidad de un costoso programa de audio y vídeo. Este tutorial ofrece una introducción a la lectura y escritura de comandos de FFmpeg y una guía paso a paso a partir de un caso práctico para aprender a utilizar el <emph>framework</emph> en un trabajo específico para los humanistas digitales. Específicamente, se mostrará cómo FFmpeg puede ser utilizado para extraer y analizar datos de color en un video archivístico.</p>
                <div type="3">
                    <head>Objetivos de aprendizaje</head>
                    <list type="unordered">
                        <item>Instalar FFmpeg en tu computadora o usar una versión "demo" en el navegador web</item>
                        <item>Comprender la estructura básica y la sintaxis de los comandos de FFmpeg</item>
                        <item>
Aprender varios comandos útiles, tales como:<list type="unordered">
                                <item>"Re-wrap" (cambiar el contenedor) y transcodificar (recodificar archivos)</item>
                                <item>"Demux" de archivos (separar audio y vídeo)</item>
                                <item>Recortar/Editar archivos</item>
                                <item>Usar FFplay para reproducir archivos</item>
                                <item>Crear vectorscopios para visualizar los datos de color</item>
                                <item>Usar FFprobe para generar informes de los datos de color</item>
                            </list>
                        </item>
                        <item>Introducir recursos para mayor exploración y experimentación</item>
                    </list>
                </div>
                <div type="3">
                    <head>Requisitos previos</head>
                    <p>Antes de comenzar con este tutorial, es necesario que localices la <ref target="https://es.wikipedia.org/wiki/Terminal_(macOS)">Terminal</ref> de tu computadora u otra interfaz de línea de comandos, ya que ahí es donde ingresarás y ejecutarás los comandos de FFmpeg. Si necesitas instrucción para acceder y usar la interfaz de línea de comandos, te recomendamos la lección de <emph>Programming Historian</emph>
                        <ref target="/es/lecciones/introduccion-a-bash">Introducción a la línea de comandos en Bash</ref> para usarios de Mac y Linux o, para usarios de Windows, <ref target="/es/lecciones/introduccion-a-powershell">Introducción a la línea de comandos de Windows con PowerShell</ref>. Adicionalmente, será de utilidad tener conocimientos básicos de <ref target="https://es.wikipedia.org/wiki/C%C3%B3dec">códecs</ref> y <ref target="https://es.wikipedia.org/wiki/Formato_contenedor">contenedores</ref> audiovisuales para entender con mayor detalle el funcionamiento de FFmpeg. Proporcionaremos información adicional y revisaremos con mayor detalle sobre códecs y contenedores en la sección sobre ejemplos de comandos preliminares de este tutorial.</p>
                </div>
            </div>
            <div type="2">
                <head>Cómo instalar FFmpeg</head>
                <p>La instalación de FFmpeg es posiblemente la parte más difícil de usar esta herramienta. Afortunadamente, existen algunas guías y recursos disponibles para instalar el <emph>framework</emph> para cada sistema operativo.</p>
                <p style="alert alert-warning">
Nuevas versiones de FFmpeg son lanzadas aproximadamente cada seis meses. Para mantenerse al tanto de ellas, es recomendable seguir a FFmpeg en <ref target="https://twitter.com/FFmpeg">Twitter</ref> o en su sitio web. Las nuevas versiones de FFmpeg generalmente contienen características tales como filtros nuevos y actualizados, compatibilidades de códecs y corrección de errores. La sintaxis de FFmpeg no cambia con estas actualizaciones y las capacidades antiguas rara vez se eliminan. Puedes aprender más sobre estas actualizaciones consultando los anuncios de actualizaciones anteriores en la sección de <ref target="https://www.ffmpeg.org/index.html#news">News</ref> en el sitio web de FFmpeg.
</p>
                <div type="3">
                    <head>Para usuarios de Mac OS</head>
                    <p>La opción más simple es usar un administrador de paquetes como <ref target="https://brew.sh/">Homebrew</ref> para instalar FFmpeg y asegurar que permanezca en la versión más reciente. Para completar este tipo de instalación, sigue estos pasos:</p>
                    <list type="unordered">
                        <item>
                            <p>Instala Homebrew de acuerdo a las instrucctiones en el enlace de arriba</p>
                        </item>
                        <item>
                            <p>Para comenzar con una instalación básica, ejecuta <code rend="inline">brew install ffmpeg</code> en tu Terminal para comenzar una instalación básica
<hi rend="bold">Nota</hi>: generalmente se recomienda instalar FFmpeg con opciones adicionales a la incluidas en la instalación básica; esto proporcionará acceso a más herramientas y funciones. <ref target="https://avpres.net/FFmpeg/install_Apple.html">La Guía de Instalación de Apple de Reto Kromer</ref> proporciona un buen conjunto de opciones adicionales:</p>
                            <ab>
                                <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_0" corresp="code_introduccion-a-ffmpeg_0.txt" rend="block"/>
                            </ab>
                            <list type="unordered">
                                <item>
                                    <p>Para una explicación de estas opciones adicionales, revisa <ref target="https://training.ashleyblewer.com/presentations/ffmpeg.html#10">La Guía FFmpeg de Ashley Blewer</ref>.</p>
                                </item>
                                <item>
                                    <p>Además, puedes ejecutar <code rend="inline">brew options ffmpeg</code> para ver qué características están o han estado disponibles en la versión actual de FFmpeg</p>
                                </item>
                                <item>
                                    <p>Para actualizar tu instalación a la versión más reciente, ejecuta:</p>
                                    <ab>
                                        <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_1" corresp="code_introduccion-a-ffmpeg_1.txt" rend="block"/>
                                    </ab>
                                </item>
                            </list>
                        </item>
                        <item>
                            <p>Para más opciones de instalación para Mac OS, revisa <ref target="https://trac.ffmpeg.org/wiki/CompilationGuide/macOS">La Guía de Compilación de FFmpeg para Mac OS</ref> (la guía solo está disponible en inglés).</p>
                        </item>
                    </list>
                </div>
                <div type="3">
                    <head>Para usuarios de Windows</head>
                    <p>Los usarios de Windows pueden usar el adminstratdor de paquetes <ref target="https://chocolatey.org/">Chocolately</ref> para instalar y mantener FFmpeg. <ref target="https://avpres.net/FFmpeg/install_Windows.html">La Guía de Instalación de Windows de Reto Kromer</ref> proporciona toda la información necesaria para usar Chocolately o construir el <emph>framework</emph> a partir del código fuente (la guía solo está disponible en inglés).</p>
                </div>
                <div type="3">
                    <head>Para usuarios de Linux</head>
                    <p>
                        <ref target="ttp://linuxbrew.sh/">Linuxbrew</ref> es un programa similar a Homebrew que se puede utilizar para instalar y mantener FFmepg en Linux. Reto Kromer también proporciona una guía útil, <ref target="https://avpres.net/FFmpeg/install_Linux.html">la Guía de Instalación de Linux</ref>, que es similar a la instalación en Mac OS. Tu distribución de Linux puede tener su <ref target="https://www.linode.com/docs/tools-reference/linux-package-management/">propio administrador de paquetes</ref> que incluye paquetes FFmpeg (la guía solo está disponible en inglés). Dependiendo de tu distribución de Linux (Ubuntu, Fedora, Arch Linux, etc.) estas versiones pueden variar, así que usar Linuxbrew podría ser útil para asegurar que la versión es la misma independientemente del tipo de Linux que utilices.</p>
                </div>
                <div type="3">
                    <head>Otros recursos de instalación</head>
                    <list type="unordered">
                        <item>
                            <ref target="https://www.ffmpeg.org/download.html">Descarga de paquetes</ref>
                            <list type="unordered">
                                <item>FFmpeg permite el accesso a archivos binarios, código fuente y versiones estáticas para Mac, Windows y Linux directamente en su sitio web. Los usuarios pueden construir el <emph>framework</emph> sin un administrador de paquetes con estos recursos. Es probable que solo los usuarios avanzados quieran usar esta opción.</item>
                            </list>
                        </item>
                        <item>
                            <ref target="https://trac.ffmpeg.org/wiki/CompilationGuide">La Guía de Compilación de FFmpeg</ref>
                            <list type="unordered">
                                <item>La página Wiki de FFmpeg también proporciona un compendio de guías y estrategias para instalar FFmpeg en tu computadora (la guía solo está disponible en inglés).</item>
                            </list>
                        </item>
                    </list>
                </div>
                <div type="3">
                    <head>Probando la instalación</head>
                    <list type="unordered">
                        <item>
                            <p>Para asegurarte de que FFmpeg se haya instalado correctamente, ejecuta:</p>
                            <ab>
                                <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_2" corresp="code_introduccion-a-ffmpeg_2.txt" rend="block"/>
                            </ab>
                        </item>
                        <item>
                            <p>Si ves una lista larga con información, ¡la instalación fue exitosa! Debe ser similar a lo siguiente:</p>
                        </item>
                    </list>
                    <ab>
                        <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_3" corresp="code_introduccion-a-ffmpeg_3.txt" rend="block"/>
                    </ab>
                    <list type="unordered">
                        <item>
Si el sistema arroja <code rend="inline">-bash: ffmpeg: command not found</code>, algo ha ido mal.<list type="unordered">
                                <item>Nota: Si estás usando un administrador de paquetes, es improbable que encuentres este mensaje de error. Sin embargo, si hay un problema después de instalar con un administrador de paquetes, es probable que haya un problema con el administrador de paquetes y no con FFmpeg. Consulta la solución de problemas en <ref target="https://docs.brew.sh/Troubleshooting">Homebrew</ref>, <ref target="https://chocolatey.org/docs/troubleshooting">Chocolatey</ref>, o <ref target="http://linuxbrew.sh/">Linuxbrew</ref> para asegurar que el administrador de paquetes está funcionando correctamente en tu computadora (las guías solo está disponible en inglés). Si estás intentando instalar sin un administrador de paquetes y ves este mensaje de error, haz una referencia cruzada de tu método con la La Guía de Compilación de FFmpeg anterior.</item>
                            </list>
                        </item>
                    </list>
                </div>
                <div type="3">
                    <head>Usando FFmpeg en el navegador</head>
                    <p>Si no quieres instalar FFmepg en tu computadora pero te gustaría familiarizarte con el <emph>framework</emph> y usarlo en la interfaz de línea de comandos, <ref target="https://bgrins.github.io/videoconverter.js/demo/">videoconverter.js</ref> de Brian Grinstead proporciona un método para ejecutar los comandos FFmpeg en tu navegador (la interfaz está en inglés).</p>
                    <p style="alert alert-warning">
  Esta interfaz del navegador no tiene las funcionalidades como para completar todo este tutorial, pero es útil para aprender los comandos esenciales de FFmpeg. Adicionalmente, este recurso opera en una versión anterior de FFmpeg y posiblemente no tenga todas las características de la versión más reciente.
</p>
                </div>
                <div type="3">
                    <head>Estructura básica y sintaxis de los comandos FFmpeg</head>
                    <p>El comando básico tiene cuatro partes:</p>
                    <ab>
                        <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_4" corresp="code_introduccion-a-ffmpeg_4.txt" rend="block"/>
                    </ab>
                    <list type="unordered">
                        <item>Cada comando comenzará con un símbolo del sistema. Dependiendo del uso, este será <code rend="inline">ffmpeg</code> (cambiar archivos), <code rend="inline">ffprobe</code> (generar metadatos de archivos) o <code rend="inline">ffplay</code> (reproducir archivos).</item>
                        <item>Los archivos de entradas son los archivos que están siendo leídos, editados o examinados.</item>
                        <item>Las banderas y acciones son las cosas que le estás diciendo a FFmpeg que haga con los archivos de entrada. La mayoría de los comandos contendrán múltiples banderas y acciones de complejidad variable.</item>
                        <item>Los archivos de salida son los archivos creados por el comando o los informes creados por los commandos de <code rend="inline">ffprobe</code>.</item>
                    </list>
                    <p>Escrito genéricamente, el comando básico es parecido a lo siguiente:</p>
                    <ab>
                        <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_5" corresp="code_introduccion-a-ffmpeg_5.txt" rend="block"/>
                    </ab>
                    <p style="alert alert-warning">
Como con cualquier interfaz de línea de comandos, tendrás que escribir las rutas de los archivos de entrada y de salida dependiendo de las ubicaciones de tus directorios de trabajo. En los ejemplos proporcionados en este tutorial, las rutas de archivos no estarán escritas completamente y se supone que el usuario ha navegado al directorio de trabajo para ejecutar los comandos.</p>
                    <p>A continuación, examinaremos algunos ejemplos de varios comandos diferentes que usan esta estructura y sintaxis. Adicionalmente, estos comandos demostrarán algunas de las características más útiles de FFmpeg y nos permitirán familiarizarnos con la forma en que se construyen los archivos audiovisuales digitales.</p>
                </div>
            </div>
            <div type="2">
                <head>Para empezar</head>
                <p>Para este tutorial, utilizaremos una película archivística que se llama <ref target="https://archive.org/details/4050_Destination_Earth_01_47_33_28">
                        <emph>Destination Earth</emph>
                    </ref> como nuestro objeto de estudio. Esta película está publicada por los <ref target="https://es.wikipedia.org/wiki/Archivos_Prelinger">Archivos Prelinger</ref> y en el <ref target="https://archive.org/">Internet Archive</ref>. Esta película, estrenada en 1956 y producida por <ref target="https://es.wikipedia.org/wiki/American_Petroleum_Institute">El American Petroleum Institute</ref> y <ref target="https://en.wikipedia.org/wiki/John_Sutherland_(producer)">John Sutherland Productions</ref>, es un excelente ejemplo de la propaganda de la época de la Guerra Fría que exalta las virtudes del capitalismo y el estilo de vida estadounidense. Utilizando el proceso de <ref target="https://es.wikipedia.org/wiki/Technicolor">Technicolor</ref>, este corto animado de ciencia ficción cuenta la historia de una sociedad marciana que vive bajo un gobierno opresivo y sus esfuerzos para mejorar sus métodos industriales. Envían un emisario a la Tierra que descubre que la clave para esto es la refinación de petróleo y la libre empresa. Utilizaremos el vídeo para introducir algunas de las funcionalidades básicas de FFmpeg y analizar sus propiedades de color con relación a su retórica propagandística.</p>
                <figure>
                    <desc>Destination Earth (1956)</desc>
                    <graphic url="destEarth_titlecard.png"/>
                </figure>
                <p>En este tutorial se llevarán a cabo los siguientes pasos:</p>
                <list type="unordered">
                    <item>Navegar a la página de <ref target="https://archive.org/details/4050_Destination_Earth_01_47_33_28">
                            <emph>Destination Earth</emph>
                        </ref> en el Internet Archive</item>
                    <item>Descargar dos archivos vídeos: las versiones "MPEG4" (extensión de archivo <code rend="inline">.m4v</code>) y "OGG" (extensión de archivo <code rend="inline">.ogv</code>) de la película</item>
                    <item>Guardar estos archivos en la misma carpeta en algún lugar de tu computadora. Guárdalos con los nombres de archivos <code rend="inline">destEarth</code>, seguido por su extensión.</item>
                </list>
                <p>Tómate unos minutos para ver el vídeo y tener una idea de su estructura, mensaje y motivos visuales antes de continuar con los siguientes comandos.</p>
            </div>
            <div type="2">
                <head>Ejemplos de comandos preliminares</head>
                <div type="3">
                    <head>Ver metadatos básicos con FFprobe</head>
                    <p>Antes de comenzar a manipular nuestros archivos <code rend="inline">destEarth</code>, usemos FFmpeg para examinar información básica sobre el archivo utilizando un simple comando de <code rend="inline">ffprobe</code>. Esto ayudará a comprender cómo se construyen los archivos audiovisuales digitales y proporcionará una base para el resto del tutorial. Navega hasta el directorio del archivo y ejecuta:</p>
                    <ab>
                        <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_6" corresp="code_introduccion-a-ffmpeg_6.txt" rend="block"/>
                    </ab>
                    <p>Verás los metadatos técnicos básicos del archivo impresos en <code rend="inline">stdout</code>:</p>
                    <figure>
                        <desc>El output de un comando básico `ffprobe` con destEarth.ogv</desc>
                        <graphic url="ffprobe_ogg_es.png"/>
                    </figure>
                    <p>La línea <code rend="inline">Input # 0</code> del informe identifica el <hi rend="bold">contenedor</hi> como <ref target="https://es.wikipedia.org/wiki/Ogg">ogg</ref>. Los contenedores (también llamados "envoltorios" o "wrappers", en inglés) proporcionan al archivo la estructura de sus diversas pistas. Los diferentes contenedores (otros más comunes incluyen <code rend="inline">.mkv</code>, <code rend="inline">.avi</code> y <code rend="inline">.flv</code>) tienen diferentes características y compatibilidad con diversos programas. Examinaremos cómo y por qué es posible que desees cambiar el contenedor de un archivo en el siguiente comando.</p>
                    <p>Las líneas <code rend="inline">Stream #0:0</code> y <code rend="inline">Stream #0:1</code> proporcionan información sobre las pistas del archivo (es decir, el contenido que ves en la pantalla y escuchas a través de sus altavoces) y también identifican el <hi rend="bold">códec</hi> de cada pista. Los códecs especifican cómo se codifica/comprime (se escribe y almacena) y se decodifica (se reproduce) la información. La pista vídeo (<code rend="inline">Stream #0:0</code>) de nuestro archivo <code rend="inline">.ogv</code> usa el códec <ref target="https://es.wikipedia.org/wiki/Theora">theora</ref> y la pista audio (<code rend="inline">Stream #0:1</code>) usa el códec <ref target="https://es.wikipedia.org/wiki/Vorbis">vorbis</ref>. Estas líneas también proporcionan información importante relacionada con el espacio de color de la pista de vídeo (<code rend="inline">yuv420p</code>), resolución (<code rend="inline">400x300</code>) y marcos por segundo (<code rend="inline">29.97 fps</code>). Adicionalmente, proporcionan información de audio como la tasa de muestreo (<code rend="inline">44100 Hz</code>) y la tasa de bits (<code rend="inline">128 kb/s</code>).</p>
                    <p>Los códecs, en mayor medida que los contenedores, determinan la calidad y la compatibilidad de un archivo audiovisual con diferentes programas y plataformas (otros códecs comunes incluyen <code rend="inline">DNxHD</code> y<code rend="inline"> ProRes</code> para vídeo y <code rend="inline">mp3</code> y<code rend="inline"> FLAC</code> para audio). Examinaremos cómo y por qué es posible que también desees cambiar el códec de un archivo en el siguiente comando.</p>
                    <p>Ejecuta otro comando de <code rend="inline">ffprobe</code>, esta vez con el archivo <code rend="inline">.m4v</code>:</p>
                    <ab>
                        <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_7" corresp="code_introduccion-a-ffmpeg_7.txt" rend="block"/>
                    </ab>
                    <p>Una vez más, verás los metadatos técnicos básicos impresos en el <code rend="inline">stdout</code>:</p>
                    <figure>
                        <desc>El output de un comando básico `ffprobe` con destEarth.m4v</desc>
                        <graphic url="ffprobe_mp4_es.png"/>
                    </figure>
                    <p>También notarás que el informe para el archivo <code rend="inline">.m4v</code> contiene múltiples contenedores en la línea <code rend="inline">Input # 0</code> como <code rend="inline">mov</code> y <code rend="inline">m4a</code>. No es necesario profundizar en los detalles para los fines de este tutorial, pero ten en cuenta que los contenedores <code rend="inline">mp4</code> y<code rend="inline"> mov</code> se presentan en múltiples "sabores" y diferentes extensiones de archivo. Sin embargo, todos son muy similares en su construcción técnica y, como tal, pueden verse agrupados en metadatos técnicos. De manera similar, el archivo <code rend="inline">ogg</code> tiene la extensión<code rend="inline"> .ogv</code>, un "sabor" o variante del formato <code rend="inline">ogg</code>.</p>
                    <p>Al igual que en nuestro comando anterior, las líneas <code rend="inline">Stream # 0: 0</code> y<code rend="inline"> Stream # 0: 1</code> identifican el códec de cada pista. Podemos ver que nuestro archivo <code rend="inline">.m4v</code> usa el códec vídeo <ref target="https://es.wikipedia.org/wiki/H.264/MPEG-4_AVC">H.264</ref> y el códec audio <ref target="https://es.wikipedia.org/wiki/Advanced_Audio_Coding">aac</ref>. Ten en cuenta que se nos proporcionan metadatos similares a nuestro archivo <code rend="inline">.ogv</code>, pero algunas características importantes relacionadas con el análisis visual (como la resolución) son significativamente diferentes. Nuestro <code rend="inline">.m4v</code> tiene una resolución más alta (<code rend="inline">640x480</code>) y, por lo tanto, utilizaremos esta versión de <emph>Destination Earth</emph> como nuestro vídeo de origen.</p>
                    <p>Ahora que sabemos más sobre la composición técnica de nuestro archivo, podemos comenzar a explorar las características y funcionalidades transformadoras de FFmpeg (volveremos a utilizar <code rend="inline">ffprobe</code> más adelante en el tutorial para realizar una extracción de metadatos de color más avanzada).</p>
                </div>
                <div type="3">
                    <head>Cambiar el contenedor (volver a envolver, "re-wrap")</head>
                    <p>Dependiendo de tu sistema operativo, puedes tener uno o más reproductores de medios instalados. Para efectos de demostración veamos qué sucede si intentas abrir <code rend="inline">destEarth.ogv</code> usando el reproductor de medios QuickTime que viene con Mac OSX:</p>
                    <figure>
                        <desc>Los reproductores multimedia patentados como Quicktime a menudo están limitados en los tipos de archivos con los que pueden trabajar</desc>
                        <graphic url="QT_fail.png"/>
                    </figure>
                    <p>Una opción cuando te enfrentas a un mensaje de este tipo es simplemente usar otro reproductor de medios. <ref target="https://www.videolan.org/vlc/index.es.html">VLC</ref>, que está construido con FFmpeg, es una excelente alternativa de código abierto, pero simplemente "usar otro programa" puede no ser siempre una solución viable (y es posible que no siempre tengas otra versión de archivo con la que trabajar). Muchos editores de vídeo populares, como Adobe Premiere, Final Cut Pro y DaVinci Resolve, tienen sus propias limitaciones en cuanto a los tipos de formatos con los que son compatibles. Además, las diferentes plataformas web y sitios de alojamiento/transmisión, como Vimeo, <ref target="https://help.vimeo.com/hc/es/articles/12426043233169-Video-and-audio-compression-guidelines">también tienen sus propios requisitos.</ref> Por lo tanto, es importante poder volver a envolver y transcodificar tus archivos para cumplir con las diversas especificaciones para la reproducción, edición, publicación digital y ajuste de archivos a los estándares requeridos por las plataformas de archivo o preservación digital.</p>
                    <p style="alert alert-warning">
Para obtener una lista completa de los códecs y contenedores compatibles con tu instalación de FFmpeg, ejecuta <code rend="inline">ffmpeg -codecs</code> y <code rend="inline">ffmpeg -formats</code>, respectivamente, para ver la lista impresa de tu <code rend="inline">stdout</code>.
</p>
                    <p>Como un ejercicio para aprender la sintaxis básica de FFmpeg y aprender a transcodificar entre formatos, comenzaremos con nuestro archivo <code rend="inline">destEarth.ogv</code> y escribiremos un nuevo archivo con vídeo codificado en<code rend="inline"> H.264</code>, audio en <code rend="inline">AAC</code> y envuelto en un contenedor <code rend="inline">.mp4</code>, una combinación muy común y altamente portátil de códecs y contenedores que es prácticamente idéntico al archivo<code rend="inline"> .m4v</code> que originalmente descargamos. Aquí está el comando que ejecutarás, junto con una explicación de cada parte de la sintaxis:</p>
                    <ab>
                        <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_8" corresp="code_introduccion-a-ffmpeg_8.txt" rend="block"/>
                    </ab>
                    <list type="unordered">
                        <item>
                            <code rend="inline">ffmpeg</code> = comienza el comando</item>
                        <item>
                            <code rend="inline">-i destEarth.ogv</code> = especifica el archivo de entrada</item>
                        <item>
                            <code rend="inline">-c:v libx264</code> = transcodifica la pista de vídeo al codec H.264</item>
                        <item>
                            <code rend="inline">-c:a aac</code> = transcodifica la pista de audio al codec AAC</item>
                        <item>
                            <code rend="inline">destEarth_transcoded.mp4</code> = especifica el archivo de salida. Ten en cuenta que aquí es donde se especifica el nuevo tipo de contenedor.</item>
                    </list>
                    <p>Si ejecutas como está escrito y en el mismo directorio que <code rend="inline">destEarth.ogv</code>, verás un nuevo archivo llamado<code rend="inline"> destEarth_transcoded.mp4</code>, que aparecerá en el directorio. Si estás operando en Mac OSX, también podrás reproducir este nuevo archivo con QuickTime. Una exploración completa de los convenios de códecs, contenedores, compatibilidad y extensión de archivos está más allá del alcance de este tutorial; sin embargo, este conjunto de ejemplos preliminares debería darles a aquellos que no estén familiarizados con la forma en que se construyen los archivos audiovisuales digitales un conjunto de conocimientos de referencia que les permitirá completar el resto del tutorial.</p>
                </div>
                <div type="3">
                    <head>Creación de extractos y "demuxing" de audio y vídeo</head>
                    <p>Ahora que tenemos un mejor entendimiento de las pistas, códecs, y contenedores, veamos formas en que FFmpeg puede trabajar con materiales de vídeo a un nivel más granular. Para este tutorial, examinaremos dos secciones separadas de <emph>Destination Earth</emph> para comparar cómo se usa el color en relación con la retórica propagandística de la película. Crearemos y prepararemos estos extractos para el análisis utilizando un comando que realiza dos funciones diferentes simultáneamente:</p>
                    <list type="unordered">
                        <item>Primero, el comando creará dos extractos de <code rend="inline">destEarth.m4v</code>.</item>
                        <item>
Segundo, el comando eliminará ("demux") los componentes de audio (<code rend="inline">Stream # 0: 1</code>) de estos extractos.<p style="alert alert-warning">
Estamos eliminando el audio para ahorrar espacio de almacenamiento (la información de audio no es necesaria para el análisis de color). Esto probablemente será útil si esperas utilizar este tipo de análisis a escalas más grandes. Cerca del final del tutorial, se discutirá más información sobre la ampliación del análisis de color.
</p>
                        </item>
                    </list>
                    <p>El primer extracto que haremos contiene una secuencia correspondiente al comienzo de la película que describe las difíciles condiciones y la vida oprimida de la sociedad marciana. El siguiente comando especifica los puntos de inicio y finalización del extracto, le dice a FFmpeg que retenga toda la información en la pista de vídeo sin transcodificar nada y le indica que escriba nuestro nuevo archivo sin la pista de audio:</p>
                    <ab>
                        <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_9" corresp="code_introduccion-a-ffmpeg_9.txt" rend="block"/>
                    </ab>
                    <list type="unordered">
                        <item>
                            <code rend="inline">ffmpeg</code> = comienza el comando</item>
                        <item>
                            <code rend="inline">-i destEarth.m4v</code> = especifica el archivo de entrada</item>
                        <item>
                            <code rend="inline">-ss 00:01:00</code> = establece el punto de inicio a 1 minuto del inicio del archivo</item>
                        <item>
                            <code rend="inline">-to 00:04:45</code> = establece el punto final a 4 minutos y 45 segundos desde el inicio del archivo</item>
                        <item>
                            <code rend="inline">-c:v copy</code> = copia la pista de vídeo directamente, sin transcodificar</item>
                        <item>
                            <code rend="inline">-an</code> = le dice a FFmpeg que ignore la pista de audio al escribir el archivo de salida.</item>
                        <item>
                            <code rend="inline">destEarth_Mars_video.mp4</code> = especifica el archivo de salida</item>
                    </list>
                    <figure>
                        <desc>Vida en Marte</desc>
                        <graphic url="Mars_screenshot.png"/>
                    </figure>
                    <p>Ahora, ejecutaremos un comando similar para crear un extracto de "Tierra". Esta parte de la película tiene una secuencia similar que describe las maravillas de la vida en la Tierra y la riqueza de su sociedad gracias al capitalismo de libre empresa y al uso de petróleo y productos derivados de este:</p>
                    <ab>
                        <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_10" corresp="code_introduccion-a-ffmpeg_10.txt" rend="block"/>
                    </ab>
                    <figure>
                        <desc>La abundancia de la Tierra</desc>
                        <graphic url="Earth_screenshot.png"/>
                    </figure>
                    <p>Ahora deberías tener dos archivos nuevos en tu directorio llamados <code rend="inline">destEarth_Mars_video.mp4</code> y<code rend="inline"> destEarth_Earth_video.mp4</code>. Puedes probar uno o ambos archivos (o cualquiera de los otros archivos en el directorio) usando la función <code rend="inline">ffplay</code> de FFmpeg. Simplemente ejecuta:</p>
                    <ab>
                        <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_11" corresp="code_introduccion-a-ffmpeg_11.txt" rend="block"/>
                    </ab>
                    <p>y/o</p>
                    <ab>
                        <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_12" corresp="code_introduccion-a-ffmpeg_12.txt" rend="block"/>
                    </ab>
                    <p>Verás una ventana abierta y el vídeo comenzará en el punto de iniicio especificado. Se reproducirá una vez y luego la ventana se cerrará (además, notarás que no hay sonido en tu vídeo). También notarás que los comandos <code rend="inline">ffplay</code> no requieren que se especifique una entrada (<code rend="inline">-i</code>) o una salida porque la reproducción en sí misma es la salida.</p>
                    <p style="alert alert-warning">
                        <code rend="inline">FFplay</code> es un reproductor multimedia muy versátil que viene con una serie de <ref target="https://ffmpeg.org/ffplay.html#Options">opciones</ref> para personalizar la reproducción. Por ejemplo, si agregas `-loop 0` al comando se reproducirá en bucle indefinidamente.</p>
                    <p>Ahora hemos creado nuestros dos extractos para el análisis. Si vemos estos clips por separado, parece haber diferencias significativas en la forma en que se utilizan el color y la variedad de colores. En la siguiente parte del tutorial examinaremos y extraeremos datos de los archivos de vídeo para cuantificar y apoyar esta hipótesis.</p>
                </div>
                <div type="3">
                    <head>Análisis de datos de color</head>
                    <p>El uso de herramientas digitales para analizar la información de color en películas es otra faceta emergente de las Humanidades Digitales que se superpone con los estudios cinematográficos tradicionales. En particular, el proyecto <ref target="https://filmcolors.org/">FilmColors</ref> de la Universidad de Zurich cuestiona la intersección crítica de las "características estéticas formales de los aspectos semánticos, históricos y tecnológicos" de su producción, recepción y difusión a través del uso de herramientas de análisis y anotación digital (Flueckiger, 2017, traducido por el autor). Aunque no hay un método estandarizado para este tipo de investigación, en el momento de escribir esta lección el comando <code rend="inline">ffprobe</code> que se describe a continuación es una una herramienta útil para extraer información de color que se puede usar en el análisis computacional. Primero, veamos otra manera estandarizada de representar la información de color que informa este enfoque cuantitativo, basado en datos, para el análisis de color: los vectorscopios.</p>
                    <div type="4">
                        <head>Vectorscopios</head>
                        <p>Durante años, profesionales del vídeo han confiado en los <ref target="https://es.wikipedia.org/wiki/Vectorscopio">vectorscopios</ref> para ver la información del color de una manera estandarizada y fácilmente legible. Un vectorscopio grafica información de color en una gratícula circular. La posición del gráfico corresponde a los <ref target="https://es.wikipedia.org/wiki/Tono_(color)">tonos</ref> particulares encontrados en una señal de vídeo. Otros factores, como la saturación, determinan también el tamaño de un gráfico. A continuación se presenta un ejemplo de un vectorscopio que muestra los valores de color de las barras SMPTE.</p>
                        <figure>
                            <desc>Una lectura de vectorescopio que representa las barras SMPTE NTSC estándar. Fuente: Wikimedia Commons</desc>
                            <graphic url="vectorscope.png"/>
                        </figure>
                        <figure>
                            <desc>Las barras SMPTE. Fuente: Wikimedia Commons</desc>
                            <graphic url="smpte_bars.png"/>
                        </figure>
                        <p>FFmpeg se puede utilizar para reproducir y crear archivos de vídeo con vectorscopios integrados en ellos para proporcionar una referencia en tiempo real para la información de color del vídeo. Los siguientes comandos <code rend="inline">ffplay</code> incorporarán un vectorscopio en la esquina inferior derecha del marco. A medida que se reproduce el vídeo, notarás el cambio en el gráfico del vectorscopio a medida que cambia el color en pantalla:</p>
                        <ab>
                            <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_13" corresp="code_introduccion-a-ffmpeg_13.txt" rend="block"/>
                        </ab>
                        <list type="unordered">
                            <item>
                                <code rend="inline">ffplay</code> = comienza el comando</item>
                            <item>
                                <code rend="inline">-i entrada_archivo.ext</code> = la ruta y el nombre del archivo de entrada</item>
                            <item>
                                <code rend="inline">-vf</code> = crea un <ref target="https://trac.ffmpeg.org/wiki/FilteringGuide">
                                    <emph>filter-graph</emph>
                                </ref> para usar con las pistas</item>
                            <item>
                                <code rend="inline">"</code> = una comilla para comenzar el <emph>filter-graph.</emph> La información entre las comillas
especifica los parámetros de la apariencia y posición del vectorscopio</item>
                            <item>
                                <code rend="inline">split=2[m][v]</code> = divide la entrada en dos salidas idénticas llamadas <code rend="inline">[m]</code> y <code rend="inline">[v]</code>
                            </item>
                            <item>
                                <code rend="inline">,</code> = la coma indica que viene otro parámetro</item>
                            <item>
                                <code rend="inline">[v]vectorscope=b=0.7:m=color3:g=green[v]</code> = asigna la salida <code rend="inline">[v]</code> al filtro del vectorscopio</item>
                            <item>
                                <code rend="inline">[m][v]overlay=x=W-w:y=H-h</code> = superpone el vectorscopio encima de la imagen de vídeo en una cierta ubicación (en este caso, en la esquina inferior derecha de la pantalla)</item>
                            <item>
                                <code rend="inline">"</code> = termina el <emph>filter-graph</emph>
                            </item>
                        </list>
                        <p style="alert alert-warning">
Para obtener más información sobre las diversas opciones para crear vectorscopios, consulta <ref target="https://ffmpeg.org/ffmpeg-filters.html#vectorscope"> la documentación oficial</ref> y <ref target="https://trac.ffmpeg.org/wiki/Vectorscope">la página Wiki FFmpeg Vectorscope</ref>. Además, puedes encontrar más información sobre cómo colocar las superposiciones en <ref target="https://ffmpeg.org/ffmpeg-filters.html#overlay-1">la documentación del filtro de superposición FFmpeg</ref>.
</p>
                        <figure>
                            <desc>Captura de pantalla de la ventana de FFplay con vectorscopio incorporado</desc>
                            <graphic url="Mars_screenshot_vector.png"/>
                        </figure>
                        <p>Y para el extracto de "Tierra":</p>
                        <ab>
                            <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_14" corresp="code_introduccion-a-ffmpeg_14.txt" rend="block"/>
                        </ab>
                        <figure>
                            <desc>Captura de pantalla de la ventana de FFplay con vectorscopio incorporado</desc>
                            <graphic url="Earth_screenshot_vector.png"/>
                        </figure>
                        <p>También podemos ajustar este comando para escribir nuevos archivos de vídeo con vectorscopios:</p>
                        <ab>
                            <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_15" corresp="code_introduccion-a-ffmpeg_15.txt" rend="block"/>
                        </ab>
                        <ab>
                            <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_16" corresp="code_introduccion-a-ffmpeg_16.txt" rend="block"/>
                        </ab>
                        <p>Nota los pequeños pero importantes cambios en sintaxis:</p>
                        <list type="unordered">
                            <item>Hemos agregado una bandera de <code rend="inline">-i</code> porque es un comando de <code rend="inline">ffmpeg</code>
                            </item>
                            <item>Hemos especificado el códec del vídeo del archivo de salida como <ref target="https://es.wikipedia.org/wiki/H.264/MPEG-4_AVC">H.264</ref> con la bandera <code rend="inline">-c:v libx264</code> y no estamos recodificando el códec de audio (<code rend="inline">-c:a copy</code>), aunque puedes especificar otro códec de audio si lo necesitas.</item>
                            <item>Hemos definido el nombre del archivo de salida</item>
                        </list>
                        <p>Tómate unos minutos para ver estos vídeos con los vectorscopios integrados en ellos. Observa cuán dinámicos (o no) son los cambios entre los extractos de "Marte" y "Tierra". Compara lo que ves en el vectorscopio con tus propias impresiones del vídeo mismo. Podríamos usar las observaciones de estos vectorscopios para hacer determinaciones sobre qué tonos de color aparecen de manera más regular o intensa en el vídeo, o podemos comparar diferentes formatos uno al lado del otro para ver cómo el color se codifica o representa de manera diferente en función de diferentes códecs, resoluciones, etc.</p>
                        <p>Aunque los vectorscopios proporcionan una representación útil y en tiempo real de la información del color, es posible que también deseemos acceder a los datos sin procesar que se encuentran debajo de ellos. Luego, podemos usar estos datos para desarrollar visualizaciones más flexibles que no dependan de ver el archivo de vídeo simultáneamente y que ofrezcan un enfoque más cuantitativo para el análisis de color. En nuestros próximos comandos, utilizaremos <code rend="inline">ffprobe</code> para producir un conjunto tabular de datos que pueda usarse para crear un gráfico de datos de color.</p>
                    </div>
                    <div type="4">
                        <head>Extracción de datos de color con FFprobe</head>
                        <p>Al comienzo de este tutorial, utilizamos un comando <code rend="inline">ffprobe</code> para ver los metadatos básicos de nuestro archivo impresos en el <code rend="inline">stdout</code>. En los siguientes ejemplos, utilizaremos <code rend="inline">ffprobe</code> para extraer datos de color de nuestros extractos de vídeo y enviar esta información a archivos<code rend="inline"> .csv</code>. Dentro de nuestro comando <code rend="inline">ffprobe</code>, vamos a utilizar el filtro<code rend="inline"> signalstats</code> para crear reportes <code rend="inline">.csv</code> de información de tono de color medio para cada marco en la secuencia de vídeo de<code rend="inline"> destEarth_Mars_video.mp4</code> y <code rend="inline">destEarth_Earth_video.mp4</code>, respectivamente.</p>
                        <ab>
                            <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_17" corresp="code_introduccion-a-ffmpeg_17.txt" rend="block"/>
                        </ab>
                        <list type="unordered">
                            <item>
                                <code rend="inline">ffprobe</code> = comienza el comando</item>
                            <item>
                                <code rend="inline">-f lavfi</code> = especifica el dispositivo de entrada virtual <ref target="https://ffmpeg.org/ffmpeg-devices.html#lavfi">libavfilter</ref> como el formato elegido. Esto es necesario cuando se usa <code rend="inline">signalstats</code> y muchos filtros en comandos FFmpeg más complejos.</item>
                            <item>
                                <code rend="inline">-i movie=destEarth_Mars_video.mp4</code> = nombre del archivo de entrada</item>
                            <item>
                                <code rend="inline">,signalstats</code> = especifica el uso del filtro <code rend="inline">signalstats</code> con el archivo de entrada</item>
                            <item>
                                <code rend="inline">-show_entries</code> = establece una lista de entradas que se mostrarán en el informe. Estos se especifican en las siguientes opciones.</item>
                            <item>
                                <code rend="inline">frame=pkt_pts_time</code> = especifica mostrar cada marco con tu correspondiente <code rend="inline">pkt_pts_time</code>, creando una entrada única para cada marco de vídeo</item>
                            <item>
                                <code rend="inline">:frame_tags=lavfi.signalstats.HUEMED</code> = crea una etiqueta para cada marco que contiene el valor de tono medio</item>
                            <item>
                                <code rend="inline">-print_format csv</code> = especifica el formato del informe de metadatos</item>
                            <item>
                                <code rend="inline">&gt; destEarth_Mars_hue.csv</code> = escribe un nuevo archivo <code rend="inline">.csv</code> que contiene el informe de metadatos usando<code rend="inline">&gt; </code>, un <ref target="https://www.gnu.org/software/bash/manual/html_node/Redirections.html">operador de redireccionamiento de Bash</ref>. Este operador toma el comando que lo precede y "redirige" la salida a otra ubicación. En este caso, está escribiendo la salida en un nuevo archivo <code rend="inline">.csv</code>. La extensión de archivo proporcionada aquí también debe coincidir con el formato especificado por el indicador <code rend="inline">print_format</code>.</item>
                        </list>
                        <p>A continuación, ejecuta el mismo comando para el extracto de "Tierra":</p>
                        <ab>
                            <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_18" corresp="code_introduccion-a-ffmpeg_18.txt" rend="block"/>
                        </ab>
                        <p style="alert alert-warning">
Para obtener más información sobre el filtro de <code rend="inline">signalstats</code> y las diversas métricas que se pueden extraer de las transmisiones de vídeo, consulta <ref target="https://ffmpeg.org/ffmpeg-filters.html#signalstats-1">la documentación del filtro FFmpeg</ref>.
</p>
                        <p>Ahora deberías tener dos archivos <code rend="inline">.csv</code> en tu directorio. Si los abres en un editor de texto o en un programa de hoja de cálculo, verás tres columnas de datos:</p>
                        <figure>
                            <desc>Las primeras filas de nuestro informe de color en formato .csv</desc>
                            <graphic url="csv_head.png"/>
                        </figure>
                        <p>Comenzando a la izquierda y moviéndose a la derecha, las dos primeras columnas nos dan información sobre dónde estamos en el vídeo. Los números decimales representan fracciones de segundo que también corresponden aproximadamente a la base de tiempo de vídeo de 30 marcos por segundo. Cada fila en nuestro <code rend="inline">.csv</code> corresponde a un marco de vídeo. La tercera columna lleva un número entero entre 0-360, valor que representa el tono medio para ese marco de vídeo. Estos números son los datos cuantitativos subyacentes del diagrama de vectorscopio y corresponden a su posición (en radianes) en la gratícula circular. Haciendo referencia a nuestra imagen de vectorescopio de antes, puedes ver que comenzando en la parte inferior del círculo (0 grados) y moviéndose a la izquierda, los "verdes" comienzan alrededor de los 38 grados, los "amarillos" en los 99 grados, los "rojos" en los 161 grados, los "magentas" en los 218 grados, los "azules" en los 279 grados y los "cianes" en los 341 grados. Una vez que comprendas estos "rangos" de tono, puedes hacerte una idea de cuál es el valor de tono medio para un marco de vídeo con solo mirar este valor numérico.</p>
                        <p>Además, ten en cuenta que este valor extraído por el filtro <code rend="inline">signalstats</code> no es una medida absoluta o completa de las cualidades de color de una imagen, sino simplemente un punto de referencia significativo desde el cual podemos explorar una estrategia basada en datos para el análisis de color. La percepción del color y la teoría del color son <ref target="https://colourturn.net/">áreas complejas y en evolución de la investigación académica</ref> que incorporan muchas estrategias diferentes de las humanidades, las ciencias sociales y las ciencias cognitivas. Es por eso que debemos tener en cuenta que cualquier estrategia analítica debe tomarse dentro del contexto de estos discursos más amplios y con un espíritu colaborativo y generativo.</p>
                    </div>
                    <div type="4">
                        <head>Visualizando datos de color</head>
                        <p>Los dos archivos <code rend="inline">.csv</code> que creamos con los comandos anteriores ahora se pueden usar para crear gráficos que visualicen los datos. Hay una serie de plataformas (tanto propietarias como de código abierto) que se pueden usar para lograr esto, como <ref target="https://www.wikihow.com/Create-a-Graph-in-Excel">Microsoft Excel</ref>, <ref target="https://rawgraphs.io/">RawGraphs</ref> y/o <ref target="https://plotly.com/graphing-libraries/">plotly</ref>. Una discusión en profundidad sobre cómo usar cualquiera de estas plataformas está fuera del alcance de este tutorial; sin embargo, a continuación se muestra la visualización final de los comandos anteriores, que se creó con los archivos <code rend="inline">.csv</code> y plotly.</p>
                        <figure>
                            <desc>Gráfico que incluye datos de tono medio de ambos extractos de vídeo</desc>
                            <graphic url="Final_Graph_plotly.png"/>
                        </figure>
                    </div>
                    <div type="4">
                        <head>Conclusiones</head>
                        <p>Al observar el gráfico, podemos ver que las trazas de Marte y la Tierra tienen rangos dinámicos muy diferentes en sus valores de tono medio. La traza de Marte es muy limitada y se mantiene dentro de los rangos rojo y amarillo (aproximadamente entre 100 y 160) en la mayoría del extracto. Esto sugiere algo sobre el uso del color en la película como un dispositivo retórico que sirve como mensaje propagandístico. Recuerda que esta sección presenta una visión antipática de la forma de vida y el sistema político marcianos: una población uniforme e infeliz, que depende de tecnología y transporte ineficientes mientras se les exige que observen la obediencia total a un gobernante supremo totalitario. La película conecta esta experiencia negativa con una paleta de tonos relativamente opacos de rojo y amarillo. También deberíamos considerar el público objetivo original de esta película, los jóvenes ciudadanos de los Estados Unidos en la década de 1950, y cómo probablemente habrían interpretado estas imágenes y usos del color en ese momento histórico. En particular, podemos considerar este uso del color en el contexto de las crecientes tensiones geopolíticas entre la Unión Soviética y los Estados Unidos y sus aliados en Europa occidental. El color rojo, específicamente, se usaba comúnmente en los medios impresos y de difusión para describir <ref target="https://es.wikipedia.org/wiki/Temor_rojo">la "amenaza" del comunismo global</ref> durante esta era de la historia mundial. Además, la elección de presentar al líder totalitario marciano con una apariencia muy similar al icónico líder soviético <ref target="https://es.wikipedia.org/wiki/I%C3%B3sif_Stalin">Joseph Stalin</ref> puede leerse como una señal visual y cultural explícita para la audiencia. Así, esta representación de Marte parece ser una caricatura alegórica de la vida bajo el velo del comunismo, tal como la percibe un observador externo y un oponente político/ideológico. Esta caricatura emplea no solo una paleta de colores limitada, sino una que está cargada con otras referencias culturales. El uso del color aprovecha los prejuicios y asociaciones que están presentes en el imaginario de la audiencia y, por lo tanto, está ligado estrechamente al argumento central de la película, que sostiene que el comunismo no es un sistema político viable.</p>
                        <p>En contraste con el uso limitado del color en nuestro extracto de Marte, la traza de la Tierra cubre un rango dinámico mucho más amplio de valores de tono. En este pasaje, el emisario marciano está aprendiendo sobre el maravilloso y rico estilo de vida de los terrícolas gracias a un sistema capitalista y a la explotación de petroleo y de productos derivados de este. La secuencia enfatiza la riqueza material y la libertad empresarial ofrecida bajo un sistema capitalista usando una variedad y vivacidad de color mucho mayor que en el extracto de Marte. Los productos comerciales y las personas se representan utilizando el espectro completo del proceso Technicolor, creando asociaciones positivas entre los resultados de la industria petrolera y el estilo de vida acomodado de quienes se benefician de él. Al igual que el extracto de Marte, a la audiencia se le ofrece una caricatura unilateral de un sistema político y una forma de vida, pero en esta sección la representación reduccionista es laudable y próspera en lugar de desoladora y opresiva.</p>
                        <p>Como una pieza de propaganda, <emph>Destination Earth</emph> se basa en estas distinciones poderosas pero demasiado simplistas entre dos sistemas políticos para influir en la opinión pública y promover el consumo de productos derivados del petróleo. La manera en que se usa (o no se usa) el color es una herramienta importante para elaborar y enfatizar este mensaje. Además, una vez que podemos extraer datos de color y visualizarlos utiliza técnicas gráficas simples, podemos ver que la disparidad en el rango dinámico proporciona una medida cuantitativa para vincular el uso técnico y estético del color en esta película animada con la retórica propagandística presentada por sus productores.</p>
                        <figure>
                            <desc>El petróleo y los ideales estadounidenses de riqueza y prosperidad se expresan en esplendor colorido</desc>
                            <graphic url="lovely_oil.png"/>
                        </figure>
                    </div>
                    <div type="4">
                        <head>Escalando el análisis de color con FFprobe</head>
                        <p>Uno de los límites de esta metodología es que estamos generando manualmente informes de color en un solo archivo a la vez. Si quisiéramos adoptar un enfoque de <ref target="https://distantviewing.org/">visión distante</ref> más en línea con las metodologías tradicionales de Humanidades Digitales, podríamos emplear un script de Bash para ejecutar nuestro comando <code rend="inline">ffprobe</code> en todos los archivos en un determinado directorio. Esto es útil si, por ejemplo, un(a) investigador(a) esta interesado en realizar un análisis similar en <ref target="https://archive.org/details/prelinger&amp;tab=collection?and%5B%5D=john+sutherland&amp;sin=">todas las películas animadas de John Sutherland encontradas en la colección de Archivos Prelinger</ref> u otro conjunto de material de vídeo de archivo.</p>
                        <p>Una vez que tengas un conjunto de material para trabajar guardado en un solo lugar, puedes guardar el siguiente <ref target="https://www.shellscript.sh/loops.html">bucle <emph>for</emph> de Bash o "for loop"</ref> dentro del directorio y ejecutarlo para generar archivos <code rend="inline">.csv</code> que contengan los mismos datos de tono medio a nivel de fotograma que extrajimos de nuestros extractos de <emph>Destination Earth</emph>.</p>
                        <ab>
                            <code lang="language-bash" xml:id="code_introduccion-a-ffmpeg_19" corresp="code_introduccion-a-ffmpeg_19.txt" rend="block"/>
                        </ab>
                        <list type="unordered">
                            <item>
                                <code rend="inline">for file in *.m4v; do</code> = inicia el bucle <emph>for</emph>. Esta primera línea le dice a FFmpeg "para todos los archivos en este directorio con la extensión <code rend="inline">.m4v</code>, ejecuta el siguiente comando."</item>
                            <item>El <code rend="inline">*</code> es un <ref target="http://tldp.org/LDP/GNU-Linux-Tools-Summary/html/x11655.htm">comodín de Bash</ref> adjunto a un tipo de archivo dado para especificarlos como archivos de entrada.</item>
                            <item>La palabra <code rend="inline">file</code> es una variable arbitraria que representará cada archivo a medida que se ejecuta a través del bucle.</item>
                            <item>
                                <code rend="inline">ffprobe -f lavfi -i movie="$file",signalstats -show_entries frame=pkt_pts_time:frame_tags=lavfi.signalstats.HUEMED -print_format csv &gt; "${file%.m4v}.csv"; done</code> = el mismo comando de extracción de metadatos de color que ejecutamos en nuestros dos extractos de <emph>Destination Earth</emph>, con algunas pequeñas modificaciones en la sintaxis para explicar su uso en varios archivos en un directorio:<list type="unordered">
                                    <item>
                                        <code rend="inline">"$file"</code> = recuerda cada variable. Las comillas aseguran que se conserva el nombre de archivo original.</item>
                                    <item>
                                        <code rend="inline">&gt; "${file%.m4v}.csv";</code> = conserva el nombre de archivo original al escribir los archivos de salida <code rend="inline">.csv</code>. Esto asegurará que los nombres de los archivos de vídeo originales coincidan con sus correspondientes reportes en <code rend="inline">.csv</code>.</item>
                                    <item>
                                        <code rend="inline">done</code> = termina el script una vez que se hayan completado todos los archivos del directorio.</item>
                                </list>
                            </item>
                        </list>
                        <p style="alert alert-warning">
También puedes usar <code rend="inline">signalstats</code> para obtener otra información valiosa relacionada con el color. Consulta la <ref target="https://www.ffmpeg.org/ffprobe-all.html#signalstats-1">documentación del filtro</ref> para obtener una lista completa de las métricas visuales disponibles.
</p>
                        <p>Una vez que ejecutas este script, verás que cada archivo de vídeo en el directorio ahora tiene un archivo <code rend="inline">.csv</code> correspondiente que contiene el conjunto de datos especificado.</p>
                    </div>
                </div>
            </div>
            <div type="2">
                <head>En resumen</head>
                <p>En este tutorial, hemos aprendido:</p>
                <list type="unordered">
                    <item>cómo instalar FFmpeg en diferentes sistemas operativos y cómo acceder al <emph>framework</emph> en el navegador web</item>
                    <item>cuál es la sintaxis básica y la estructura de los comandos FFmpeg</item>
                    <item>cómo visualizar metadatos técnicos básicos de un archivo audiovisual</item>
                    <item>cómo transformar un archivo audiovisual a través de la transcodificación y el "re-wrapping"</item>
                    <item>cómo analizar y editar ese archivo audiovisual separando sus componentes ("demux") y crear extractos</item>
                    <item>cómo reproducir archivos audiovisuales usando <code rend="inline">ffplay</code>
                    </item>
                    <item>cómo crear nuevos archivos de vídeo con vectorscopios integrados</item>
                    <item>cómo exportar datos tabulares relacionados con el color de una pista de vídeo usando <code rend="inline">ffprobe</code>
                    </item>
                    <item>cómo crear un bucle <emph>for</emph> de Bash para extraer información de datos de color de múltiples archivos de vídeo con un solo comando</item>
                </list>
                <p>A un nivel más amplio, este tutorial aspira a proporcionar una introducción informada y atractiva sobre cómo se pueden incorporar las herramientas y metodologías audiovisuales en los proyectos y las prácticas de Humanidades Digitales. Con herramientas abiertas y potentes como FFmpeg, existe un gran potencial para expandir el alcance del campo para incluir tipos de medios y análisis más ricos y complejos que nunca.</p>
            </div>
            <div type="2">
                <head>Más recursos</head>
                <p>FFmpeg tiene una comunidad grande y bien apoyada de usarios a través de todo el mundo. Como tal, hay muchos recursos gratuitos y de código abierto para descubir nuevos comandos y técnicas para trabajar con materiales audiovisuales. Por favor, contacta al autor con cualquier adición a esta lista, especialmente si se trata de recursos educativos en español para aprender FFmpeg.</p>
                <list type="unordered">
                    <item>
                        <ref target="https://www.ffmpeg.org/ffmpeg.html">La documentación oficial de FFmpeg</ref>
                    </item>
                    <item>
                        <ref target="https://trac.ffmpeg.org/wiki/WikiStart">FFmpeg Wiki</ref>
                    </item>
                    <item>
                        <ref target="https://amiaopensource.github.io/ffmprovisr/">ffmprovisr</ref> de <ref target="https://amianet.org/?lang=es">La Asociación de Archivistas de Imágenes en Movimiento</ref>
                    </item>
                    <item>
                        <ref target="https://training.ashleyblewer.com/">Entrenamiento de preservación audiovisual de Ashley Blewer</ref>
                    </item>
                    <item>
                        <ref target="https://github.com/privatezero/NDSR/blob/master/Demystifying_FFmpeg_Slides.pdf">La presentación de Andrew Weaver: "Demystifying FFmpeg"</ref>
                    </item>
                    <item>
                        <ref target="https://docs.google.com/presentation/d/1NuusF948E6-gNTN04Lj0YHcVV9-30PTvkh_7mqyPPv4/present?ueb=true&amp;slide=id.g2974defaca_0_231">FFmpeg: Presentación de Ben Turkus</ref>
                    </item>
                    <item>
                        <ref target="https://avpres.net/FFmpeg/">FFmpeg Cookbook for Archivists de Reto Kromer</ref>
                    </item>
                </list>
                <div type="3">
                    <head>Programas de código abierto de análisis audiovisual que usan FFmpeg</head>
                    <list type="unordered">
                        <item>
                            <ref target="https://mediaarea.net/en/MediaInfo">MediaInfo</ref>
                        </item>
                        <item>
                            <ref target="https://bavc.org/preserve-media/preservation-tools">QC Tools</ref>
                        </item>
                    </list>
                </div>
            </div>
            <div type="2">
                <head>Referencias</head>
                <list type="unordered">
                    <item>
                        <p>Champion, E. (2017) “Digital Humanities is text heavy, visualization light, and simulation poor,” Digital Scholarship in the Humanities 32(S1), i25-i32</p>
                    </item>
                    <item>
                        <p>Hockey, S. (2004) “The History of Humanities Computing,” A Companion to Digital Humanities, ed. Susan Schreibman, Ray Siemens, John Unsworth. Oxford: Blackwell</p>
                    </item>
                </list>
                <p>Este tutorial fue posible gracias al apoyo de la Academia Británica y fue escrito durante el Taller de <emph>Programming Historian</emph>  desarrollado en la Universidad de Los Andes en Bogotá, Colombia, entre el 31 de julio y 3 de agosto de 2018.</p>
            </div>
        </body>
    </text>
</TEI>
