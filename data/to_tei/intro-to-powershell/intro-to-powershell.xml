<TEI xmlns="https://tei-c.org/ns/1-0/">
  <metadata>
  <title>Introduction to the Windows Command Line with PowerShell</title>
  <layout>lesson</layout>
  <date>2016-07-21</date>
  <authors>Ted Dawson</authors>
  <reviewers>Erin N. Bush,Derek Price</reviewers>
  <editors>Jeri Wieringa</editors>
  <difficulty>1</difficulty>
  <activity>transforming</activity>
  <topics>data-manipulation,get-ready</topics>
  <abstract>This tutorial will introduce you to the basics of Windows PowerShell, the standard command-line interface for Windows computers.</abstract>
  <review-ticket>https://github.com/programminghistorian/ph-submissions/issues/18</review-ticket>
  <redirect_from>/lessons/intro-to-powershell</redirect_from>
  <avatar_alt>An ornate seashell</avatar_alt>
  <doi>10.46430/phen0054</doi>
</metadata>
  <text>
    <body>
      <div n="1"><head>Introduction</head>
<p>This tutorial will introduce you to the basics of Windows PowerShell, the standard command-line interface for Windows computers. If you are a Mac or Linux user, you should check out the <link target="/lessons/intro-to-bash">Bash introduction</link> instead. If you are already familiar with using Bash, you may be able to get started with PowerShell just by looking at the <link target="#quick-reference">table at the end of this lesson</link>.</p>
<p>The tutorial is divided into two main sections. In the first section, "<link target="#getting-started">Getting Started</link>," you will learn to do basic desktop tasks like creating and opening files and folders using PowerShell. In the second section, "<link target="#doing-more">Doing More</link>," you will get a glimpse of some of the features that make work on the command line particularly efficient, and learn enough of the basics to be able to explore further on your own. You will also <link target="#using-command-line-tools-and-running-python-scripts">get set up to run Python scripts from the command line</link>.</p>
<p>This tutorial was written for PowerShell 5.0. If you are using an earlier version, you may encounter a few small syntax differences which you should be able to overcome with a little help from a search engine.</p>
</div>
      <div n="1"><head>What is PowerShell and Why is it Useful?</head>
<p>Windows PowerShell is a <hi rend="bold">command-line interface</hi> for Windows computers. A command-line interface (CLI) is a program for telling your computer to do tasks using typed commands, rather than by clicking pictures on the desktop as in a <hi rend="bold">graphical user interface</hi> (GUI). (Technically, PowerShell is more than just the CLI, and you can get a quick overview of its features on <link target="https://en.wikipedia.org/wiki/Windows_PowerShell">Wikipedia</link>.) Using the command line has many advantages. It makes it possible to automate tasks and to do many things with one command. Most importantly, a number of tools of value to humanists can only be run from the command line, including many you can learn about on <emph>The Programming Historian</emph>, like <link target="/lessons/topic-modeling-and-mallet">Mallet</link>, <link target="/lessons/sustainable-authorship-in-plain-text-using-pandoc-and-markdown">Pandoc</link>, or <link target="/lessons/automated-downloading-with-wget">Wget</link>. The command line is also the best place to work with programs you have custom built for your own research using programming languages like Python.</p>
</div>
      <div n="1"><head>Getting Started</head>
<p>You will first learn to navigate through your files and do some of the basic tasks you do every day on the computer.</p>
<div n="2"><head>Open PowerShell</head>
<p>Run a search for PowerShell on your computer. You probably have several different options, like "PowerShell," "PowerShell ISE," and "PowerShell (x86)." The ISE (integrated scripting environment) is a handy tool which allows you to write scripts on the fly, and also has a convenient look-up for all the PowerShell commands. Right now, this is more than we need. "x86" exists for backwards compatibility. (If you've been around a while, you'll remember old Intel processors from the 80s and early 90s called "286," "386," "486," and so forth. That's what "x86" is getting at. It is a 32-bit version.) We want 64-bit and simple, so we'll use the one just called "Windows PowerShell." You may want to pin it to your task-bar (right click it to get this option). When you open it, it will look like this:</p>
<figure><desc>PowerShell on start up</desc><graphic url="intro-to-powershell1.png"/></figure>
<p>If you don't like the white on blue, right click the top bar, select "properties," and go to "colors" to change things. You may have to close and re-open PowerShell to get it to display correctly.</p>
</div><div n="2"><head>Navigation</head>
<p>A nice thing about PowerShell is you always know where you are because it tells you in the prompt. In my case, I see:</p>
<p><code type="inline">C:\Users\Ted&gt;</code></p>
<p>You should see something similar, but with your user name. In case you don't, type</p>
<p><code type="inline">sl ~</code></p>
<p>Make sure to include the space. This will bring you to your home directory: <code type="inline">C:\Users\YOURUSERNAME</code> where "YOURUSERNAME" is replaced with the name of your account on the machine. "Directory" is just another word for "folder," and PowerShell considers your user folder - not the desktop - to be your home. (The desktop is actually just another folder within your user folder, that is, a subdirectory of the user directory). Entering <code type="inline">sl ~</code> is just like opening the folder called "Users" and from there "YOURUSERNAME" using your GUI. Let's start by learning how to move around between directories and view their contents.</p>
<div n="3"><head>Viewing Directory Contents with <code type="inline">Get-ChildItem</code> (<code type="inline">gci</code>, <code type="inline">ls</code>)</head>
<p>Our first command is <code type="inline">Get-ChildItem</code>. Go ahead and type it in, and hit enter. You'll see a list of everything in your current directory. In my case, that looks like this:</p>
<figure><desc>Listing directory contents with `Get-ChildItem`</desc><graphic url="intro-to-powershell2.png"/></figure>
<p>Notice that I didn't actually enter <code type="inline">Get-ChildItem</code>. I just entered <code type="inline">gci</code>. The commands we will be learning are all of the form <code type="inline">Verb-Noun</code>. These are called "cmdlets" (pronounced "commandlets"), and their form is supposed to make it easy to remember what they do and predict similar cmdlets. Because cmdlets are rather long, most of them come with sleeker aliases that you can use instead. I will first present cmdlets with their names, but always subsequently use the standard aliases, because they are much faster to work with. It is important to note that many cmdlets have multiple aliases. For instance, <code type="inline">Get-ChildItem</code>, <code type="inline">gci</code>, <code type="inline">dir</code>, and <code type="inline">ls</code> all do exactly the same thing. While it is unsurprising that <code type="inline">gci</code> is short for <code type="inline">Get-ChildItem</code>, you may be wondering where <code type="inline">dir</code> and <code type="inline">ls</code> come from.</p>
<p>PowerShell is relatively new (first released in 2006), and its designers anticipated that many people who would use it would already have experience with some existing CLIs (command-line interfaces), specifically either with Microsoft's older CLI called command prompt, or with Linux CLIs like Bash, which is now also standard on OS X. Thus, many cmdlets have an alias that is the standard command in one of these two systems (and often for both). In the present example, <code type="inline">dir</code> comes from command prompt, and <code type="inline">ls</code> comes from Bash. I will use the "PowerShell-style" aliases in this tutorial, since it makes it easier to remember the actual cmdlet names. However, I will try to also mention other common aliases, particulary those familiar to Bash users. If you work with a lot of people who use OS X or Linux, it can be good to know these names. The <link target="#quick-reference">table at bottom</link> gives the cmdlets along with their standard PowerShell aliases and the nearest Bash equivalent.</p>
<p>Go ahead and try using <code type="inline">gci</code>, <code type="inline">dir</code>, and <code type="inline">ls</code>. You'll get the exact same list of things. Most of these things will be directories. One of them should be your desktop. Let's move into that directory.</p>
</div><div n="3"><head>Moving Between Directories with <code type="inline">Set-Location</code> (<code type="inline">sl</code>, <code type="inline">cd</code>)</head>
<p>To move to your desktop, we'll use the <code type="inline">Set-Location</code> cmdlet. Enter</p>
<p><code type="inline">sl desktop</code></p>
<p>into PowerShell. This tells PowerShell to move to the desktop. Notice that you can write "desktop" using all lowercase letters, even though when you looked at the contents of the <code type="inline">YOURUSERNAME</code> directory, "Desktop" was spelled with a capital "D". PowerShell is not case sensitive! Now that you've changed your location, you can use <code type="inline">gci</code> to see a list of everything on your desktop - that is, everything in the directory named <code type="inline">Desktop</code>. If you're as disorganized as I am, this will be a long list. We can move back to the <code type="inline">YOURUSERNAME</code> directory by typing</p>
<p><code type="inline">sl ..</code></p>
<p>Don't leave out the space! Now type</p>
<p><code type="inline">sl ..</code></p>
<p>again. You should be in the <code type="inline">Users</code> directory.</p>
<p>Now try navigating back to the desktop, and then back again to <code type="inline">Users</code>. That should take four commands: <code type="inline">sl YOURUSERNAME</code>, <code type="inline">sl desktop</code>, <code type="inline">sl ..</code>, <code type="inline">sl ..</code>. But you can actually do it with only two. You should be at <code type="inline">C:\Users&gt;</code> right now. Instead of typing <code type="inline">sl YOURUSERNAME</code> and then <code type="inline">sl desktop</code>, you can just type</p>
<p><code type="inline">sl YOURUSERNAME\desktop</code></p>
<p>and get to the desktop with one command! Similarly, from the desktop, by typing</p>
<p><code type="inline">sl ..\..</code></p>
<p>you can get back to where you started with one command. If you don't have the pinkie stamina for typing <code type="inline">\</code> all the time, you can also type <code type="inline">sl ../..</code>. Not only is PowerShell not case sensitive, it also doesn't care what direction the slash goes. <code type="inline">sl ../..</code>, <code type="inline">SL ..\..</code>, <code type="inline">Set-Location ..\..</code>, and <code type="inline">set-location ../..</code> all do exactly the same thing.</p>
</div><div n="3"><head>Creating New Directories with <code type="inline">mkdir</code></head>
<p>We're moving toward working with files. Before we start, let's make a directory where we can store everything we're using for this lesson. Navigate back home by typing</p>
<p><code type="inline">sl ~</code></p>
<p>We'll make a new directory inside of your <code type="inline">YOURUSERNAME</code> directory. To do this, we use the command <code type="inline">mkdir</code>. Call your directory whatever you want, but try not to use spaces, as these make working on the command line more complicated than necessary. I will call my directory "funWithPowerShell". So I type</p>
<p><code type="inline">mkdir funWithPowerShell</code></p>
<p>See how I used <link target="https://en.wikipedia.org/wiki/CamelCase">CamelCase</link> to avoid spaces? Another common way to do this is with hyphens or underscores, as in <code type="inline">fun_with_power_shell</code>. Whatever you name your directory, try to avoid using spaces. Once you've been working with PowerShell a little, you'll probably find that you start titling new files without spaces by default. This is a good habit to be in, as it simplifies work on the command line as well as work with programming languages like Python.</p>
<p>However, you probably have plenty of existing files with spaces in their names. To open these in PowerShell, you just need to use quotes. Let's try this. Move into your new directory using</p>
<p><code type="inline">sl funWithPowerShell</code></p>
<p>(Or whatever you titled your directory.) Enter</p>
<p><code type="inline">gci</code></p>
<p>and you'll see that there's nothing here. That's because you haven't put anything in it! Let's put a new directory inside with <code type="inline">mkdir</code>. We'll call this directory "Directory with a long name and lots of spaces". Because the name has spaces in it, we'll have to use quotes to create it. Type</p>
<p><code type="inline">mkdir "Directory with a long name and lots of spaces"</code></p>
<p>and hit enter. Now enter</p>
<p><code type="inline">gci</code></p>
<p>and you'll see your new directory. Suppose we want to move into this directory. We would have to type <code type="inline">sl "Directory with a long name and lots of spaces"</code>. Not only will this take a while to type, but if we get one letter wrong, PowerShell won't be able to find our directory. Instead, try just typing</p>
<p><code type="inline">sl d</code> and then hitting the <code type="inline">tab</code> key.</p>
<p>Voila! PowerShell completes the name of the directory for us, including the quotes! Using <code type="inline">tab</code> for auto-completion will save you a lot of time. You'll notice that when PowerShell completed the name for us, it also threw in a <code type="inline">.\</code> at the beginning of the directory name. The dot is just shorthand for the current directory. When you type commands, PowerShell always assumes there's a <code type="inline">.\</code> at the beginning - in other words, that you are referring to something in the current directory. So you don't have to type this part (unless you want PowerShell to look somewhere else for whatever you're telling it to do, in which case you can type the path for that directory - i.e. <code type="inline">C:\directory\bla\etc</code>.)</p>
<p>Let's practice a little more with directories before getting to files.</p>
</div><div n="3"><head>Using <code type="inline">Explorer</code> to View Directories in the GUI</head>
<p>At this point, we've made two directories. I mentioned above that "directory" is just another word for "folder." You can see this for yourself by finding your new directories in the GUI. Windows actually calls your GUI "File Explorer" or just "Explorer." We can call Explorer from within PowerShell by using the command <code type="inline">Explorer</code>. Navigate back into your funWithPowerShell folder with</p>
<p><code type="inline">sl ..</code></p>
<p>Now try typing</p>
<p><code type="inline">explorer .</code></p>
<p>Remember, the dot just means "this directory," and you don't have to capitalize "explorer" because case doesn't matter in PowerShell. Explorer should have just opened a window showing the contents of the "funWithPowerShell" directory. Arrange your windows so you can see both the image in Explorer and PowerShell. Now you'll be able to watch how what you do in PowerShell shows up in Explorer.</p>
<p>The <code type="inline">Explorer</code> command is extremely useful. It is essentially like double-clicking something in the GUI. Thus, you can also use it to open files and programs.</p>
</div><div n="3"><head>Deletion with <code type="inline">Remove-Item</code> (<code type="inline">rm</code>)</head>
<p>Now that you can see the results of what you're doing in PowerShell, let's learn to delete things - for instance that directory with the long name. First, create a few more directories. Name them "dir," "dir1," and "dir2." You can make all three with a single command by typing</p>
<p><code type="inline">mkdir dir, dir1, dir2</code></p>
<p>Pretty neat, huh? You should see your three new directories pop up in your open Explorer window.</p>
<p>Now, let's get rid of that long-named directory. To do this, we use the cmdlet <code type="inline">Remove-Item</code> or just <code type="inline">rm</code>. You have to be <hi rend="bold">very careful</hi> with this cmdlet, because it does not put things in your recycle bin. It <hi rend="bold">deletes them permanently</hi>. Gone. Type in <code type="inline">rm</code> followed by a space and the long-named directory's name. You'll probably want to use <code type="inline">tab</code> for auto-completion. Note, however, that now that we have a bunch of directories with names beginning with "d", so we have to type through the first unique letter to get it to auto-complete correctly. So I type</p>
<p><code type="inline">rm dire</code> and then hit <code type="inline">tab</code>.</p>
<p>Alternatively, you can just type <code type="inline">rm</code> and then hit <code type="inline">tab</code> multiple times to scroll through all your directories. If you go too far, use <code type="inline">shift</code> with <code type="inline">tab</code> to scroll back.</p>
<p>Before pressing <code type="inline">enter</code>, I stare long and hard to make sure I'm deleting the thing I want to delete. Then I hit <code type="inline">enter</code>.</p>
<p>Go ahead and delete the other three directories, and watch them disappear from Explorer. Just like with <code type="inline">mkdir</code>, you can delete all three directories with one command. Give it a try.</p>
<p>We just deleted the <code type="inline">dir</code>, <code type="inline">dir1</code>, and <code type="inline">dir2</code> directories. But we'll need them for the next example. So let's create them again. Rather than typing out the instruction, though, try just tapping the up arrow on your keyboard a couple of times. You should soon see the command you used to make the three directories the first time. Once you do, hit enter, and they'll be made again! Like using <code type="inline">tab</code> to auto-complete, using the up and down arrows to scroll through recent commands will save you a lot of time! <hi rend="bold">Note that we are not undoing our earlier deletion.</hi> We are just using a shortcut to enter again a command we've recently used.</p>
</div><div n="3"><head>Understanding the Tree Structure of Your Computer's File System</head>
<p>Okay, now you should have three directories inside your <code type="inline">funWithPowerShell</code> directory. Move into the <code type="inline">dir</code> directory. (Use <code type="inline">sl dir</code>).</p>
<p>It's important to understand how your computer organizes things. Look at the path to your current directory. The path is all the stuff written before the <code type="inline">&gt;</code>. In my case, that's</p>
<p><code type="inline">C:\Users\Ted\funWithPowerShell\dir</code></p>
<p>Yours should look pretty similar. What this path actually represents is a tree-like structure the computer follows to get to where you are. The trunk of the tree is <code type="inline">C:</code> which is your hard drive. (Actually, on most modern computers, it will be a partition of your hard drive. Why is it called <code type="inline">C</code>? Your computer assigns a letter to every drive. <code type="inline">A</code> and <code type="inline">B</code> are reserved for the two floppy disk drives which long ago users would have interacted with more frequently than their hard drives. Even though most computers no longer have them, their names are still reserved.)</p>
<p>If <code type="inline">C:</code> is the trunk, each section of the path after it is a branch, each one coming off the one above it. Thus, <code type="inline">Users</code> is a branch from <code type="inline">C:</code>, <code type="inline">Ted</code> is a smaller branch coming off of <code type="inline">Users</code> and so forth. You could also use a metaphor of heredity rather than botany and call each branch a <code type="inline">child</code> of the directory above it. This is actually the more common language for describing the relationships between directories (hence the cmdlet <code type="inline">Get-ChildItem</code>), but we'll stick with the tree metaphor, since in real life, relationships of heredity can be much more complex than the extremely hierarchical structure according to which your computer is organized.</p>
<p>Understanding that the path works like a tree is important for navigating around to directories not immediately above or below the current one. Thus, we know there is a directory called "dir1", and that this directory is also in the "funWithPowerShell" directory. See what happens if you attempt to use <code type="inline">sl</code> to move directly over into it by typing</p>
<p><code type="inline">sl dir1</code></p>
<p>This threw an error!</p>
<figure><desc>An error caused by jumping between branches</desc><graphic url="intro-to-powershell3.png"/></figure>
<p>We've tried to jump from one branch to another, and PowerShell can only understand our movement if we move along the tree. That means we first have to move up to where the branches for "dir1" and "dir" meet, and then back down to "dir1." You can do this with one command. See if you can figure it out before you read the next line.</p>
<p>The command is:</p>
<p><code type="inline">sl ..\dir1</code></p>
<p>This tells PowerShell to move up one directory to <code type="inline">funWithPowerShell</code> and then move back down into the directory <code type="inline">dir1</code>.</p>
</div><div n="3"><head>Moving fast with <code type="inline">Push-Location</code> (<code type="inline">pushd</code>) and <code type="inline">Pop-Location</code> (<code type="inline">popd</code>)</head>
<p>Before moving on to working with files, let's try out the commands <code type="inline">pushd</code> and <code type="inline">popd</code>. Do this: Go all the way up to the trunk of your tree, <code type="inline">C:</code>. That should be four directories above where you are, so you could type</p>
<p><code type="inline">sl ..\..\..\..</code></p>
<p>Then, change back to <code type="inline">dir1</code>. But rather than typing <code type="inline">sl</code> before the path, type <code type="inline">pushd</code>. Like this:</p>
<p><code type="inline">pushd users\YOURUSERNAME\funWithPowerShell\dir1</code></p>
<p>You'll now be in the directory, just as if you'd typed <code type="inline">sl</code> at the beginning of that path. But here's the fun part. Now type</p>
<p><code type="inline">popd</code></p>
<p>and hit enter. Neat, right? The command <code type="inline">pushd</code> tells powershell to move into the given directory after marking the current directory so it can be returned to with <code type="inline">popd</code>. In other words, <code type="inline">popd</code> will always "pop" you back to the last directory you were in before using <code type="inline">pushd</code>. (If you want to understand more about what is going on, read about the <link target="https://en.wikipedia.org/wiki/Call_stack">call stack</link> on Wikipedia.) Using <code type="inline">pushd</code> and <code type="inline">popd</code> is very useful when you're frequently moving between two directories.</p>
</div></div><div n="2"><head>Working With Files</head>
<p>Now that you know how to move around your computer's file system from the command line, let's work on actually doing things to files. We'll start by learning to <hi rend="bold">create</hi> new files, <hi rend="bold">copy</hi> them, and <hi rend="bold">move</hi> them around.</p>
<div n="3"><head>Creating Files with <code type="inline">New-Item</code> (<code type="inline">ni</code>)</head>
<p>First, we need some files to work with. Let's make a new plain text document called "example.txt". Navigate to the <code type="inline">funWithPowerShell</code> directory - use tab for each directory name as you type out the path to speed this up - and type</p>
<p><code type="inline">ni example.txt</code></p>
<p>then hit enter. Now do</p>
<p><code type="inline">gci</code></p>
<p>to see that, indeed, you now have, in addition to your directories, the file <code type="inline">example.txt</code>. We'll need several files, so go ahead and make <code type="inline">example1.txt</code> and <code type="inline">example2.txt</code>. You'll be unsurprised to hear that with a comma, you can do this in one command:</p>
<p><code type="inline">ni example1.txt, example2.txt</code></p>
</div><div n="3"><head>Copying and Moving Files with <code type="inline">Copy-Item</code> (<code type="inline">cp</code>) and <code type="inline">Move-Item</code> (<code type="inline">mv</code>)</head>
<p>We probably should have put these files into one of our directories. Let's move them.</p>
<p>We'll put <code type="inline">example.txt</code> in <code type="inline">dir</code> by typing</p>
<p><code type="inline">mv example.txt dir</code></p>
<p>Now type <code type="inline">gci</code> and you'll see <code type="inline">example.txt</code> has disappeared. Move into <code type="inline">dir</code> (<code type="inline">sl dir</code>) and type <code type="inline">gci</code> and you'll see it's now in there! (You can also do this without moving by just typing <code type="inline">gci dir</code> from <code type="inline">funWithPowerShell</code>.) Move back to <code type="inline">funWithPowerShell</code> and put <code type="inline">example1.txt</code> in <code type="inline">dir1</code> and <code type="inline">example2.txt</code> in <code type="inline">dir2</code>.</p>
<p>We can also use <code type="inline">mv</code> to <hi rend="bold">rename</hi> things. Use <code type="inline">sl</code> to move into <code type="inline">dir</code>. Do a quick <code type="inline">gci</code> and you should see your <code type="inline">example.txt</code> file. This is a boring name. Let's call it "benjamin.txt" instead. Type</p>
<p><code type="inline">mv example.txt benjamin.txt</code></p>
<p>Use <code type="inline">gci</code> again to confirm that your document is now called <code type="inline">benjamin.txt</code>.</p>
<p>You may be surprised that the same cmdlet is used both to move and to rename files. In fact, though, the operation is the same. In both cases, you're telling the computer to change the "name" of the file's location, that is, to change the <hi rend="bold">path</hi> it follows to find the file. In the first example above, the path began as</p>
<p><code type="inline">C:\Users\Ted\funWithPowerShell\example.txt</code></p>
<p>and changed to</p>
<p><code type="inline">C:\Users\Ted\funWithPowerShell\dir\example.txt</code></p>
<p>In the second example, the path changed from</p>
<p><code type="inline">C:\Users\Ted\funWithPowerShell\dir\example.txt</code></p>
<p>to</p>
<p><code type="inline">C:\Users\Ted\funWithPowerShell\dir\benjamin.txt</code></p>
<p>In other words, in both examples, <code type="inline">mv</code> just changed the path. Don't worry if this doesn't make sense just yet. Just be careful when you use <code type="inline">mv</code>, because if you don't type exactly the right thing, you may rename something when you mean to move it, or vice versa.</p>
<p>Beyond moving files, we also want to be able to copy and delete them. To copy files, we use the cmdlet <code type="inline">Copy-Item</code>, or <code type="inline">cp</code>. Let's make a two copies of <code type="inline">benjamin.txt</code>, and name them "steven.txt" and "susie.txt".</p>
<p><code type="inline">cp benjamin.txt steven.txt</code></p>
<p><code type="inline">cp benjamin.txt susie.txt</code></p>
<p>We can also delete these two new files with <code type="inline">rm</code>, just like with directories. Try to do it with one command. As always, be careful when you use <code type="inline">rm</code>.</p>
<p>Here's the command:</p>
<p><code type="inline">rm steven.txt, susie.txt</code></p>
<p>Goodbye, Steven and Susie!</p>
<figure><desc>Moving, copying, and deleting</desc><graphic url="intro-to-powershell4.png"/></figure>
</div></div></div>
      <div n="1"><head>Doing More</head>
<p>Okay, so now we can navigate around, make files, and move and delete them in PowerShell. We feel pretty cool and/or geeky, because we can do these things from the command line, but it's not actually useful, since we could already do these things pretty easily in the GUI. Now that we know these basics, though, we can start learning slightly more complex commands that can be useful in our work as digital humanists.</p>
<h3>Writing to Files with <code type="inline">Write-Output</code> (<code type="inline">write</code>, <code type="inline">echo</code>) and Redirection</h3>
<p>We have an empty file in our <code type="inline">dir</code> directory. That's not very interesting. Let's add some content. We could open the file in Notepad and modify it that way. But we can also add to it with commands right from the command line. The cmdlet we use for this is <code type="inline">Write-Output</code>, or just <code type="inline">write</code>.</p>
<p>Try entering this:</p>
<p><code type="inline">write "The technique of reproduction detaches the reproduced object from the domain of tradition."</code></p>
<p>PowerShell should print that statement directly into the command-line window. That's all that <code type="inline">write</code> does. It tells PowerShell "Print out whatever I write." That's not very useful, though, because we want it to put this text into our document. To do this, we'll use something called <hi rend="bold">redirection</hi>.</p>
<p>Redirection is just a way to tell PowerShell to take the results of a command and put them somewhere other than in the PowerShell window. To redirect a command, we put a right angle bracket (<code type="inline">&gt;</code>) between the command and the place we want its output to go. In this case, we want the output of our <code type="inline">write</code> command to wind up in <code type="inline">benjamin.txt</code>. So we use the up arrow to get the statement back, and add <code type="inline">&gt; benjamin.txt</code> at the end. The whole thing should look like this:</p>
<p><code type="inline">write "The technique of reproduction detaches the reproduced object from the domain of tradition." &gt; benjamin.txt</code></p>
<p>When you hit enter, nothing will seem to have happened. That's because your <code type="inline">write</code> statement was redirected. To see that something did indeed happen, use <code type="inline">gci</code> to view the contents of your directory. Notice that the length of <code type="inline">benjamin.txt</code> is no longer 0. That's because we just put some text in there!</p>
<h3>Reading Files with <code type="inline">Get-Content</code> (<code type="inline">gc</code>, <code type="inline">cat</code>)</h3>
<p>While <code type="inline">gci</code> can show us that <emph>something</emph> is in the file, it would be nice to see that it's the sentence we tried to put in there. We could do this by typing <code type="inline">notepad benjamin.txt</code>, which would open the document in Notepad. But there is also a cmdlet for just printing the contents to PowerShell. This cmdlet is called <code type="inline">Get-Content</code>. Enter:</p>
<p><code type="inline">gc benjamin.txt</code></p>
<p>There's your sentence!</p>
<p>Using <code type="inline">gc</code> by itself is helpful, but not that interesting. By combining it with redirection, we can do a lot more. For starters, we can put the contents of one file into another. This is a lot like copying a file. You already know how to do this with <code type="inline">cp</code>. Make a copy of <code type="inline">benjamin.txt</code> named <code type="inline">benjamin1.txt</code> using <code type="inline">cp</code>. That command will look like this:</p>
<p><code type="inline">cp benjamin.txt benjamin1.txt</code></p>
<p>Now, try to make <code type="inline">benjamin2.txt</code>, with the exact same contents as <code type="inline">benjamin.txt</code> but by using <code type="inline">gc</code> and redirection. See if you can figure out how to do this.</p>
<p>In case you're stumped, here's the answer:</p>
<p><code type="inline">gc benjamin.txt &gt; benjamin2.txt</code></p>
<p>Of course, that's just a more cumbersome way to do what we can already do with <code type="inline">cp</code>. The difference in these methods is substantial, though, because using <code type="inline">gc</code> we can append information to a text without replacing what is already there, and we can also get the contents of multiple texts and put them into another text.</p>
<p>First, let's look at appending. We need something to append, so let's make a new text called <code type="inline">next.txt</code> and write to it the sentence "By making many reproductions it substitutes a plurality of copies for a unique existence." We could make our file first with <code type="inline">ni</code>, but we don't need to. If we tell PowerShell to write to a file that isn't there, it will make the file for us. Thus we can just enter</p>
<p><code type="inline">write "By making many reproductions it substitutes a plurality of copies for a unique existence." &gt; next.txt</code></p>
<p>Use <code type="inline">gc</code> to check that <code type="inline">next.txt</code> really is what we want it to be.</p>
<p>Now, let's add the content of <code type="inline">next.txt</code> to <code type="inline">benjamin.txt</code> using <code type="inline">gc</code> and redirection. Seems simple enough, right? Try entering</p>
<p><code type="inline">gc next.txt &gt; benjamin.txt</code></p>
<p>Then, check what happened with <code type="inline">gc benjamin.txt</code>. You will see that you have indeed put the content of <code type="inline">next.txt</code> into <code type="inline">benjamin.txt</code>, but that you've <emph>replaced</emph> the content that was already there. This isn't what we wanted to do!</p>
<p>Using <code type="inline">&gt;</code>, we just told PowerShell to put the content of one text into another, and it overwrote what was already there. We can fix this by using <code type="inline">&gt;&gt;</code> for our redirection instead of just a single <code type="inline">&gt;</code>. This tells PowerShell to append the new information. Try this:</p>
<p><code type="inline">gc next.txt &gt;&gt; benjamin1.txt</code></p>
<p>Use <code type="inline">gc</code> to see that <code type="inline">benjamin1.txt</code> now has both sentences.</p>
<figure><desc>The difference between `&gt;` and `&gt;&gt;`</desc><graphic url="intro-to-powershell5.png"/></figure>
<p>Now, let's see about getting the contents of multiple files at the same time.</p>
<h3>Working with Lots of Files at Once Using Wildcards (<code type="inline">*</code>)</h3>
<p>You should now have four files in your directory, each with one or two sentences from Walter Benjamin's artwork essay in it. You might be losing track of what exactly is in them. Let's use <code type="inline">gc</code> to check the contents.</p>
<p>We could look at each one individually. As you may have guessed, though, you can display all four with one command. Enter</p>
<p><code type="inline">gc benjamin.txt, benjamin1.txt, benjamin2.txt, next.txt</code></p>
<p>and you'll get your sentence printed out three times. We can do this even more quickly. Try entering</p>
<p><code type="inline">gc *.txt</code></p>
<p>The result will be exactly the same thing. What the <code type="inline">*.txt</code> does is tell PowerShell to find anything ending with <code type="inline">.txt</code>. The <code type="inline">*</code> is called a <hi rend="bold">wildcard</hi>, and can be used to replace any part of a file name. Try typing <code type="inline">gc ben*</code>, and you'll get only the texts that begin with "ben". Since the only files in this directory are the four we want, you can even type <code type="inline">gc *</code> and get the content we're interested in by having PowerShell get the content of <emph>everything</emph> in the directory.</p>
<h3>Searching with <code type="inline">Select-String</code> (<code type="inline">sls</code>)</h3>
<p>Of course, we don't always want to see everything. Often, we want to find specific content. Using <code type="inline">*</code>, we can search multiple files at the same time. One of our sentences had something about "unique existence," didn't it? Where was that? We can use the <code type="inline">Select-String</code> cmdlet to search for specific bits of text. Enter</p>
<p><code type="inline">sls "unique existence" *.txt</code></p>
<p>and PowerShell will spit out all the lines containing that string from any file in our directory ending in <code type="inline">.txt</code>.</p>
<p>Using <code type="inline">sls</code> on files as small as ours won't save us all that much time over reading the files ourselves. But using this cmdlet with larger numbers of longer files can be extraordinarily helpful.</p>
<h3>Infinite Loops and Aborting with <code type="inline">control-c</code></h3>
<p>Let's look at one more useful task we can accomplish by combining <code type="inline">gc</code>, wildcards, and redirection. Suppose we have numerous different files we want to combine together into another file, for instance because we've downloaded hundreds of song lyrics we want to analyze, and want to group all the ones by a certain artist into a single file. Although we could do this by listing them all out, i.e. <code type="inline">gc text1, text2, text3 &gt; newtext</code>, if we have a hundred texts, this will be pretty cumbersome. This is what wildcards are for.</p>
<p>Let's try concatenating all four of our texts and putting the result into a fifth text. Using <code type="inline">*.txt</code> might seem a handy helper. <hi rend="bold">We are about to do something foolish, so please read the next paragraph before typing this command!</hi></p>
<p>Let's try</p>
<p><code type="inline">gc *.txt &gt; bigben.txt</code></p>
<p>Your computer will appear to do nothing. But unlike other times when your computer has apparently done nothing, this time, the command prompt doesn't come back up. If you try to type another command, nothing will happen. This is because PowerShell is still working on your last command. As you do more and more complicated things with PowerShell, this will sometimes happen - you're making your computer sweat! In this case, however, PowerShell will never stop working on this command, because it is in an infinite loop! Fortunately, you can abort this task with</p>
<p><code type="inline">control-c</code></p>
<p>Using <code type="inline">control-c</code> like this is very handy, as you may sometimes accidentally get caught in a loop, or you may just get sick of waiting for your computer to do certain extremely long tasks.</p>
<p>How did we just get stuck in that loop? We told PowerShell to put all files ending in <code type="inline">.txt</code> into a new file ending in <code type="inline">.txt</code>. Since that new file fell under the rubric of files the computer should be concatenating and adding to <code type="inline">bigben.txt</code>, it added that one in there, too. And then, since it had a <code type="inline">.txt</code> file with new content, it added <emph>that</emph> as well. This is a great example of something we often forget about our computers: they are not smart. Extremely powerful, yes. But totally lacking common sense. Humans look at instructions and try to <emph>interpret</emph> them. "She can't possibly mean for me to add the contents of the final text back into itself over and over again forever." Computers, on the other hand, do exactly what we tell them to, no matter how illogical our commands may be. As you gain experience working on the command line, you will often be flummoxed by your computer's overly literal interpretations of your commands, but you will also learn how to give it instructions it can follow. Infinite loops should be avoided at all costs, but they will occur, and when they do, just remember <code type="inline">control-c</code>.</p>
<h3>Specifying cmdlets with Parameters</h3>
<p>We have seen that your computer needs to have things told to it in very exact ways. Fortunately, PowerShell provides methods for refining cmdlets by adding parameters.</p>
<p>Let's look at an example. Use <code type="inline">gci</code> and you should see that you have five files in your directory. One of them, <code type="inline">bigben.txt</code>, is very large. Enter</p>
<p><code type="inline">gc bigben.txt</code></p>
<p>PowerShell will start dumping an inordinate amount of text onto the screen. You may want to abort the process with <code type="inline">control-c</code> (this is not an infinite loop, just a really large file, so you can wait for the whole thing to print, it'll just take a while.) You can use the cmdlet <code type="inline">clear</code> if the large block of text bothers you.</p>
<p>What we really want to see is just that <code type="inline">bigben.txt</code> really is comprised of the lines of the other texts, repeated over and over again. We can do this by looking only at the beginning and ending, and for this, we add a <hi rend="bold">parameter</hi> to our cmdlet.</p>
<p>Enter this:</p>
<p><code type="inline">gc bigben.txt -totalcount 10</code></p>
<p>You will see the first 10 lines of your text. Make sure to include the hyphen, as otherwise PowerShell will not know that <code type="inline">-TotalCount</code> is a parameter. Now enter</p>
<p><code type="inline">gc bigben.txt -tail 10</code></p>
<p>and you will see the last 10 lines. What we have done is specified our <code type="inline">gc</code> cmdlet with the parameters <code type="inline">-totalcount</code> and <code type="inline">-tail</code>. Almost all cmdlets can be refined by adding parameters like this. But how do we know what parameters are available?</p>
<h3>Finding out more with <code type="inline">Get-Help</code></h3>
<p>PowerShell does not expect you to memorize all the possible parameters for all the cmdlets. Instead, it provides an easy way to list them off using the cmdlet <code type="inline">Get-Help</code>. Enter</p>
<p><code type="inline">Get-Help gc</code></p>
<p>and you'll get a screen that looks like this:</p>
<figure><desc>Help page for `Get-Content`</desc><graphic url="intro-to-powershell6.png"/></figure>
<p>Your page may be slightly different, but the important part to look at right now is the section labeled "SYNTAX." This shows us all of the parameters we can add to <code type="inline">Get-Content</code>. If you're just trying to remember the exact name of a parameter you've used before, this will be enough to jog your memory. But it doesn't tell us what the parameters actually do.</p>
<p>Fortunately, <code type="inline">Get-Help</code> itself has parameters, and by adding <code type="inline">-online</code> to your <code type="inline">Get-Help</code> cmdlet, you tell PowerShell to ask your browser to open a page on Microsoft's TechNet portal that explains all the parameters in plain English. Enter</p>
<p><code type="inline">Get-Help gc -online</code></p>
<figure><desc>The online help page for `Get-Content`</desc><graphic url="intro-to-powershell7.png"/></figure>
<p>Here we can see the actual description of the parameters <code type="inline">-TotalCount</code> and <code type="inline">-Tail</code>.</p>
<h3>Solving the Infinite Loop Problem with the <code type="inline">-exclude</code> Parameter</h3>
<p>Look again at the help for <code type="inline">Get-Content</code>, and you'll see that one of the possible parameters is <code type="inline">-exclude</code>. This sounds promising for dealing with our infinite loop problem! The description online reads: "Omits the specified items. The value of this parameter qualifies the <hi rend="bold">Path</hi> parameter. Enter a path element or pattern, such as '*.txt'. Wildcards are permitted." This sounds <emph>very</emph> promising. The "Path parameter" is (usually) the thing you write immediately after your cmdlet. It tells PowerShell where to apply the cmdlet. When we type <code type="inline">gc benjamin.txt</code>, <code type="inline">benjamin.txt</code> is the path. It is actually shorthand for <code type="inline">.\benjamin.txt</code>, which in turn is shorthand for <code type="inline">C:\Users\YOURUSERNAME\funWithPowerShell\dir\benjamin.txt</code>. That line tells your computer the path to follow through the tree-like structure of your file system in order to find the file you want. What help is telling us, then, is that we can omit specified items from our <code type="inline">gc</code> cmdlet by adding the parameter <code type="inline">-exclude</code> and then entering the path we want it to exclude. We can use this to take the contents of all of our <code type="inline">.txt</code> files and put them into a new file without creating an infinite loop. See if you can figure out what to type, using what we did with <code type="inline">-totalcount</code> and <code type="inline">-tail</code> as a reference.</p>
<p>Here's what I did. I first deleted my current bigben.txt with <code type="inline">rm</code>. (This isn't really necessary, since using a single <code type="inline">&gt;</code> on my redirect will replace the current contents anyway, but it's nice to have a clean start!) Then I entered</p>
<p><code type="inline">gc *.txt -exclude bigben.txt &gt; bigben.txt</code></p>
<p>Voila!</p>
<p>Throughout this process, we've been adding texts together, or concatenating them. You can learn more about <link target="https://en.wikipedia.org/wiki/Concatenation">concatenation from Wikipedia</link>, and if you want to see a few more examples of concatenation using PowerShell, check out this <link target="https://blogs.technet.microsoft.com/heyscriptingguy/2014/07/15/keep-your-hands-clean-use-powershell-to-glue-strings-together">blog entry</link>, which will take you into the wonderful world of variables, something beyond the scope of this tutorial, but well worth learning about.</p>
<h3>Getting Even More out of cmdlets with Piping</h3>
<p>So now we have five documents in our directory. In order to be able to do really useful things with them, we need one more tool: <hi rend="bold">Piping</hi>. Piping is sort of like redirection, but instead of telling PowerShell to put the results of a cmdlet somewhere else, it tells it to take the output of one cmdlet and use it as the input for another. Where we use <code type="inline">&gt;</code> for redirection, for piping we use <code type="inline">|</code>.</p>
<p>We are going to get even more mileage out of <code type="inline">gc</code>, this time by piping its results to the cmdlet <code type="inline">measure-object</code> (or just <code type="inline">measure</code>). This latter cmdlet measures various properties. For our purposes, we will use it to get the number of lines, words, and characters in our files by adding the parameters <code type="inline">-line</code>, <code type="inline">-word</code>, and <code type="inline">-character</code>, or just <code type="inline">-l</code>, <code type="inline">-w</code>, <code type="inline">-c</code>. (With parameters, you only need to type as much of the name as necessary to identify the parameter in question. Use <code type="inline">Get-Help</code> to figure out what that will be for a given cmdlet.)</p>
<p>Enter this:</p>
<p><code type="inline">gc benjamin.txt | measure -l -w -c</code></p>
<p>You should get a count of the lines, words, and characters in the text. Of course, you could do this easily enough with your word processor. The power of working on the command-line comes from being able to manipulate lots of things at once and being able to specify what we want done with extra precision. In this example, this means we can count words in multiple of our files at once, and that we can add additional parameters to specify exactly how we want to count them.</p>
<p>See if you can get a count for the lines, words, and characters in all the files. It should be no surprise to you that the wildcard (<code type="inline">*</code>) can help you here. For instance, you could enter</p>
<p><code type="inline">gc *.txt | measure -l -w -c</code></p>
<p>With our five small files, this still doesn't result in much, but it would have taken longer using the word processor, and we could also do it with a directory containing thousands of lengthy files. We can also control our actions more precisely with additional parameters. Use <code type="inline">Get-Help measure</code> to see the parameters at your disposal. We could go to the online help to learn more about them, but for now let's just use one that's self-explanatory as an example: <code type="inline">-IgnoreWhiteSpace</code>.</p>
<p>Use the up-arrow to get your last command back, and add <code type="inline">-ignorewhitespace</code> to the end. (You can also just type <code type="inline">-ig</code>, but <code type="inline">-i</code> alone is not sufficient, because it doesn't differentiate the <code type="inline">-IgnoreWhiteSpace</code> parameter from the <code type="inline">-InputObject</code> parameter, as a helpful error message will tell you if you try it.) You'll see the same count, but with fewer characters, because this time PowerShell didn't count the spaces. The advantage of precision is clear over using a word processor, where it is difficult to determine whether or not white space is being ignored in the first place, let alone to toggle the feature.</p>
<h2>Using Command-Line Tools and Running Python Scripts</h2>
<p>The most important reason to become familiar with using the command line is not because of the increased precision or the ability to work with multiple files, useful as these features are, but rather because of the many additional tools you gain access to, as mentioned in the introduction. When getting set up to work with some of these tools, you may run into problems because Windows sometimes configures the paths incorrectly. Fixing this problem requires setting environment variables, a topic beyond the scope of this tutorial. Fortunately, there is a lot of support out there, and a little searching will usually turn up the solution you need. Because many lessons on <emph>The Programming Historian</emph> require you to use Python, let's look briefly at getting Python set up. Having done this, you will be less daunted by instructions for setting environment variables for other programs.</p>
<p>If you don't already have Python, or if you wonder why you would want to use it, check out the <link target="/lessons/introduction-and-installation">Python tutorial</link> right here on <emph>The Programming Historian</emph>. In that tutorial, you will learn to set up Python to run scripts directly in an editor. It will often be more useful to be able to run scripts from the command line. In order to do that, we need to set an environment variable. First, you need to know the name of the directory where Python is installed on your computer. Enter <code type="inline">sl C:\</code> and then use <code type="inline">gci</code>. You should see a directory named "Python" with the version number at the end. On my computer, the directory is "Python27." Now we tell Windows to create a Path variable pointing to that directory by entering this into PowerShell, replacing "Python27" with the name of the directory on your computer:</p>
<p><code type="inline">[Environment]::SetEnvironmentVariable("Path", "$env:Path;C:\Python27", "User")</code></p>
<p>This tells Windows: "Hey, the path for Python is C:\Python27." If you want to understand exactly how this works, look at <link target="https://technet.microsoft.com/en-us/library/ff730964.aspx">this page</link> on Microsoft's TechNet portal (the same portal you get to using the <code type="inline">-online</code> parameter with <code type="inline">Get-Help</code>).</p>
<p>Once you've entered the command above, exit PowerShell and start it again. You should now be able to start the Python interpreter by typing <code type="inline">python</code> into PowerShell. To run scripts, you simply type <code type="inline">python</code> followed by the path for the script you want. It's easiest to first navigate to the directory with the script in it, and then just enter <code type="inline">python script-name.py</code>.</p>
<p>Now you're all set up to run Python scripts from the command line!</p>
</div>
      <div n="1"><head>Conclusion</head>
<p>In this tutorial, you've learned some of the basics of working with PowerShell, the command-line interface on Windows. You now know enough to use PowerShell for many of the day-to-day tasks you do on your computer, and I would recommend using it for just that. At first, you may find it more difficult to copy a file and move it to a new directory from the command line, but the more you practice, the more natural it will become. Eventually, you will be very comfortable working in PowerShell, and will be able to do many tasks more easily this way.</p>
<p>Although we have only had a glimpse of what PowerShell can do, you now have enough basic knowledge to learn to do more. There are lots of helpful resources online, and they are yours for the googling! It is also helpful to know that a lot of discussions about using the command line will be based on Unix and other *nix systems. In most cases, if you just type the names of the commands they are using together with "PowerShell" into a search engine, you will find the corresponding PowerShell cmdlet.</p>
<p>The more you use PowerShell, the easier it will be, and the more you will learn to unlock capabilities you did not even know your computer had! Eventually, you will see how constraining your GUI has been. You won't stop using it, but you will find yourself starting up PowerShell more and more often to break free from these constraints, and utilize your computer more fully. Your computer is like a pocket knife. The GUI only allows you to open a few blades. With the command line, you can open them all!</p>
</div>
      <div n="1"><head>Quick Reference</head>
<p>This table serves as a quick reference to all the cmdlets discussed in this lesson. The first column shows the actual name; the second shows what you will normally type instead. The Bash equivalent shows the most similar command in Bash. Unless this command is in parentheses, it can also be used in PowerShell as an alias for the corresponding cmdlet. (Linux and OS X users, please see the note below.) For a more complete explanation of any of the cmdlets, use <code type="inline">Get-Help</code> with the <code type="inline">-online</code> parameter (e.g. <code type="inline">Get-Help Get-ChildItem -online</code>.)</p>
<table>
<thead>
<tr>
<th>Cmdlet</th>
<th>Alias</th>
<th>Bash Equivalent</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code type="inline">Get-ChildItem</code></td>
<td><code type="inline">gci</code></td>
<td><code type="inline">ls</code></td>
<td>List the directories and files in the current location.</td>
</tr>
<tr>
<td><code type="inline">Set-Location</code></td>
<td><code type="inline">sl</code></td>
<td><code type="inline">cd</code></td>
<td>Change to the directory at the given path. Typing <code type="inline">..</code> rather than a path will move up one directory.</td>
</tr>
<tr>
<td><code type="inline">Push-Location</code></td>
<td><code type="inline">pushd</code></td>
<td><code type="inline">pushd</code></td>
<td>Changes to the directory.</td>
</tr>
<tr>
<td><code type="inline">Pop-Location</code></td>
<td><code type="inline">popd</code></td>
<td><code type="inline">popd</code></td>
<td>Changes back to the previous directory after using <code type="inline">pushd</code></td>
</tr>
<tr>
<td><code type="inline">New-Item</code></td>
<td><code type="inline">ni</code></td>
<td>(<code type="inline">touch</code>)</td>
<td>Creates a new item. Used with no parameter, the item is by default a file. Using <code type="inline">mkdir</code> is a shortcut for including the parameter <code type="inline">-ItemType dir</code>.</td>
</tr>
<tr>
<td><code type="inline">mkdir</code></td>
<td>none</td>
<td><code type="inline">mkdir</code></td>
<td>Creates a new directory. (See <code type="inline">New-Item</code>.)</td>
</tr>
<tr>
<td><code type="inline">Explorer</code></td>
<td>none</td>
<td>(<code type="inline">open</code>)</td>
<td>Open something using File Explorer (the GUI)</td>
</tr>
<tr>
<td><code type="inline">Remove-Item</code></td>
<td><code type="inline">rm</code></td>
<td><code type="inline">rm</code></td>
<td>Deletes something. Permanently!</td>
</tr>
<tr>
<td><code type="inline">Move-Item</code></td>
<td><code type="inline">mv</code></td>
<td><code type="inline">mv</code></td>
<td>Moves something. Takes two arguments - first a filename (i.e. its present path), then a path for its new location (including the name it should have there). By not changing the path, it can be used to rename files.</td>
</tr>
<tr>
<td><code type="inline">Copy-Item</code></td>
<td><code type="inline">cp</code></td>
<td><code type="inline">cp</code></td>
<td>Copies a file to a new location. Takes same arguments as move, but keeps the original file in its location.</td>
</tr>
<tr>
<td><code type="inline">Write-Output</code></td>
<td><code type="inline">write</code></td>
<td><code type="inline">echo</code></td>
<td>Outputs whatever you type. Use redirection to output to a file. Redirection with <code type="inline">&gt;&gt;</code> will add to the file, rather than overwriting contents.</td>
</tr>
<tr>
<td><code type="inline">Get-Content</code></td>
<td><code type="inline">gc</code></td>
<td><code type="inline">cat</code></td>
<td>Gets the contents of a file and prints it to the screen. Adding the parameter <code type="inline">-TotalCount</code> followed by a number x prints only the first x lines. Adding the parameter <code type="inline">-Tail</code> followed by a number x prints only the final x lines.</td>
</tr>
<tr>
<td><code type="inline">Select-String</code></td>
<td><code type="inline">sls</code></td>
<td>(<code type="inline">grep</code>)</td>
<td>Searches for specific content.</td>
</tr>
<tr>
<td><code type="inline">Measure-Object</code></td>
<td><code type="inline">measure</code></td>
<td>(<code type="inline">wc</code>)</td>
<td>Gets statistical information about an object. Use <code type="inline">Get-Content</code> and pipe the output to <code type="inline">Measure-Object</code> with the parameters <code type="inline">-line</code>, <code type="inline">-word</code>, and <code type="inline">-character</code> to get word count information.</td>
</tr>
<tr>
<td><code type="inline">&gt;</code></td>
<td>none</td>
<td><code type="inline">&gt;</code></td>
<td>Redirection. Puts the output of the command to the left of <code type="inline">&gt;</code> into a file to the right of <code type="inline">&gt;</code>.</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
<td>none</td>
<td>`</td>
</tr>
<tr>
<td><code type="inline">Get-Help</code></td>
<td>none</td>
<td><code type="inline">man</code></td>
<td>Gets the help file for a cmdlet. Adding the parameter <code type="inline">-online</code> opens the help page on TechNet.</td>
</tr>
<tr>
<td><code type="inline">exit</code></td>
<td>none</td>
<td><code type="inline">exit</code></td>
<td>Exits PowerShell</td>
</tr>
</tbody></table><p>Remember the keyboard shortcuts of <code type="inline">tab</code> for auto-completion and the up and down arrows to scroll through recent commands. These shortcuts can save a lot of typing!</p>
<p><emph>A note to Linux and OS X users</emph>: Although many Bash commands work in PowerShell, they often don't do exactly the same thing. They may take different parameters, and the syntax may be slightly different. (Technically, they never do the same thing, as PowerShell commands produce objects, whereas Bash commands produce text.) However, the similarity of their actions offers a handy crutch for quickly getting up and running with PowerShell, and a little help from the <code type="inline">Get-Help</code> cmdlet (you can just type <code type="inline">man</code> like in Bash) will usually resolve any confusion.</p>
</div>
    </body>
  </text>
</TEI>
