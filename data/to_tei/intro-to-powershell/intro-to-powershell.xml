<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:id="intro-to-powershell">
    <teiHeader>
        <fileDesc>
            <titleStmt>
                <title>Introduction to the Windows Command Line with PowerShell</title>
                <author role="original_author">Ted Dawson</author>
                <editor role="reviewers">
                    <persName>Erin N. Bush</persName>
                    <persName>Derek Price</persName>
                </editor>
                <editor role="editors">Jeri Wieringa</editor>
            </titleStmt>
            <publicationStmt>
                <distributor>Programming Historian</distributor>
                <idno type="doi">10.46430/phen0054</idno>
                <date type="published">07/21/2016</date>
            </publicationStmt>
            <sourceDesc>
                <p>Born digital, in a markdown format. This lesson is original. Available translations are the following:<ref type="translations" target="#introduccion-a-powershell"/>
                </p>
            </sourceDesc>
        </fileDesc>
        <profileDesc>
            <abstract>
                <p>This tutorial will introduce you to the basics of Windows PowerShell, the standard command-line interface for Windows computers.</p>
            </abstract>
            <textClass>
                <keywords>
                    <term xml:lang="en">data-manipulation</term>
                    <term xml:lang="en">get-ready</term>
                </keywords>
            </textClass>
        </profileDesc>
    </teiHeader>
    <text xml:lang="en">
        <body>
            <div type="1">
                <head>Introduction</head>
                <p>This tutorial will introduce you to the basics of Windows PowerShell, the standard command-line interface for Windows computers. If you are a Mac or Linux user, you should check out the <ref target="/lessons/intro-to-bash">Bash introduction</ref> instead. If you are already familiar with using Bash, you may be able to get started with PowerShell just by looking at the <ref target="#quick-reference">table at the end of this lesson</ref>.</p>
                <p>The tutorial is divided into two main sections. In the first section, "<ref target="#getting-started">Getting Started</ref>," you will learn to do basic desktop tasks like creating and opening files and folders using PowerShell. In the second section, "<ref target="#doing-more">Doing More</ref>," you will get a glimpse of some of the features that make work on the command line particularly efficient, and learn enough of the basics to be able to explore further on your own. You will also <ref target="#using-command-line-tools-and-running-python-scripts">get set up to run Python scripts from the command line</ref>.</p>
                <p>This tutorial was written for PowerShell 5.0. If you are using an earlier version, you may encounter a few small syntax differences which you should be able to overcome with a little help from a search engine.</p>
            </div>
            <div type="1">
                <head>What is PowerShell and Why is it Useful?</head>
                <p>Windows PowerShell is a <hi rend="bold">command-line interface</hi> for Windows computers. A command-line interface (CLI) is a program for telling your computer to do tasks using typed commands, rather than by clicking pictures on the desktop as in a <hi rend="bold">graphical user interface</hi> (GUI). (Technically, PowerShell is more than just the CLI, and you can get a quick overview of its features on <ref target="https://en.wikipedia.org/wiki/Windows_PowerShell">Wikipedia</ref>.) Using the command line has many advantages. It makes it possible to automate tasks and to do many things with one command. Most importantly, a number of tools of value to humanists can only be run from the command line, including many you can learn about on <emph>The Programming Historian</emph>, like <ref target="/lessons/topic-modeling-and-mallet">Mallet</ref>, <ref target="/lessons/sustainable-authorship-in-plain-text-using-pandoc-and-markdown">Pandoc</ref>, or <ref target="/lessons/automated-downloading-with-wget">Wget</ref>. The command line is also the best place to work with programs you have custom built for your own research using programming languages like Python.</p>
            </div>
            <div type="1">
                <head>Getting Started</head>
                <p>You will first learn to navigate through your files and do some of the basic tasks you do every day on the computer.</p>
                <div type="2">
                    <head>Open PowerShell</head>
                    <p>Run a search for PowerShell on your computer. You probably have several different options, like "PowerShell," "PowerShell ISE," and "PowerShell (x86)." The ISE (integrated scripting environment) is a handy tool which allows you to write scripts on the fly, and also has a convenient look-up for all the PowerShell commands. Right now, this is more than we need. "x86" exists for backwards compatibility. (If you've been around a while, you'll remember old Intel processors from the 80s and early 90s called "286," "386," "486," and so forth. That's what "x86" is getting at. It is a 32-bit version.) We want 64-bit and simple, so we'll use the one just called "Windows PowerShell." You may want to pin it to your task-bar (right click it to get this option). When you open it, it will look like this:</p>
                    <figure>
                        <desc>PowerShell on start up</desc>
                        <graphic url="intro-to-powershell1.png"/>
                    </figure>
                    <p>If you don't like the white on blue, right click the top bar, select "properties," and go to "colors" to change things. You may have to close and re-open PowerShell to get it to display correctly.</p>
                </div>
                <div type="2">
                    <head>Navigation</head>
                    <p>A nice thing about PowerShell is you always know where you are because it tells you in the prompt. In my case, I see:</p>
                    <p>
                        <code rend="inline">C:\Users\Ted&gt;</code>
                    </p>
                    <p>You should see something similar, but with your user name. In case you don't, type</p>
                    <p>
                        <code rend="inline">sl ~</code>
                    </p>
                    <p>Make sure to include the space. This will bring you to your home directory: <code rend="inline">C:\Users\YOURUSERNAME</code> where "YOURUSERNAME" is replaced with the name of your account on the machine. "Directory" is just another word for "folder," and PowerShell considers your user folder - not the desktop - to be your home. (The desktop is actually just another folder within your user folder, that is, a subdirectory of the user directory). Entering <code rend="inline">sl ~</code> is just like opening the folder called "Users" and from there "YOURUSERNAME" using your GUI. Let's start by learning how to move around between directories and view their contents.</p>
                    <div type="3">
                        <head>Viewing Directory Contents with <code rend="inline">Get-ChildItem</code> (<code rend="inline">gci</code>, <code rend="inline">ls</code>)</head>
                        <p>Our first command is <code rend="inline">Get-ChildItem</code>. Go ahead and type it in, and hit enter. You'll see a list of everything in your current directory. In my case, that looks like this:</p>
                        <figure>
                            <desc>Listing directory contents with `Get-ChildItem`</desc>
                            <graphic url="intro-to-powershell2.png"/>
                        </figure>
                        <p>Notice that I didn't actually enter <code rend="inline">Get-ChildItem</code>. I just entered <code rend="inline">gci</code>. The commands we will be learning are all of the form <code rend="inline">Verb-Noun</code>. These are called "cmdlets" (pronounced "commandlets"), and their form is supposed to make it easy to remember what they do and predict similar cmdlets. Because cmdlets are rather long, most of them come with sleeker aliases that you can use instead. I will first present cmdlets with their names, but always subsequently use the standard aliases, because they are much faster to work with. It is important to note that many cmdlets have multiple aliases. For instance, <code rend="inline">Get-ChildItem</code>, <code rend="inline">gci</code>, <code rend="inline">dir</code>, and <code rend="inline">ls</code> all do exactly the same thing. While it is unsurprising that <code rend="inline">gci</code> is short for <code rend="inline">Get-ChildItem</code>, you may be wondering where <code rend="inline">dir</code> and <code rend="inline">ls</code> come from.</p>
                        <p>PowerShell is relatively new (first released in 2006), and its designers anticipated that many people who would use it would already have experience with some existing CLIs (command-line interfaces), specifically either with Microsoft's older CLI called command prompt, or with Linux CLIs like Bash, which is now also standard on OS X. Thus, many cmdlets have an alias that is the standard command in one of these two systems (and often for both). In the present example, <code rend="inline">dir</code> comes from command prompt, and <code rend="inline">ls</code> comes from Bash. I will use the "PowerShell-style" aliases in this tutorial, since it makes it easier to remember the actual cmdlet names. However, I will try to also mention other common aliases, particulary those familiar to Bash users. If you work with a lot of people who use OS X or Linux, it can be good to know these names. The <ref target="#quick-reference">table at bottom</ref> gives the cmdlets along with their standard PowerShell aliases and the nearest Bash equivalent.</p>
                        <p>Go ahead and try using <code rend="inline">gci</code>, <code rend="inline">dir</code>, and <code rend="inline">ls</code>. You'll get the exact same list of things. Most of these things will be directories. One of them should be your desktop. Let's move into that directory.</p>
                    </div>
                    <div type="3">
                        <head>Moving Between Directories with <code rend="inline">Set-Location</code> (<code rend="inline">sl</code>, <code rend="inline">cd</code>)</head>
                        <p>To move to your desktop, we'll use the <code rend="inline">Set-Location</code> cmdlet. Enter</p>
                        <p>
                            <code rend="inline">sl desktop</code>
                        </p>
                        <p>into PowerShell. This tells PowerShell to move to the desktop. Notice that you can write "desktop" using all lowercase letters, even though when you looked at the contents of the <code rend="inline">YOURUSERNAME</code> directory, "Desktop" was spelled with a capital "D". PowerShell is not case sensitive! Now that you've changed your location, you can use <code rend="inline">gci</code> to see a list of everything on your desktop - that is, everything in the directory named <code rend="inline">Desktop</code>. If you're as disorganized as I am, this will be a long list. We can move back to the <code rend="inline">YOURUSERNAME</code> directory by typing</p>
                        <p>
                            <code rend="inline">sl ..</code>
                        </p>
                        <p>Don't leave out the space! Now type</p>
                        <p>
                            <code rend="inline">sl ..</code>
                        </p>
                        <p>again. You should be in the <code rend="inline">Users</code> directory.</p>
                        <p>Now try navigating back to the desktop, and then back again to <code rend="inline">Users</code>. That should take four commands: <code rend="inline">sl YOURUSERNAME</code>, <code rend="inline">sl desktop</code>, <code rend="inline">sl ..</code>, <code rend="inline">sl ..</code>. But you can actually do it with only two. You should be at <code rend="inline">C:\Users&gt;</code> right now. Instead of typing <code rend="inline">sl YOURUSERNAME</code> and then <code rend="inline">sl desktop</code>, you can just type</p>
                        <p>
                            <code rend="inline">sl YOURUSERNAME\desktop</code>
                        </p>
                        <p>and get to the desktop with one command! Similarly, from the desktop, by typing</p>
                        <p>
                            <code rend="inline">sl ..\..</code>
                        </p>
                        <p>you can get back to where you started with one command. If you don't have the pinkie stamina for typing <code rend="inline">\</code> all the time, you can also type <code rend="inline">sl ../..</code>. Not only is PowerShell not case sensitive, it also doesn't care what direction the slash goes. <code rend="inline">sl ../..</code>, <code rend="inline">SL ..\..</code>, <code rend="inline">Set-Location ..\..</code>, and <code rend="inline">set-location ../..</code> all do exactly the same thing.</p>
                    </div>
                    <div type="3">
                        <head>Creating New Directories with <code rend="inline">mkdir</code>
                        </head>
                        <p>We're moving toward working with files. Before we start, let's make a directory where we can store everything we're using for this lesson. Navigate back home by typing</p>
                        <p>
                            <code rend="inline">sl ~</code>
                        </p>
                        <p>We'll make a new directory inside of your <code rend="inline">YOURUSERNAME</code> directory. To do this, we use the command <code rend="inline">mkdir</code>. Call your directory whatever you want, but try not to use spaces, as these make working on the command line more complicated than necessary. I will call my directory "funWithPowerShell". So I type</p>
                        <p>
                            <code rend="inline">mkdir funWithPowerShell</code>
                        </p>
                        <p>See how I used <ref target="https://en.wikipedia.org/wiki/CamelCase">CamelCase</ref> to avoid spaces? Another common way to do this is with hyphens or underscores, as in <code rend="inline">fun_with_power_shell</code>. Whatever you name your directory, try to avoid using spaces. Once you've been working with PowerShell a little, you'll probably find that you start titling new files without spaces by default. This is a good habit to be in, as it simplifies work on the command line as well as work with programming languages like Python.</p>
                        <p>However, you probably have plenty of existing files with spaces in their names. To open these in PowerShell, you just need to use quotes. Let's try this. Move into your new directory using</p>
                        <p>
                            <code rend="inline">sl funWithPowerShell</code>
                        </p>
                        <p>(Or whatever you titled your directory.) Enter</p>
                        <p>
                            <code rend="inline">gci</code>
                        </p>
                        <p>and you'll see that there's nothing here. That's because you haven't put anything in it! Let's put a new directory inside with <code rend="inline">mkdir</code>. We'll call this directory "Directory with a long name and lots of spaces". Because the name has spaces in it, we'll have to use quotes to create it. Type</p>
                        <p>
                            <code rend="inline">mkdir "Directory with a long name and lots of spaces"</code>
                        </p>
                        <p>and hit enter. Now enter</p>
                        <p>
                            <code rend="inline">gci</code>
                        </p>
                        <p>and you'll see your new directory. Suppose we want to move into this directory. We would have to type <code rend="inline">sl "Directory with a long name and lots of spaces"</code>. Not only will this take a while to type, but if we get one letter wrong, PowerShell won't be able to find our directory. Instead, try just typing</p>
                        <p>
                            <code rend="inline">sl d</code> and then hitting the <code rend="inline">tab</code> key.</p>
                        <p>Voila! PowerShell completes the name of the directory for us, including the quotes! Using <code rend="inline">tab</code> for auto-completion will save you a lot of time. You'll notice that when PowerShell completed the name for us, it also threw in a <code rend="inline">.\</code> at the beginning of the directory name. The dot is just shorthand for the current directory. When you type commands, PowerShell always assumes there's a <code rend="inline">.\</code> at the beginning - in other words, that you are referring to something in the current directory. So you don't have to type this part (unless you want PowerShell to look somewhere else for whatever you're telling it to do, in which case you can type the path for that directory - i.e. <code rend="inline">C:\directory\bla\etc</code>.)</p>
                        <p>Let's practice a little more with directories before getting to files.</p>
                    </div>
                    <div type="3">
                        <head>Using <code rend="inline">Explorer</code> to View Directories in the GUI</head>
                        <p>At this point, we've made two directories. I mentioned above that "directory" is just another word for "folder." You can see this for yourself by finding your new directories in the GUI. Windows actually calls your GUI "File Explorer" or just "Explorer." We can call Explorer from within PowerShell by using the command <code rend="inline">Explorer</code>. Navigate back into your funWithPowerShell folder with</p>
                        <p>
                            <code rend="inline">sl ..</code>
                        </p>
                        <p>Now try typing</p>
                        <p>
                            <code rend="inline">explorer .</code>
                        </p>
                        <p>Remember, the dot just means "this directory," and you don't have to capitalize "explorer" because case doesn't matter in PowerShell. Explorer should have just opened a window showing the contents of the "funWithPowerShell" directory. Arrange your windows so you can see both the image in Explorer and PowerShell. Now you'll be able to watch how what you do in PowerShell shows up in Explorer.</p>
                        <p>The <code rend="inline">Explorer</code> command is extremely useful. It is essentially like double-clicking something in the GUI. Thus, you can also use it to open files and programs.</p>
                    </div>
                    <div type="3">
                        <head>Deletion with <code rend="inline">Remove-Item</code> (<code rend="inline">rm</code>)</head>
                        <p>Now that you can see the results of what you're doing in PowerShell, let's learn to delete things - for instance that directory with the long name. First, create a few more directories. Name them "dir," "dir1," and "dir2." You can make all three with a single command by typing</p>
                        <p>
                            <code rend="inline">mkdir dir, dir1, dir2</code>
                        </p>
                        <p>Pretty neat, huh? You should see your three new directories pop up in your open Explorer window.</p>
                        <p>Now, let's get rid of that long-named directory. To do this, we use the cmdlet <code rend="inline">Remove-Item</code> or just <code rend="inline">rm</code>. You have to be <hi rend="bold">very careful</hi> with this cmdlet, because it does not put things in your recycle bin. It <hi rend="bold">deletes them permanently</hi>. Gone. Type in <code rend="inline">rm</code> followed by a space and the long-named directory's name. You'll probably want to use <code rend="inline">tab</code> for auto-completion. Note, however, that now that we have a bunch of directories with names beginning with "d", so we have to type through the first unique letter to get it to auto-complete correctly. So I type</p>
                        <p>
                            <code rend="inline">rm dire</code> and then hit <code rend="inline">tab</code>.</p>
                        <p>Alternatively, you can just type <code rend="inline">rm</code> and then hit <code rend="inline">tab</code> multiple times to scroll through all your directories. If you go too far, use <code rend="inline">shift</code> with <code rend="inline">tab</code> to scroll back.</p>
                        <p>Before pressing <code rend="inline">enter</code>, I stare long and hard to make sure I'm deleting the thing I want to delete. Then I hit <code rend="inline">enter</code>.</p>
                        <p>Go ahead and delete the other three directories, and watch them disappear from Explorer. Just like with <code rend="inline">mkdir</code>, you can delete all three directories with one command. Give it a try.</p>
                        <p>We just deleted the <code rend="inline">dir</code>, <code rend="inline">dir1</code>, and <code rend="inline">dir2</code> directories. But we'll need them for the next example. So let's create them again. Rather than typing out the instruction, though, try just tapping the up arrow on your keyboard a couple of times. You should soon see the command you used to make the three directories the first time. Once you do, hit enter, and they'll be made again! Like using <code rend="inline">tab</code> to auto-complete, using the up and down arrows to scroll through recent commands will save you a lot of time! <hi rend="bold">Note that we are not undoing our earlier deletion.</hi> We are just using a shortcut to enter again a command we've recently used.</p>
                    </div>
                    <div type="3">
                        <head>Understanding the Tree Structure of Your Computer's File System</head>
                        <p>Okay, now you should have three directories inside your <code rend="inline">funWithPowerShell</code> directory. Move into the <code rend="inline">dir</code> directory. (Use <code rend="inline">sl dir</code>).</p>
                        <p>It's important to understand how your computer organizes things. Look at the path to your current directory. The path is all the stuff written before the <code rend="inline">&gt;</code>. In my case, that's</p>
                        <p>
                            <code rend="inline">C:\Users\Ted\funWithPowerShell\dir</code>
                        </p>
                        <p>Yours should look pretty similar. What this path actually represents is a tree-like structure the computer follows to get to where you are. The trunk of the tree is <code rend="inline">C:</code> which is your hard drive. (Actually, on most modern computers, it will be a partition of your hard drive. Why is it called <code rend="inline">C</code>? Your computer assigns a letter to every drive. <code rend="inline">A</code> and <code rend="inline">B</code> are reserved for the two floppy disk drives which long ago users would have interacted with more frequently than their hard drives. Even though most computers no longer have them, their names are still reserved.)</p>
                        <p>If <code rend="inline">C:</code> is the trunk, each section of the path after it is a branch, each one coming off the one above it. Thus, <code rend="inline">Users</code> is a branch from <code rend="inline">C:</code>, <code rend="inline">Ted</code> is a smaller branch coming off of <code rend="inline">Users</code> and so forth. You could also use a metaphor of heredity rather than botany and call each branch a <code rend="inline">child</code> of the directory above it. This is actually the more common language for describing the relationships between directories (hence the cmdlet <code rend="inline">Get-ChildItem</code>), but we'll stick with the tree metaphor, since in real life, relationships of heredity can be much more complex than the extremely hierarchical structure according to which your computer is organized.</p>
                        <p>Understanding that the path works like a tree is important for navigating around to directories not immediately above or below the current one. Thus, we know there is a directory called "dir1", and that this directory is also in the "funWithPowerShell" directory. See what happens if you attempt to use <code rend="inline">sl</code> to move directly over into it by typing</p>
                        <p>
                            <code rend="inline">sl dir1</code>
                        </p>
                        <p>This threw an error!</p>
                        <figure>
                            <desc>An error caused by jumping between branches</desc>
                            <graphic url="intro-to-powershell3.png"/>
                        </figure>
                        <p>We've tried to jump from one branch to another, and PowerShell can only understand our movement if we move along the tree. That means we first have to move up to where the branches for "dir1" and "dir" meet, and then back down to "dir1." You can do this with one command. See if you can figure it out before you read the next line.</p>
                        <p>The command is:</p>
                        <p>
                            <code rend="inline">sl ..\dir1</code>
                        </p>
                        <p>This tells PowerShell to move up one directory to <code rend="inline">funWithPowerShell</code> and then move back down into the directory <code rend="inline">dir1</code>.</p>
                    </div>
                    <div type="3">
                        <head>Moving fast with <code rend="inline">Push-Location</code> (<code rend="inline">pushd</code>) and <code rend="inline">Pop-Location</code> (<code rend="inline">popd</code>)</head>
                        <p>Before moving on to working with files, let's try out the commands <code rend="inline">pushd</code> and <code rend="inline">popd</code>. Do this: Go all the way up to the trunk of your tree, <code rend="inline">C:</code>. That should be four directories above where you are, so you could type</p>
                        <p>
                            <code rend="inline">sl ..\..\..\..</code>
                        </p>
                        <p>Then, change back to <code rend="inline">dir1</code>. But rather than typing <code rend="inline">sl</code> before the path, type <code rend="inline">pushd</code>. Like this:</p>
                        <p>
                            <code rend="inline">pushd users\YOURUSERNAME\funWithPowerShell\dir1</code>
                        </p>
                        <p>You'll now be in the directory, just as if you'd typed <code rend="inline">sl</code> at the beginning of that path. But here's the fun part. Now type</p>
                        <p>
                            <code rend="inline">popd</code>
                        </p>
                        <p>and hit enter. Neat, right? The command <code rend="inline">pushd</code> tells powershell to move into the given directory after marking the current directory so it can be returned to with <code rend="inline">popd</code>. In other words, <code rend="inline">popd</code> will always "pop" you back to the last directory you were in before using <code rend="inline">pushd</code>. (If you want to understand more about what is going on, read about the <ref target="https://en.wikipedia.org/wiki/Call_stack">call stack</ref> on Wikipedia.) Using <code rend="inline">pushd</code> and <code rend="inline">popd</code> is very useful when you're frequently moving between two directories.</p>
                    </div>
                </div>
                <div type="2">
                    <head>Working With Files</head>
                    <p>Now that you know how to move around your computer's file system from the command line, let's work on actually doing things to files. We'll start by learning to <hi rend="bold">create</hi> new files, <hi rend="bold">copy</hi> them, and <hi rend="bold">move</hi> them around.</p>
                    <div type="3">
                        <head>Creating Files with <code rend="inline">New-Item</code> (<code rend="inline">ni</code>)</head>
                        <p>First, we need some files to work with. Let's make a new plain text document called "example.txt". Navigate to the <code rend="inline">funWithPowerShell</code> directory - use tab for each directory name as you type out the path to speed this up - and type</p>
                        <p>
                            <code rend="inline">ni example.txt</code>
                        </p>
                        <p>then hit enter. Now do</p>
                        <p>
                            <code rend="inline">gci</code>
                        </p>
                        <p>to see that, indeed, you now have, in addition to your directories, the file <code rend="inline">example.txt</code>. We'll need several files, so go ahead and make <code rend="inline">example1.txt</code> and <code rend="inline">example2.txt</code>. You'll be unsurprised to hear that with a comma, you can do this in one command:</p>
                        <p>
                            <code rend="inline">ni example1.txt, example2.txt</code>
                        </p>
                    </div>
                    <div type="3">
                        <head>Copying and Moving Files with <code rend="inline">Copy-Item</code> (<code rend="inline">cp</code>) and <code rend="inline">Move-Item</code> (<code rend="inline">mv</code>)</head>
                        <p>We probably should have put these files into one of our directories. Let's move them.</p>
                        <p>We'll put <code rend="inline">example.txt</code> in <code rend="inline">dir</code> by typing</p>
                        <p>
                            <code rend="inline">mv example.txt dir</code>
                        </p>
                        <p>Now type <code rend="inline">gci</code> and you'll see <code rend="inline">example.txt</code> has disappeared. Move into <code rend="inline">dir</code> (<code rend="inline">sl dir</code>) and type <code rend="inline">gci</code> and you'll see it's now in there! (You can also do this without moving by just typing <code rend="inline">gci dir</code> from <code rend="inline">funWithPowerShell</code>.) Move back to <code rend="inline">funWithPowerShell</code> and put <code rend="inline">example1.txt</code> in <code rend="inline">dir1</code> and <code rend="inline">example2.txt</code> in <code rend="inline">dir2</code>.</p>
                        <p>We can also use <code rend="inline">mv</code> to <hi rend="bold">rename</hi> things. Use <code rend="inline">sl</code> to move into <code rend="inline">dir</code>. Do a quick <code rend="inline">gci</code> and you should see your <code rend="inline">example.txt</code> file. This is a boring name. Let's call it "benjamin.txt" instead. Type</p>
                        <p>
                            <code rend="inline">mv example.txt benjamin.txt</code>
                        </p>
                        <p>Use <code rend="inline">gci</code> again to confirm that your document is now called <code rend="inline">benjamin.txt</code>.</p>
                        <p>You may be surprised that the same cmdlet is used both to move and to rename files. In fact, though, the operation is the same. In both cases, you're telling the computer to change the "name" of the file's location, that is, to change the <hi rend="bold">path</hi> it follows to find the file. In the first example above, the path began as</p>
                        <p>
                            <code rend="inline">C:\Users\Ted\funWithPowerShell\example.txt</code>
                        </p>
                        <p>and changed to</p>
                        <p>
                            <code rend="inline">C:\Users\Ted\funWithPowerShell\dir\example.txt</code>
                        </p>
                        <p>In the second example, the path changed from</p>
                        <p>
                            <code rend="inline">C:\Users\Ted\funWithPowerShell\dir\example.txt</code>
                        </p>
                        <p>to</p>
                        <p>
                            <code rend="inline">C:\Users\Ted\funWithPowerShell\dir\benjamin.txt</code>
                        </p>
                        <p>In other words, in both examples, <code rend="inline">mv</code> just changed the path. Don't worry if this doesn't make sense just yet. Just be careful when you use <code rend="inline">mv</code>, because if you don't type exactly the right thing, you may rename something when you mean to move it, or vice versa.</p>
                        <p>Beyond moving files, we also want to be able to copy and delete them. To copy files, we use the cmdlet <code rend="inline">Copy-Item</code>, or <code rend="inline">cp</code>. Let's make a two copies of <code rend="inline">benjamin.txt</code>, and name them "steven.txt" and "susie.txt".</p>
                        <p>
                            <code rend="inline">cp benjamin.txt steven.txt</code>
                        </p>
                        <p>
                            <code rend="inline">cp benjamin.txt susie.txt</code>
                        </p>
                        <p>We can also delete these two new files with <code rend="inline">rm</code>, just like with directories. Try to do it with one command. As always, be careful when you use <code rend="inline">rm</code>.</p>
                        <p>Here's the command:</p>
                        <p>
                            <code rend="inline">rm steven.txt, susie.txt</code>
                        </p>
                        <p>Goodbye, Steven and Susie!</p>
                        <figure>
                            <desc>Moving, copying, and deleting</desc>
                            <graphic url="intro-to-powershell4.png"/>
                        </figure>
                    </div>
                </div>
            </div>
            <div type="1">
                <head>Doing More</head>
                <p>Okay, so now we can navigate around, make files, and move and delete them in PowerShell. We feel pretty cool and/or geeky, because we can do these things from the command line, but it's not actually useful, since we could already do these things pretty easily in the GUI. Now that we know these basics, though, we can start learning slightly more complex commands that can be useful in our work as digital humanists.</p>
                <h3>Writing to Files with <code rend="inline">Write-Output</code> (<code rend="inline">write</code>, <code rend="inline">echo</code>) and Redirection</h3>
                <p>We have an empty file in our <code rend="inline">dir</code> directory. That's not very interesting. Let's add some content. We could open the file in Notepad and modify it that way. But we can also add to it with commands right from the command line. The cmdlet we use for this is <code rend="inline">Write-Output</code>, or just <code rend="inline">write</code>.</p>
                <p>Try entering this:</p>
                <p>
                    <code rend="inline">write "The technique of reproduction detaches the reproduced object from the domain of tradition."</code>
                </p>
                <p>PowerShell should print that statement directly into the command-line window. That's all that <code rend="inline">write</code> does. It tells PowerShell "Print out whatever I write." That's not very useful, though, because we want it to put this text into our document. To do this, we'll use something called <hi rend="bold">redirection</hi>.</p>
                <p>Redirection is just a way to tell PowerShell to take the results of a command and put them somewhere other than in the PowerShell window. To redirect a command, we put a right angle bracket (<code rend="inline">&gt;</code>) between the command and the place we want its output to go. In this case, we want the output of our <code rend="inline">write</code> command to wind up in <code rend="inline">benjamin.txt</code>. So we use the up arrow to get the statement back, and add <code rend="inline">&gt; benjamin.txt</code> at the end. The whole thing should look like this:</p>
                <p>
                    <code rend="inline">write "The technique of reproduction detaches the reproduced object from the domain of tradition." &gt; benjamin.txt</code>
                </p>
                <p>When you hit enter, nothing will seem to have happened. That's because your <code rend="inline">write</code> statement was redirected. To see that something did indeed happen, use <code rend="inline">gci</code> to view the contents of your directory. Notice that the length of <code rend="inline">benjamin.txt</code> is no longer 0. That's because we just put some text in there!</p>
                <h3>Reading Files with <code rend="inline">Get-Content</code> (<code rend="inline">gc</code>, <code rend="inline">cat</code>)</h3>
                <p>While <code rend="inline">gci</code> can show us that <emph>something</emph> is in the file, it would be nice to see that it's the sentence we tried to put in there. We could do this by typing <code rend="inline">notepad benjamin.txt</code>, which would open the document in Notepad. But there is also a cmdlet for just printing the contents to PowerShell. This cmdlet is called <code rend="inline">Get-Content</code>. Enter:</p>
                <p>
                    <code rend="inline">gc benjamin.txt</code>
                </p>
                <p>There's your sentence!</p>
                <p>Using <code rend="inline">gc</code> by itself is helpful, but not that interesting. By combining it with redirection, we can do a lot more. For starters, we can put the contents of one file into another. This is a lot like copying a file. You already know how to do this with <code rend="inline">cp</code>. Make a copy of <code rend="inline">benjamin.txt</code> named <code rend="inline">benjamin1.txt</code> using <code rend="inline">cp</code>. That command will look like this:</p>
                <p>
                    <code rend="inline">cp benjamin.txt benjamin1.txt</code>
                </p>
                <p>Now, try to make <code rend="inline">benjamin2.txt</code>, with the exact same contents as <code rend="inline">benjamin.txt</code> but by using <code rend="inline">gc</code> and redirection. See if you can figure out how to do this.</p>
                <p>In case you're stumped, here's the answer:</p>
                <p>
                    <code rend="inline">gc benjamin.txt &gt; benjamin2.txt</code>
                </p>
                <p>Of course, that's just a more cumbersome way to do what we can already do with <code rend="inline">cp</code>. The difference in these methods is substantial, though, because using <code rend="inline">gc</code> we can append information to a text without replacing what is already there, and we can also get the contents of multiple texts and put them into another text.</p>
                <p>First, let's look at appending. We need something to append, so let's make a new text called <code rend="inline">next.txt</code> and write to it the sentence "By making many reproductions it substitutes a plurality of copies for a unique existence." We could make our file first with <code rend="inline">ni</code>, but we don't need to. If we tell PowerShell to write to a file that isn't there, it will make the file for us. Thus we can just enter</p>
                <p>
                    <code rend="inline">write "By making many reproductions it substitutes a plurality of copies for a unique existence." &gt; next.txt</code>
                </p>
                <p>Use <code rend="inline">gc</code> to check that <code rend="inline">next.txt</code> really is what we want it to be.</p>
                <p>Now, let's add the content of <code rend="inline">next.txt</code> to <code rend="inline">benjamin.txt</code> using <code rend="inline">gc</code> and redirection. Seems simple enough, right? Try entering</p>
                <p>
                    <code rend="inline">gc next.txt &gt; benjamin.txt</code>
                </p>
                <p>Then, check what happened with <code rend="inline">gc benjamin.txt</code>. You will see that you have indeed put the content of <code rend="inline">next.txt</code> into <code rend="inline">benjamin.txt</code>, but that you've <emph>replaced</emph> the content that was already there. This isn't what we wanted to do!</p>
                <p>Using <code rend="inline">&gt;</code>, we just told PowerShell to put the content of one text into another, and it overwrote what was already there. We can fix this by using <code rend="inline">&gt;&gt;</code> for our redirection instead of just a single <code rend="inline">&gt;</code>. This tells PowerShell to append the new information. Try this:</p>
                <p>
                    <code rend="inline">gc next.txt &gt;&gt; benjamin1.txt</code>
                </p>
                <p>Use <code rend="inline">gc</code> to see that <code rend="inline">benjamin1.txt</code> now has both sentences.</p>
                <figure>
                    <desc>The difference between `&gt;` and `&gt;&gt;`</desc>
                    <graphic url="intro-to-powershell5.png"/>
                </figure>
                <p>Now, let's see about getting the contents of multiple files at the same time.</p>
                <h3>Working with Lots of Files at Once Using Wildcards (<code rend="inline">*</code>)</h3>
                <p>You should now have four files in your directory, each with one or two sentences from Walter Benjamin's artwork essay in it. You might be losing track of what exactly is in them. Let's use <code rend="inline">gc</code> to check the contents.</p>
                <p>We could look at each one individually. As you may have guessed, though, you can display all four with one command. Enter</p>
                <p>
                    <code rend="inline">gc benjamin.txt, benjamin1.txt, benjamin2.txt, next.txt</code>
                </p>
                <p>and you'll get your sentence printed out three times. We can do this even more quickly. Try entering</p>
                <p>
                    <code rend="inline">gc *.txt</code>
                </p>
                <p>The result will be exactly the same thing. What the <code rend="inline">*.txt</code> does is tell PowerShell to find anything ending with <code rend="inline">.txt</code>. The <code rend="inline">*</code> is called a <hi rend="bold">wildcard</hi>, and can be used to replace any part of a file name. Try typing <code rend="inline">gc ben*</code>, and you'll get only the texts that begin with "ben". Since the only files in this directory are the four we want, you can even type <code rend="inline">gc *</code> and get the content we're interested in by having PowerShell get the content of <emph>everything</emph> in the directory.</p>
                <h3>Searching with <code rend="inline">Select-String</code> (<code rend="inline">sls</code>)</h3>
                <p>Of course, we don't always want to see everything. Often, we want to find specific content. Using <code rend="inline">*</code>, we can search multiple files at the same time. One of our sentences had something about "unique existence," didn't it? Where was that? We can use the <code rend="inline">Select-String</code> cmdlet to search for specific bits of text. Enter</p>
                <p>
                    <code rend="inline">sls "unique existence" *.txt</code>
                </p>
                <p>and PowerShell will spit out all the lines containing that string from any file in our directory ending in <code rend="inline">.txt</code>.</p>
                <p>Using <code rend="inline">sls</code> on files as small as ours won't save us all that much time over reading the files ourselves. But using this cmdlet with larger numbers of longer files can be extraordinarily helpful.</p>
                <h3>Infinite Loops and Aborting with <code rend="inline">control-c</code>
                </h3>
                <p>Let's look at one more useful task we can accomplish by combining <code rend="inline">gc</code>, wildcards, and redirection. Suppose we have numerous different files we want to combine together into another file, for instance because we've downloaded hundreds of song lyrics we want to analyze, and want to group all the ones by a certain artist into a single file. Although we could do this by listing them all out, i.e. <code rend="inline">gc text1, text2, text3 &gt; newtext</code>, if we have a hundred texts, this will be pretty cumbersome. This is what wildcards are for.</p>
                <p>Let's try concatenating all four of our texts and putting the result into a fifth text. Using <code rend="inline">*.txt</code> might seem a handy helper. <hi rend="bold">We are about to do something foolish, so please read the next paragraph before typing this command!</hi>
                </p>
                <p>Let's try</p>
                <p>
                    <code rend="inline">gc *.txt &gt; bigben.txt</code>
                </p>
                <p>Your computer will appear to do nothing. But unlike other times when your computer has apparently done nothing, this time, the command prompt doesn't come back up. If you try to type another command, nothing will happen. This is because PowerShell is still working on your last command. As you do more and more complicated things with PowerShell, this will sometimes happen - you're making your computer sweat! In this case, however, PowerShell will never stop working on this command, because it is in an infinite loop! Fortunately, you can abort this task with</p>
                <p>
                    <code rend="inline">control-c</code>
                </p>
                <p>Using <code rend="inline">control-c</code> like this is very handy, as you may sometimes accidentally get caught in a loop, or you may just get sick of waiting for your computer to do certain extremely long tasks.</p>
                <p>How did we just get stuck in that loop? We told PowerShell to put all files ending in <code rend="inline">.txt</code> into a new file ending in <code rend="inline">.txt</code>. Since that new file fell under the rubric of files the computer should be concatenating and adding to <code rend="inline">bigben.txt</code>, it added that one in there, too. And then, since it had a <code rend="inline">.txt</code> file with new content, it added <emph>that</emph> as well. This is a great example of something we often forget about our computers: they are not smart. Extremely powerful, yes. But totally lacking common sense. Humans look at instructions and try to <emph>interpret</emph> them. "She can't possibly mean for me to add the contents of the final text back into itself over and over again forever." Computers, on the other hand, do exactly what we tell them to, no matter how illogical our commands may be. As you gain experience working on the command line, you will often be flummoxed by your computer's overly literal interpretations of your commands, but you will also learn how to give it instructions it can follow. Infinite loops should be avoided at all costs, but they will occur, and when they do, just remember <code rend="inline">control-c</code>.</p>
                <h3>Specifying cmdlets with Parameters</h3>
                <p>We have seen that your computer needs to have things told to it in very exact ways. Fortunately, PowerShell provides methods for refining cmdlets by adding parameters.</p>
                <p>Let's look at an example. Use <code rend="inline">gci</code> and you should see that you have five files in your directory. One of them, <code rend="inline">bigben.txt</code>, is very large. Enter</p>
                <p>
                    <code rend="inline">gc bigben.txt</code>
                </p>
                <p>PowerShell will start dumping an inordinate amount of text onto the screen. You may want to abort the process with <code rend="inline">control-c</code> (this is not an infinite loop, just a really large file, so you can wait for the whole thing to print, it'll just take a while.) You can use the cmdlet <code rend="inline">clear</code> if the large block of text bothers you.</p>
                <p>What we really want to see is just that <code rend="inline">bigben.txt</code> really is comprised of the lines of the other texts, repeated over and over again. We can do this by looking only at the beginning and ending, and for this, we add a <hi rend="bold">parameter</hi> to our cmdlet.</p>
                <p>Enter this:</p>
                <p>
                    <code rend="inline">gc bigben.txt -totalcount 10</code>
                </p>
                <p>You will see the first 10 lines of your text. Make sure to include the hyphen, as otherwise PowerShell will not know that <code rend="inline">-TotalCount</code> is a parameter. Now enter</p>
                <p>
                    <code rend="inline">gc bigben.txt -tail 10</code>
                </p>
                <p>and you will see the last 10 lines. What we have done is specified our <code rend="inline">gc</code> cmdlet with the parameters <code rend="inline">-totalcount</code> and <code rend="inline">-tail</code>. Almost all cmdlets can be refined by adding parameters like this. But how do we know what parameters are available?</p>
                <h3>Finding out more with <code rend="inline">Get-Help</code>
                </h3>
                <p>PowerShell does not expect you to memorize all the possible parameters for all the cmdlets. Instead, it provides an easy way to list them off using the cmdlet <code rend="inline">Get-Help</code>. Enter</p>
                <p>
                    <code rend="inline">Get-Help gc</code>
                </p>
                <p>and you'll get a screen that looks like this:</p>
                <figure>
                    <desc>Help page for `Get-Content`</desc>
                    <graphic url="intro-to-powershell6.png"/>
                </figure>
                <p>Your page may be slightly different, but the important part to look at right now is the section labeled "SYNTAX." This shows us all of the parameters we can add to <code rend="inline">Get-Content</code>. If you're just trying to remember the exact name of a parameter you've used before, this will be enough to jog your memory. But it doesn't tell us what the parameters actually do.</p>
                <p>Fortunately, <code rend="inline">Get-Help</code> itself has parameters, and by adding <code rend="inline">-online</code> to your <code rend="inline">Get-Help</code> cmdlet, you tell PowerShell to ask your browser to open a page on Microsoft's TechNet portal that explains all the parameters in plain English. Enter</p>
                <p>
                    <code rend="inline">Get-Help gc -online</code>
                </p>
                <figure>
                    <desc>The online help page for `Get-Content`</desc>
                    <graphic url="intro-to-powershell7.png"/>
                </figure>
                <p>Here we can see the actual description of the parameters <code rend="inline">-TotalCount</code> and <code rend="inline">-Tail</code>.</p>
                <h3>Solving the Infinite Loop Problem with the <code rend="inline">-exclude</code> Parameter</h3>
                <p>Look again at the help for <code rend="inline">Get-Content</code>, and you'll see that one of the possible parameters is <code rend="inline">-exclude</code>. This sounds promising for dealing with our infinite loop problem! The description online reads: "Omits the specified items. The value of this parameter qualifies the <hi rend="bold">Path</hi> parameter. Enter a path element or pattern, such as '*.txt'. Wildcards are permitted." This sounds <emph>very</emph> promising. The "Path parameter" is (usually) the thing you write immediately after your cmdlet. It tells PowerShell where to apply the cmdlet. When we type <code rend="inline">gc benjamin.txt</code>, <code rend="inline">benjamin.txt</code> is the path. It is actually shorthand for <code rend="inline">.\benjamin.txt</code>, which in turn is shorthand for <code rend="inline">C:\Users\YOURUSERNAME\funWithPowerShell\dir\benjamin.txt</code>. That line tells your computer the path to follow through the tree-like structure of your file system in order to find the file you want. What help is telling us, then, is that we can omit specified items from our <code rend="inline">gc</code> cmdlet by adding the parameter <code rend="inline">-exclude</code> and then entering the path we want it to exclude. We can use this to take the contents of all of our <code rend="inline">.txt</code> files and put them into a new file without creating an infinite loop. See if you can figure out what to type, using what we did with <code rend="inline">-totalcount</code> and <code rend="inline">-tail</code> as a reference.</p>
                <p>Here's what I did. I first deleted my current bigben.txt with <code rend="inline">rm</code>. (This isn't really necessary, since using a single <code rend="inline">&gt;</code> on my redirect will replace the current contents anyway, but it's nice to have a clean start!) Then I entered</p>
                <p>
                    <code rend="inline">gc *.txt -exclude bigben.txt &gt; bigben.txt</code>
                </p>
                <p>Voila!</p>
                <p>Throughout this process, we've been adding texts together, or concatenating them. You can learn more about <ref target="https://en.wikipedia.org/wiki/Concatenation">concatenation from Wikipedia</ref>, and if you want to see a few more examples of concatenation using PowerShell, check out this <ref target="https://blogs.technet.microsoft.com/heyscriptingguy/2014/07/15/keep-your-hands-clean-use-powershell-to-glue-strings-together">blog entry</ref>, which will take you into the wonderful world of variables, something beyond the scope of this tutorial, but well worth learning about.</p>
                <h3>Getting Even More out of cmdlets with Piping</h3>
                <p>So now we have five documents in our directory. In order to be able to do really useful things with them, we need one more tool: <hi rend="bold">Piping</hi>. Piping is sort of like redirection, but instead of telling PowerShell to put the results of a cmdlet somewhere else, it tells it to take the output of one cmdlet and use it as the input for another. Where we use <code rend="inline">&gt;</code> for redirection, for piping we use <code rend="inline">|</code>.</p>
                <p>We are going to get even more mileage out of <code rend="inline">gc</code>, this time by piping its results to the cmdlet <code rend="inline">measure-object</code> (or just <code rend="inline">measure</code>). This latter cmdlet measures various properties. For our purposes, we will use it to get the number of lines, words, and characters in our files by adding the parameters <code rend="inline">-line</code>, <code rend="inline">-word</code>, and <code rend="inline">-character</code>, or just <code rend="inline">-l</code>, <code rend="inline">-w</code>, <code rend="inline">-c</code>. (With parameters, you only need to type as much of the name as necessary to identify the parameter in question. Use <code rend="inline">Get-Help</code> to figure out what that will be for a given cmdlet.)</p>
                <p>Enter this:</p>
                <p>| <code rend="inline">gc benjamin.txt | measure -l -w -c</code> |</p>
                <p>You should get a count of the lines, words, and characters in the text. Of course, you could do this easily enough with your word processor. The power of working on the command-line comes from being able to manipulate lots of things at once and being able to specify what we want done with extra precision. In this example, this means we can count words in multiple of our files at once, and that we can add additional parameters to specify exactly how we want to count them.</p>
                <p>See if you can get a count for the lines, words, and characters in all the files. It should be no surprise to you that the wildcard (<code rend="inline">*</code>) can help you here. For instance, you could enter</p>
                <p>| <code rend="inline">gc *.txt | measure -l -w -c</code> |</p>
                <p>With our five small files, this still doesn't result in much, but it would have taken longer using the word processor, and we could also do it with a directory containing thousands of lengthy files. We can also control our actions more precisely with additional parameters. Use <code rend="inline">Get-Help measure</code> to see the parameters at your disposal. We could go to the online help to learn more about them, but for now let's just use one that's self-explanatory as an example: <code rend="inline">-IgnoreWhiteSpace</code>.</p>
                <p>Use the up-arrow to get your last command back, and add <code rend="inline">-ignorewhitespace</code> to the end. (You can also just type <code rend="inline">-ig</code>, but <code rend="inline">-i</code> alone is not sufficient, because it doesn't differentiate the <code rend="inline">-IgnoreWhiteSpace</code> parameter from the <code rend="inline">-InputObject</code> parameter, as a helpful error message will tell you if you try it.) You'll see the same count, but with fewer characters, because this time PowerShell didn't count the spaces. The advantage of precision is clear over using a word processor, where it is difficult to determine whether or not white space is being ignored in the first place, let alone to toggle the feature.</p>
                <h2>Using Command-Line Tools and Running Python Scripts</h2>
                <p>The most important reason to become familiar with using the command line is not because of the increased precision or the ability to work with multiple files, useful as these features are, but rather because of the many additional tools you gain access to, as mentioned in the introduction. When getting set up to work with some of these tools, you may run into problems because Windows sometimes configures the paths incorrectly. Fixing this problem requires setting environment variables, a topic beyond the scope of this tutorial. Fortunately, there is a lot of support out there, and a little searching will usually turn up the solution you need. Because many lessons on <emph>The Programming Historian</emph> require you to use Python, let's look briefly at getting Python set up. Having done this, you will be less daunted by instructions for setting environment variables for other programs.</p>
                <p>If you don't already have Python, or if you wonder why you would want to use it, check out the <ref target="/lessons/introduction-and-installation">Python tutorial</ref> right here on <emph>The Programming Historian</emph>. In that tutorial, you will learn to set up Python to run scripts directly in an editor. It will often be more useful to be able to run scripts from the command line. In order to do that, we need to set an environment variable. First, you need to know the name of the directory where Python is installed on your computer. Enter <code rend="inline">sl C:\</code> and then use <code rend="inline">gci</code>. You should see a directory named "Python" with the version number at the end. On my computer, the directory is "Python27." Now we tell Windows to create a Path variable pointing to that directory by entering this into PowerShell, replacing "Python27" with the name of the directory on your computer:</p>
                <p>
                    <code rend="inline">[Environment]::SetEnvironmentVariable("Path", "$env:Path;C:\Python27", "User")</code>
                </p>
                <p>This tells Windows: "Hey, the path for Python is C:\Python27." If you want to understand exactly how this works, look at <ref target="https://technet.microsoft.com/en-us/library/ff730964.aspx">this page</ref> on Microsoft's TechNet portal (the same portal you get to using the <code rend="inline">-online</code> parameter with <code rend="inline">Get-Help</code>).</p>
                <p>Once you've entered the command above, exit PowerShell and start it again. You should now be able to start the Python interpreter by typing <code rend="inline">python</code> into PowerShell. To run scripts, you simply type <code rend="inline">python</code> followed by the path for the script you want. It's easiest to first navigate to the directory with the script in it, and then just enter <code rend="inline">python script-name.py</code>.</p>
                <p>Now you're all set up to run Python scripts from the command line!</p>
            </div>
            <div type="1">
                <head>Conclusion</head>
                <p>In this tutorial, you've learned some of the basics of working with PowerShell, the command-line interface on Windows. You now know enough to use PowerShell for many of the day-to-day tasks you do on your computer, and I would recommend using it for just that. At first, you may find it more difficult to copy a file and move it to a new directory from the command line, but the more you practice, the more natural it will become. Eventually, you will be very comfortable working in PowerShell, and will be able to do many tasks more easily this way.</p>
                <p>Although we have only had a glimpse of what PowerShell can do, you now have enough basic knowledge to learn to do more. There are lots of helpful resources online, and they are yours for the googling! It is also helpful to know that a lot of discussions about using the command line will be based on Unix and other *nix systems. In most cases, if you just type the names of the commands they are using together with "PowerShell" into a search engine, you will find the corresponding PowerShell cmdlet.</p>
                <p>The more you use PowerShell, the easier it will be, and the more you will learn to unlock capabilities you did not even know your computer had! Eventually, you will see how constraining your GUI has been. You won't stop using it, but you will find yourself starting up PowerShell more and more often to break free from these constraints, and utilize your computer more fully. Your computer is like a pocket knife. The GUI only allows you to open a few blades. With the command line, you can open them all!</p>
            </div>
            <head>Quick Reference</head>
            <p>This table serves as a quick reference to all the cmdlets discussed in this lesson. The first column shows the actual name; the second shows what you will normally type instead. The Bash equivalent shows the most similar command in Bash. Unless this command is in parentheses, it can also be used in PowerShell as an alias for the corresponding cmdlet. (Linux and OS X users, please see the note below.) For a more complete explanation of any of the cmdlets, use <code rend="inline">Get-Help</code> with the <code rend="inline">-online</code> parameter (e.g. <code rend="inline">Get-Help Get-ChildItem -online</code>.)</p>
            <table>
                <row>
                    <cell role="label">Cmdlet</cell>
                    <cell role="label">Alias</cell>
                    <cell role="label">Bash Equivalent</cell>
                    <cell role="label">Description</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Get-ChildItem</code>
                    </cell>
                    <cell>
                        <code rend="inline">gci</code>
                    </cell>
                    <cell>
                        <code rend="inline">ls</code>
                    </cell>
                    <cell>List the directories and files in the current location.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Set-Location</code>
                    </cell>
                    <cell>
                        <code rend="inline">sl</code>
                    </cell>
                    <cell>
                        <code rend="inline">cd</code>
                    </cell>
                    <cell>Change to the directory at the given path. Typing <code rend="inline">..</code> rather than a path will move up one directory.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Push-Location</code>
                    </cell>
                    <cell>
                        <code rend="inline">pushd</code>
                    </cell>
                    <cell>
                        <code rend="inline">pushd</code>
                    </cell>
                    <cell>Changes to the directory.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Pop-Location</code>
                    </cell>
                    <cell>
                        <code rend="inline">popd</code>
                    </cell>
                    <cell>
                        <code rend="inline">popd</code>
                    </cell>
                    <cell>Changes back to the previous directory after using <code rend="inline">pushd</code>
                    </cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">New-Item</code>
                    </cell>
                    <cell>
                        <code rend="inline">ni</code>
                    </cell>
                    <cell>(<code rend="inline">touch</code>)</cell>
                    <cell>Creates a new item. Used with no parameter, the item is by default a file. Using <code rend="inline">mkdir</code> is a shortcut for including the parameter <code rend="inline">-ItemType dir</code>.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">mkdir</code>
                    </cell>
                    <cell>none</cell>
                    <cell>
                        <code rend="inline">mkdir</code>
                    </cell>
                    <cell>Creates a new directory. (See <code rend="inline">New-Item</code>.)</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Explorer</code>
                    </cell>
                    <cell>none</cell>
                    <cell>(<code rend="inline">open</code>)</cell>
                    <cell>Open something using File Explorer (the GUI)</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Remove-Item</code>
                    </cell>
                    <cell>
                        <code rend="inline">rm</code>
                    </cell>
                    <cell>
                        <code rend="inline">rm</code>
                    </cell>
                    <cell>Deletes something. Permanently!</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Move-Item</code>
                    </cell>
                    <cell>
                        <code rend="inline">mv</code>
                    </cell>
                    <cell>
                        <code rend="inline">mv</code>
                    </cell>
                    <cell>Moves something. Takes two arguments - first a filename (i.e. its present path), then a path for its new location (including the name it should have there). By not changing the path, it can be used to rename files.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Copy-Item</code>
                    </cell>
                    <cell>
                        <code rend="inline">cp</code>
                    </cell>
                    <cell>
                        <code rend="inline">cp</code>
                    </cell>
                    <cell>Copies a file to a new location. Takes same arguments as move, but keeps the original file in its location.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Write-Output</code>
                    </cell>
                    <cell>
                        <code rend="inline">write</code>
                    </cell>
                    <cell>
                        <code rend="inline">echo</code>
                    </cell>
                    <cell>Outputs whatever you type. Use redirection to output to a file. Redirection with <code rend="inline">&gt;&gt;</code> will add to the file, rather than overwriting contents.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Get-Content</code>
                    </cell>
                    <cell>
                        <code rend="inline">gc</code>
                    </cell>
                    <cell>
                        <code rend="inline">cat</code>
                    </cell>
                    <cell>Gets the contents of a file and prints it to the screen. Adding the parameter <code rend="inline">-TotalCount</code> followed by a number x prints only the first x lines. Adding the parameter <code rend="inline">-Tail</code> followed by a number x prints only the final x lines.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Select-String</code>
                    </cell>
                    <cell>
                        <code rend="inline">sls</code>
                    </cell>
                    <cell>(<code rend="inline">grep</code>)</cell>
                    <cell>Searches for specific content.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Measure-Object</code>
                    </cell>
                    <cell>
                        <code rend="inline">measure</code>
                    </cell>
                    <cell>(<code rend="inline">wc</code>)</cell>
                    <cell>Gets statistical information about an object. Use <code rend="inline">Get-Content</code> and pipe the output to <code rend="inline">Measure-Object</code> with the parameters <code rend="inline">-line</code>, <code rend="inline">-word</code>, and <code rend="inline">-character</code> to get word count information.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">&gt;</code>
                    </cell>
                    <cell>none</cell>
                    <cell>
                        <code rend="inline">&gt;</code>
                    </cell>
                    <cell>Redirection. Puts the output of the command to the left of <code rend="inline">&gt;</code> into a file to the right of <code rend="inline">&gt;</code>.</cell>
                </row>
                <row>
                    <cell>`</cell>
                    <cell>`</cell>
                    <cell>none</cell>
                    <cell>`</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Get-Help</code>
                    </cell>
                    <cell>none</cell>
                    <cell>
                        <code rend="inline">man</code>
                    </cell>
                    <cell>Gets the help file for a cmdlet. Adding the parameter <code rend="inline">-online</code> opens the help page on TechNet.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">exit</code>
                    </cell>
                    <cell>none</cell>
                    <cell>
                        <code rend="inline">exit</code>
                    </cell>
                    <cell>Exits PowerShell</cell>
                </row>
            </table>
            <p>Remember the keyboard shortcuts of <code rend="inline">tab</code> for auto-completion and the up and down arrows to scroll through recent commands. These shortcuts can save a lot of typing!</p>
            <p>
                <emph>A note to Linux and OS X users</emph>: Although many Bash commands work in PowerShell, they often don't do exactly the same thing. They may take different parameters, and the syntax may be slightly different. (Technically, they never do the same thing, as PowerShell commands produce objects, whereas Bash commands produce text.) However, the similarity of their actions offers a handy crutch for quickly getting up and running with PowerShell, and a little help from the <code rend="inline">Get-Help</code> cmdlet (you can just type <code rend="inline">man</code> like in Bash) will usually resolve any confusion.</p>
        </body>
    </text>
</TEI>
