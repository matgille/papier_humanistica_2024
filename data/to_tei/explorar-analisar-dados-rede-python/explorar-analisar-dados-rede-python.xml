<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:id="explorar-analisar-dados-rede-python">
  <teiHeader>
 <fileDesc>
  <titleStmt>
   <title>Explorar e Analisar Dados de Rede com Python</title>
  <author role="original_author"><persName>John R. Ladd</persName><persName>Jessica Otis</persName><persName>Christopher N. Warren</persName><persName>Scott Weingart</persName></author><editor role="reviewers"><persName>Elisa Beshero-Bondar</persName><persName>Anne Chao</persName><persName>Qiwei Li</persName></editor><author role="translators">Jo&#227;o Domingues Pereira</author><editor role="translation-reviewers"><persName>Josir Cardoso Gomes</persName><persName>Daniel Alves</persName></editor><editor role="editors">Brandon Walsh</editor></titleStmt>
  <publicationStmt>
   <idno type="doi">10.46430/phpt0041</idno><date type="published">06/16/2017</date><date type="translated">05/12/2023</date><p>Lesson reviewed and published in Programming Historian.</p>
  </publicationStmt>
  <sourceDesc>
  <p>Born digital, in a markdown format. Original file: <ref type="original_file" target="#exploring-and-analyzing-network-data-with-python"/>.</p><p>There are other translations: <ref target=""/></p></sourceDesc>
 </fileDesc>
 <profileDesc><abstract><p>Esta li&#231;&#227;o introduz m&#233;tricas de rede e como tirar conclus&#245;es das mesmas quando se trabalha com dados de Humanidades. O leitor aprender&#225; como usar o pacote NetworkX do Python para produzir e trabalhar com estas estat&#237;sticas de rede.</p></abstract><textClass><keywords><term xml:lang="en">network-analysis</term><term xml:lang="en">data-visualization</term></keywords></textClass></profileDesc>
</teiHeader>
  <text xml:lang="pt">
    <body>
      <div type="1"><head>Introdu&#231;&#227;o</head>
<div type="2"><head>Objetivos da Li&#231;&#227;o</head>
<p>Neste tutorial, o leitor ir&#225; aprender:</p>
<list type="unordered">
<item>A usar o pacote <ref target="https://perma.cc/F574-RREU"><hi rend="bold">NetworkX</hi></ref> para trabalhar com dados de rede em <ref target="/pt/licoes/introducao-instalacao-python"><hi rend="bold">Python</hi></ref>; e</item>
<item>
A analisar dados de rede de Humanidades para encontrar:<list type="unordered">
<item>Estruturas de rede e comprimentos de caminho,</item>
<item>N&#243;s importantes ou centrais, e</item>
<item>Comunidades e subgrupos.</item>
</list>
</item>
</list>
<p><hi rend="bold">n.b.</hi>: Este &#233; um tutorial para explorar estat&#237;sticas e m&#233;tricas de rede. Assim sendo, iremos focar-nos em maneiras de analisar e tirar conclus&#245;es a partir de redes sem visualiz&#225;-las. Provavelmente, o leitor querer&#225; uma combina&#231;&#227;o de visualiza&#231;&#227;o e m&#233;tricas de rede no seu pr&#243;prio projeto, e, por isso, n&#243;s recomendamos este artigo como um complemento a <ref target="/en/lessons/creating-network-diagrams-from-historical-sources">este tutorial anterior do <emph>Programming Historian</emph></ref> (em ingl&#234;s)<ref type="footnotemark" target="#note_1"/>.</p>
</div><div type="2"><head>Pr&#233;-Requisitos</head>
<p>Este tutorial assume que o leitor:</p>
<list type="unordered">
<item>Tem uma familiaridade b&#225;sica com redes e/ou leu <ref target="/en/lessons/creating-network-diagrams-from-historical-sources"><emph>From Hermeneutics to Data to Networks: Data Extraction and Network Visualization of Historical Sources</emph></ref> (em ingl&#234;s), de Marten D&#252;ring, aqui no <emph>Programming Historian</emph>;</item>
<item>Instalou o Python 3, n&#227;o o Python 2 que &#233; nativamente instalado em sistemas operacionais com base no Unix, como os Macs (se precisar de assist&#234;ncia com a instala&#231;&#227;o do Python 3, veja <ref target="https://perma.cc/DP2N-B4EN">The Hitchhiker's Guide to Python</ref> (em ingl&#234;s); e</item>
<item>Instalou o instalador de pacotes <code rend="inline">pip</code><ref type="footnotemark" target="#note_2"/>.</item>
</list>
<p>&#201; poss&#237;vel ter duas vers&#245;es do Python (2 <emph>e</emph> 3) instaladas no seu computador ao mesmo tempo. Por esta raz&#227;o, ao aceder ao Python 3, o leitor frequentemente ter&#225; que o declarar explicitamente digitando <code rend="inline">python3</code> e <code rend="inline">pip3</code> em vez de simplesmente <code rend="inline">python</code> e <code rend="inline">pip</code>. Consulte os tutoriais do <emph>Programming Historian</emph> sobre a <ref target="/pt/licoes/introducao-instalacao-python">instala&#231;&#227;o do Python</ref> e o <ref target="/pt/licoes/instalacao-modulos-python-pip">uso do pip</ref> para mais informa&#231;&#245;es<ref type="footnotemark" target="#note_3"/>.</p>
</div><div type="2"><head>O Que o Leitor Pode Aprender a Partir dos Dados de Rede?</head>
<p>H&#225; muito que as redes interessam aos pesquisadores nas Humanidades, mas muitos acad&#233;micos recentes progrediram dum interesse grandemente qualitativo e metaf&#243;rico em links e conex&#245;es para um s&#233;quito mais formal de ferramentas quantitativas para estudar mediadores, <emph>hubs</emph> (n&#243;s importantes) e estruturas interconectadas. Como o soci&#243;logo Mark S. Granovetter apontou no seu importante artigo de maio de 1973 <ref target="https://perma.cc/A4PC-WPKN"><emph>The Strength of Weak Ties</emph></ref> (em ingl&#234;s), raramente &#233; suficiente notar que duas pessoas estavam conectadas uma &#224; outra. Fatores como a sua rela&#231;&#227;o estrutural com outras pessoas e se essas pessoas adicionais estavam, elas pr&#243;prias, conectadas umas &#224;s outras t&#234;m influ&#234;ncia decisiva nos eventos. Na medida em que at&#233; o mais perspicaz dos acad&#233;micos tem dificuldade em perceber, digamos, o contorno geral duma rede (a sua "Topologia" de rede) e em identificar os n&#243;s mais significativos para conectar grupos, a an&#225;lise quantitativa de rede oferece aos acad&#233;micos um modo de transitar relativamente fluidamente entre o objeto social de larga escala (o "grafo") e as particularidades minuciosas das pessoas e la&#231;os sociais.</p>
<p>Este tutorial ir&#225; ajud&#225;-lo a responder quest&#245;es como:</p>
<list type="unordered">
<item>Qual &#233; a estrutura geral da rede?</item>
<item>Quem s&#227;o as pessoas importantes, ou <emph>hubs</emph>, na rede?</item>
<item>Quais s&#227;o os subgrupos e comunidades na rede?</item>
</list>
</div><div type="2"><head>O Nosso Exemplo: a Sociedade dos Amigos</head>
<p>Antes que existissem amigos do Facebook, havia a Sociedade dos Amigos, conhecida como os <emph>quakers</emph>. Fundados na Inglaterra em meados do s&#233;culo XVII, os <emph>quakers</emph> eram crist&#227;os protestantes que divergiram da oficial Igreja da Inglaterra e que promoviam uma ampla toler&#226;ncia religiosa, preferindo a suposta "luz interior" (<emph>inner light</emph>; <hi rend="bold">nota de tradu&#231;&#227;o</hi>: este conceito tinha uma extrema import&#226;ncia na Teologia <emph>quaker</emph>) e as consci&#234;ncias dos crist&#227;os &#224; ortodoxia imposta pelo Estado. O n&#250;mero de <emph>quakers</emph> cresceu rapidamente de meados para os finais do s&#233;culo XVII e os seus membros espalharam-se pelas Ilhas Brit&#226;nicas, pela Europa e pelas col&#244;nias do Novo Mundo---especialmente pela Pensilv&#226;nia, fundada pelo l&#237;der <emph>quaker</emph> William Penn e lar dos quatro autores.</p>
<p>Visto que os acad&#233;micos h&#225; muito que ligam o crescimento e a persist&#234;ncia dos <emph>quakers</emph> &#224; efic&#225;cia das suas redes, os dados usados neste tutorial s&#227;o uma lista de nomes e rela&#231;&#245;es entre os primevos <emph>quakers</emph> do s&#233;culo XVII. Este <emph>dataset</emph> &#233; derivado do <ref target="http://www.oxforddnb.com"><emph>Oxford Dictionary of National Biography</emph></ref> (em ingl&#234;s) e do trabalho em progresso do projeto <ref target="http://www.sixdegreesoffrancisbacon.com"><emph>Six Degrees of Francis Bacon</emph></ref> (em ingl&#234;s), o qual est&#225; a reconstruir as redes sociais da Gr&#227;-Bretanha moderna (1500-1700).</p>
</div></div>
      <div type="1"><head>Prepara&#231;&#227;o dos Dados e Instala&#231;&#227;o do NetworkX</head>
<p>Antes de iniciar este tutorial, o leitor precisar&#225; de fazer o download de dois ficheiros que, combinados, constituem o <emph>dataset</emph> da nossa rede. O ficheiro <ref target="/assets/exploring-and-analyzing-network-data-with-python/quakers_nodelist.csv">quakers_nodelist.csv</ref> &#233; uma lista de <emph>quakers</emph> modernos (n&#243;s) e o ficheiro <ref target="/assets/exploring-and-analyzing-network-data-with-python/quakers_edgelist.csv">quakers_edgelist.csv</ref> &#233; uma lista de rela&#231;&#245;es entre esses <emph>quakers</emph> (<emph>edges</emph>). Para fazer o download destes ficheiros, basta clicar com o bot&#227;o direito do <emph>mouse</emph> nos <emph>links</emph> e escolher "Guardar liga&#231;&#227;o como".</p>
<p>Ser&#225; extremamente &#250;til ao leitor familiarizar-se com a estrutura do <emph>dataset</emph> antes de continuar. Para mais informa&#231;&#245;es sobre a estrutura geral dos <emph>datasets</emph> de rede, veja <ref target="/en/lessons/creating-network-diagrams-from-historical-sources#developing-a-coding-scheme">este tutorial</ref> (em ingl&#234;s). Quando o leitor abrir o ficheiro de n&#243;s no programa da sua escolha, ver&#225; que cada <emph>quaker</emph> &#233; primeiramente identificado pelo seu <emph>name</emph> (nome). Cada n&#243; dum <emph>quaker</emph> tamb&#233;m tem um n&#250;mero de atributos associados, incluindo <emph>historical significance</emph> (em portugu&#234;s, significado hist&#243;rico), <emph>gender</emph> (em portugu&#234;s, g&#233;nero), <emph>birth</emph>/<emph>death dates</emph> (em portugu&#234;s, datas de nascimento/morte), e o SDFB ID---um identificador num&#233;rico exclusivo que lhe permitir&#225; cruzar n&#243;s neste <emph>dataset</emph> com o <emph>dataset</emph> original do <emph>Six Degrees of Francis Bacon</emph>, se desejado. Aqui est&#227;o as primeiras linhas:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_0" corresp="code_explorar-analisar-dados-rede-python_0.txt" rend="block"/></ab>
<p>Note que, embora as colunas n&#227;o estejam corretamente alinhadas como ocorre numa tabela de dados, as v&#237;rgulas mant&#234;m tudo apropriadamente separado.</p>
<p>Quando o leitor abrir o ficheiro de <emph>edges</emph>, ver&#225; que n&#243;s usamos os <emph>names</emph> do ficheiro de n&#243;s para identificar os n&#243;s conectados por cada <emph>edge</emph>. Estas <emph>edges</emph> come&#231;am num n&#243; <emph><hi rend="bold">source</hi></emph> (em portugu&#234;s, origem) e acabam num n&#243; <emph><hi rend="bold">target</hi></emph> (em portugu&#234;s, destino). Embora esta linguagem derive das chamadas estruturas de rede <hi rend="bold">direcionadas</hi>, n&#243;s usaremos os nossos dados como uma rede <hi rend="bold">n&#227;o direcionada</hi>: se a Pessoa A conhece a Pessoa B, ent&#227;o a Pessoa B tamb&#233;m deve conhecer a Pessoa A. Nas redes direcionadas, as rela&#231;&#245;es n&#227;o precisam de ser rec&#237;procas (a Pessoa A pode enviar uma carta &#224; B sem receber uma em troca), mas nas redes n&#227;o direcionadas as conex&#245;es s&#227;o sempre rec&#237;procas, ou <hi rend="bold">sim&#233;tricas</hi>. Uma vez que esta &#233; uma rede de quem conhecia quem ao inv&#233;s de, digamos, uma rede epistolar, um conjunto de rela&#231;&#245;es n&#227;o direcionadas &#233; o mais apropriado. As rela&#231;&#245;es sim&#233;tricas nas redes n&#227;o direcionadas s&#227;o &#250;teis sempre que estiver preocupado com rela&#231;&#245;es que definem o mesmo papel para ambas as partes. Dois amigos t&#234;m uma rela&#231;&#227;o sim&#233;trica: cada um deles &#233; um amigo do outro. O autor e o destinat&#225;rio duma carta t&#234;m uma rela&#231;&#227;o assim&#233;trica porque cada um tem um papel diferente. Tanto as redes direcionadas como as n&#227;o direcionadas t&#234;m os seus pr&#243;prios recursos (e, por vezes, as suas pr&#243;prias m&#233;tricas), e o leitor querer&#225; escolher aquela que melhor se adapta aos tipos de rela&#231;&#245;es que est&#225; a registrar e &#224;s quest&#245;es que quer clarificar. Aqui est&#227;o as primeiras <emph>edges</emph> na rede <emph>quaker</emph> n&#227;o direcionada:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_1" corresp="code_explorar-analisar-dados-rede-python_1.txt" rend="block"/></ab>
<p>Agora que fez o download dos dados <emph>quakers</emph> e viu como est&#227;o estruturados, est&#225; na hora de come&#231;ar a trabalhar com esses dados no Python. Assim que tanto o Python como o pip estiverem instalados (ver Pr&#233;-Requisitos, acima), querer&#225; instalar o NetworkX, digitando isto na sua <ref target="/en/lessons/intro-to-bash">linha de comandos</ref> (em ingl&#234;s):<ref type="footnotemark" target="#note_4"/></p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_2" corresp="code_explorar-analisar-dados-rede-python_2.txt" lang="language-python" rend="block"/></ab>
<p>Uma nota curta sobre controle de vers&#227;o: este tutorial usa NetworkX 3.1, mas a biblioteca est&#225; em desenvolvimento ativo e &#233; atualizada com frequ&#234;ncia. Recomendamos usar o comando de instala&#231;&#227;o acima para garantir que a sua vers&#227;o do NetworkX corresponde ao c&#243;digo abaixo (em vez de simplesmente instalar a vers&#227;o mais recente). Se j&#225; tiver uma vers&#227;o mais antiga do NetworkX instalada, execute <code rend="inline">pip3 install networkx==3.1 --upgrade</code> antes de tentar o tutorial<ref type="footnotemark" target="#note_5"/>.</p>
<p>Est&#225; feito! Est&#225; preparado para come&#231;ar a codificar.</p>
</div>
      <div type="1"><head>Come&#231;ando</head>
<h2>Ler Ficheiros, Importar Dados</h2>
<p>Inicie um novo ficheiro de texto simples, em branco, no mesmo diret&#243;rio que os seus ficheiros de dados chamado <code rend="inline">quaker_network.py</code> (para mais detalhes sobre a instala&#231;&#227;o e execu&#231;&#227;o do Python, ver <ref target="/pt/licoes/instalacao-windows">este tutorial</ref>). No topo desse ficheiro, importe as bibliotecas de que precisa. O leitor precisar&#225; de tr&#234;s bibliotecas---aquela que acab&#225;mos de instalar, e duas bibliotecas incorporadas no Python. Pode digitar:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_3" corresp="code_explorar-analisar-dados-rede-python_3.txt" lang="language-python" rend="block"/></ab>
<p>Agora pode ordenar ao programa para ler os seus ficheiros de CSV e retirar os dados de que precisa. Ironicamente, ler ficheiros e reorganizar os dados geralmente requer um c&#243;digo mais complexo que as fun&#231;&#245;es para executar uma an&#225;lise de redes sociais, portanto pedimos que tenha paci&#234;ncia connosco ao longo deste primeiro bloco de c&#243;digo. Aqui est&#225; um conjunto de comandos para abrir e ler os ficheiros das nossas listas de n&#243;s e de <emph>edges</emph>:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_4" corresp="code_explorar-analisar-dados-rede-python_4.txt" lang="language-python" rend="block"/></ab>
<p>Este c&#243;digo executa fun&#231;&#245;es similares &#224;s <ref target="/pt/licoes/trabalhando-ficheiros-texto-python">deste tutorial</ref>, mas usa o m&#243;dulo CSV para carregar os seus n&#243;s e <emph>edges</emph>. Mais tarde, o leitor voltar&#225; a atuar sobre os dados e obter&#225; mais informa&#231;&#227;o sobre os n&#243;s, mas, por agora, precisa de duas coisas: a lista completa de n&#243;s e uma lista de pares <emph>edges</emph> (como &#233;nuplos de n&#243;s)<ref type="footnotemark" target="#note_6"/>. Estas s&#227;o as formas de que o NetworkX precisar&#225; para criar um "objeto grafo", um tipo de dados especial do NetworkX sobre o qual o leitor aprender&#225; na pr&#243;xima sec&#231;&#227;o.</p>
<p>Nesta fase, antes de come&#231;ar a usar o NetworkX, o leitor pode fazer algumas verifica&#231;&#245;es de sanidade b&#225;sicas para se certificar que os seus dados foram corretamente carregados usando fun&#231;&#245;es e m&#233;todos incorporados no Python. Digitando:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_5" corresp="code_explorar-analisar-dados-rede-python_5.txt" lang="language-python" rend="block"/></ab>
<p>e:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_6" corresp="code_explorar-analisar-dados-rede-python_6.txt" lang="language-python" rend="block"/></ab>
<p>e, depois, executando o seu <emph>script</emph> lhe mostrar&#225; quantos n&#243;s e <emph>edges</emph> carregou com sucesso no Python. Se o leitor vir 119 n&#243;s e 174 <emph>edges</emph>, ent&#227;o tem todos os dados necess&#225;rios.</p>
<h2>No&#231;&#245;es B&#225;sicas do NetworkX: Criar o Grafo</h2>
<p>Agora o leitor tem os seus dados como duas listas do Python: uma lista de n&#243;s (<code rend="inline">node_names</code>) e uma lista de <emph>edges</emph> (<code rend="inline">edges</code>). No NetworkX, o leitor pode juntar estas duas listas num s&#243; objeto rede que compreende como os n&#243;s e as <emph>edges</emph> se relacionam. Este objeto &#233; chamado de <hi rend="bold">Grafo</hi>, referindo-se a um dos termos comuns para dados organizados como uma rede <hi rend="bold">n.b.</hi>: n&#227;o se refere a alguma representa&#231;&#227;o visual dos dados. Aqui, grafo &#233; usado puramente num sentido matem&#225;tico, de an&#225;lise de rede. Primeiro, o leitor deve <emph>inicializar</emph> um objeto Grafo com o seguinte comando:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_7" corresp="code_explorar-analisar-dados-rede-python_7.txt" lang="language-python" rend="block"/></ab>
<quote>
<p><hi rend="bold">Nota de tradu&#231;&#227;o</hi>: em ingl&#234;s, 'gr&#225;fico' pode ser traduzido como '<emph>graphic</emph>' ou, de forma diminutiva, como '<emph>graph</emph>', que tamb&#233;m pode significar 'grafo', o termo aqui referido. Esta homografia n&#227;o ocorre no portugu&#234;s.</p>
</quote>
<p>Isto criar&#225; um novo objeto grafo, <emph>G</emph>, com nada nele. Agora, o leitor pode adicionar as suas listas de n&#243;s e de <emph>edges</emph> assim:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_8" corresp="code_explorar-analisar-dados-rede-python_8.txt" lang="language-python" rend="block"/></ab>
<p>Esta &#233; uma de v&#225;rias maneiras de adicionar dados a um objeto rede. O leitor pode verificar a <ref target="https://perma.cc/3QVU-FLPF">documenta&#231;&#227;o do NetworkX</ref> (em ingl&#234;s) para obter mais informa&#231;&#245;es sobre como adicionar <emph>weighted edges</emph>, ou adicionar n&#243;s e <emph>edges</emph> uma de cada vez.</p>
<p>Finalmente, o leitor pode obter informa&#231;&#227;o b&#225;sica sobre a sua rede rec&#233;m-criada usando a fun&#231;&#227;o <code rend="inline">info</code>:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_9" corresp="code_explorar-analisar-dados-rede-python_9.txt" lang="language-python" rend="block"/></ab>
<p>A fun&#231;&#227;o <code rend="inline">info</code> informa o tipo da sua rede (neste caso, &#233; um objeto Graph padr&#227;o) e o n&#250;mero de n&#243;s e arestas na mesma. O <emph>output</emph> deve ser parecido a este:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_10" corresp="code_explorar-analisar-dados-rede-python_10.txt" rend="block"/></ab>
<p>Esta &#233; uma forma r&#225;pida de obter informa&#231;&#227;o geral sobre o seu grafo, mas como o leitor aprender&#225; em sec&#231;&#245;es subsequentes, est&#225; apenas a passar pela superf&#237;cie do que o NetworkX lhe pode indicar sobre os seus dados.</p>
<p>Para recapitular, de momento o seu <emph>script</emph> ser&#225; semelhante a isto:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_11" corresp="code_explorar-analisar-dados-rede-python_11.txt" lang="language-python" rend="block"/></ab>
<p>At&#233; agora, o leitor leu dados de n&#243;s e de <emph>edges</emph> no Python a partir de ficheiros CSV, e, depois, contou esses n&#243;s e <emph>edges</emph>. Depois disso, o leitor criou um objeto grafo usando o NetworkX e carregou os seus dados para esse objeto.</p>
<h2>Adicionar Atributos</h2>
<p>Para o NetworkX, um objeto grafo &#233; uma coisa grande (a sua rede) composta por dois tipos de coisas mais pequenas (os seus n&#243;s e as suas <emph>edges</emph>). At&#233; agora, o leitor carregou n&#243;s e <emph>edges</emph> (como pares de n&#243;s), mas o NetworkX permite-lhe adicionar <emph>atributos</emph> tanto aos n&#243;s como &#224;s <emph>edges</emph>, providenciando mais informa&#231;&#227;o sobre cada um deles. Mais &#224; frente neste tutorial, o leitor executar&#225; m&#233;tricas e adicionar&#225; alguns dos resultados de volta ao Grafo como atributos. Por agora, vamos certificar-nos que o seu Grafo cont&#233;m todos os atributos que est&#227;o atualmente no seu CSV.</p>
<p>O leitor querer&#225; retornar a uma lista que criou no in&#237;cio do seu <emph>script</emph>: <code rend="inline">nodes</code>. Esta lista cont&#233;m todas as linhas do <code rend="inline">quakers_nodelist.csv</code>, incluindo colunas para o <emph>name</emph>, a <emph>historical significance</emph>, o <emph>gender</emph>, o <emph>birth year</emph>, o <emph>death year</emph> e o SDFB ID. O leitor querer&#225; iterar por esta lista e adicionar esta informa&#231;&#227;o ao nosso grafo. Existem algumas maneiras de fazer isto, mas o NetworkX providencia duas fun&#231;&#245;es convenientes para adicionar atributos a todos os n&#243;s e <emph>edges</emph> dum Grafo duma s&#243; vez: <code rend="inline">nx.set_node_attributes()</code> e <code rend="inline">nx.set_edge_attributes()</code>. Para usar estas fun&#231;&#245;es, o leitor ir&#225; precisar que os seus dados de atributos estejam na forma dum <emph>dicion&#225;rio</emph> Python, no qual os nomes dos n&#243;s s&#227;o as <emph>chaves</emph> e os atributos que quer adicionar s&#227;o os <emph>valores</emph><ref type="footnotemark" target="#note_7"/>. O leitor querer&#225; criar um dicion&#225;rio para cada um dos seus atributos, e, depois, adicion&#225;-los usando as fun&#231;&#245;es acima. A primeira coisa que o leitor deve fazer &#233; criar cinco dicion&#225;rios em branco, usando chavetas:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_12" corresp="code_explorar-analisar-dados-rede-python_12.txt" lang="language-python" rend="block"/></ab>
<p>Agora n&#243;s podemos fazer o <emph>loop</emph> atrav&#233;s da nossa lista de <code rend="inline">nodes</code> e adicionar os itens apropriados a cada dicion&#225;rio. N&#243;s fazemos isto sabendo antecipadamente a posi&#231;&#227;o, ou <emph>&#237;ndice</emph>, de cada atributo. Porque o nosso ficheiro <code rend="inline">quaker_nodelist.csv</code> est&#225; bem organizado, n&#243;s sabemos que o <emph>name</emph> da pessoa ser&#225; sempre o primeiro item no lista: &#237;ndice 0, visto que come&#231;amos sempre a contar do 0 no Python. A <emph>historical significance</emph> da pessoa ser&#225; o &#237;ndice 1, o seu <emph>gender</emph> ser&#225; o &#237;ndice 2, e assim por diante. Portanto, n&#243;s podemos construir os nossos dicion&#225;rios desta forma<ref type="footnotemark" target="#note_8"/> :</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_13" corresp="code_explorar-analisar-dados-rede-python_13.txt" lang="language-python" rend="block"/></ab>
<p>Agora o leitor tem um conjunto de dicion&#225;rios que pode usar para adicionar atributos a n&#243;s no seu objeto Grafo. A fun&#231;&#227;o <code rend="inline">set_node_attributes</code> toma tr&#234;s vari&#225;veis: o Grafo ao qual o leitor est&#225; a adicionar o atributo, o dicion&#225;rio de pares id-atributo, e o nome do novo atributo. O c&#243;digo para adicionar os seus seis atributos assemelha-se a isto:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_14" corresp="code_explorar-analisar-dados-rede-python_14.txt" lang="language-python" rend="block"/></ab>
<p>Agora todos os seus n&#243;s t&#234;m estes seis atributos, e o leitor pode aceder a eles a qualquer momento. Por exemplo, o leitor pode obter todos os <emph>birth years</emph> dos seus n&#243;s iterando por eles e acedendo ao atributo <code rend="inline">birth_year</code>, assim:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_15" corresp="code_explorar-analisar-dados-rede-python_15.txt" lang="language-python" rend="block"/></ab>
<p>A partir desta instru&#231;&#227;o, o leitor obter&#225; uma linha de <emph>output</emph> para cada n&#243; na rede. Deve parecer-se como uma simples lista de nomes e anos:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_16" corresp="code_explorar-analisar-dados-rede-python_16.txt" rend="block"/></ab>
<p>Os passos acima s&#227;o um m&#233;todo comum para adicionar atributos a n&#243;s que o leitor usar&#225; repetidamente mais tarde neste tutorial. Aqui est&#225; uma recapitula&#231;&#227;o do bloco de c&#243;digo desta sec&#231;&#227;o:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_17" corresp="code_explorar-analisar-dados-rede-python_17.txt" lang="language-python" rend="block"/></ab>
<p>Agora o leitor aprendeu como criar um objeto Grafo e adicionar atributos ao mesmo. Nesta pr&#243;xima sec&#231;&#227;o, o leitor aprender&#225; sobre uma variedade de m&#233;tricas dispon&#237;veis no NetworkX e como aceder &#224;s mesmas. Mas relaxe, acabou de aprender o maior parte do c&#243;digo de que precisar&#225; para o resto do tutorial!</p>
</div>
      <div type="1"><head>M&#233;tricas Dispon&#237;veis no NetworkX</head>
<p>Quando o leitor come&#231;a a trabalhar num novo <emph>dataset</emph>, &#233; uma boa ideia obter uma vis&#227;o geral dos dados. A primeira etapa, descrita acima, consiste simplesmente em abrir os ficheiros e ver o que est&#225; l&#225; dentro. Porque &#233; uma rede, o leitor sabe que existir&#227;o n&#243;s e <emph>edges</emph>, mas quantos de cada um existem? Que informa&#231;&#227;o est&#225; anexada a cada n&#243; ou <emph>edge</emph>?</p>
<p>No nosso caso, existem 174 <emph>edges</emph> e 119 n&#243;s. Estas <emph>edges</emph> n&#227;o t&#234;m dire&#231;&#245;es (isto &#233;, existe uma rela&#231;&#227;o sim&#233;trica entre pessoas), nem incluem informa&#231;&#227;o adicional. Para os n&#243;s, n&#243;s sabemos os seus <emph>names</emph>, a sua <emph>historical significance</emph>, o seu <emph>genders</emph>, a sua <emph>birth date</emph> e <emph>death date</emph>, e o SDFB ID.</p>
<p>Estes detalhes informam o que o leitor pode ou devia fazer com o seu <emph>dataset</emph>. Muitos poucos n&#243;s (digamos, 15), e uma an&#225;lise de rede &#233; menos &#250;til que desenhar uma imagem ou fazer algumas leituras; Demasiadas (digamos, 15 milh&#245;es), e o leitor deveria considerar come&#231;ar com um subconjunto ou encontrar um supercomputador.</p>
<p>As propriedades da rede tamb&#233;m guiam a sua an&#225;lise. Porque esta rede &#233; <hi rend="bold">n&#227;o direcionada</hi>, a sua an&#225;lise tem que usar m&#233;tricas que exigem <emph>edges</emph> sim&#233;tricas entre n&#243;s. Por exemplo, o leitor pode determinar em que comunidades as pessoas se encontram, mas n&#227;o pode determinar as rotas <emph>direcionais</emph> pelas quais a informa&#231;&#227;o poder&#225; fluir ao longo da rede (precisaria duma rede direcionada para isso). Ao usar as rela&#231;&#245;es sim&#233;tricas e n&#227;o direcionadas neste caso, o leitor ser&#225; capaz de encontrar subcomunidades e as pessoas que s&#227;o importantes nessas comunidades, um processo que seria mais dif&#237;cil (embora ainda que poss&#237;vel) com uma rede direcionada. O NetworkX permite-lhe realizar a maior parte das an&#225;lises que o leitor pode conceber, mas deve compreender as possibilidades do seu <emph>dataset</emph> e perceber que alguns logaritmos do NetworkX s&#227;o mais apropriados do que outros.</p>
<h3>O Formato da Rede</h3>
<p>Ap&#243;s ver a apar&#234;ncia do <emph>dataset</emph>, &#233; importante ver a apar&#234;ncia da <emph>rede</emph>. Estas s&#227;o coisas diferentes. O <emph>dataset</emph> &#233; uma representa&#231;&#227;o abstrata do que o leitor assume serem conex&#245;es entre entidades; a rede &#233; a instancia&#231;&#227;o espec&#237;fica dessas suposi&#231;&#245;es. A rede, pelo menos neste contexto, &#233; como o computador, l&#234; as conex&#245;es que o leitor codificou num <emph>dataset</emph>. A rede tem uma <ref target="https://perma.cc/8M84-GESG">Topologia</ref>, ou uma forma conectiva, que pode ser centralizada ou descentralizada; densa ou esparsa; c&#237;clica ou linear. Um <emph>dataset</emph> n&#227;o tem, fora da estrutura da tabela na qual est&#225; digitado.</p>
<p>O formato e as propriedades b&#225;sicas da rede ir&#227;o dar-lhe uma ideia sobre com o que est&#225; a trabalhar e que an&#225;lises parecem razo&#225;veis. O leitor j&#225; sabe o n&#250;mero de n&#243;s e de <emph>edges</emph>, mas a que a rede se 'assemelha'? Os n&#243;s agrupam-se, ou est&#227;o espalhados de forma regular? Existem estruturas complexas, ou cada n&#243; est&#225; organizado numa linha reta?</p>
<p>A visualiza&#231;&#227;o abaixo, criada na ferramenta de visualiza&#231;&#227;o de redes <ref target="https://gephi.org/">Gephi</ref>, lhe dar&#225; uma ideia da Topologia desta rede<ref type="footnotemark" target="#note_9"/>. O leitor poderia criar um gr&#225;fico similar no Palladio usando <ref target="/en/lessons/creating-network-diagrams-from-historical-sources">este tutorial</ref> (em ingl&#234;s).</p>
<figure><desc>Visualiza&#231;&#227;o de rede baseada em for&#231;a dos dados *quakers*, criado no Gephi.</desc><graphic url="exploring-and-analyzing-network-data-with-python-1.png"/></figure>
<p>Existem v&#225;rias formas de visualizar uma rede, e um <ref target="https://perma.cc/AM7G-BTWV"><emph>layout</emph> baseado em for&#231;a</ref> (em ingl&#234;s), do qual a imagem acima &#233; um exemplo, encontra-se entre as mais comuns. Grafos baseados em for&#231;a tentam encontrar o posicionamento ideal para n&#243;s com uma calcula&#231;&#227;o baseada na <ref target="https://perma.cc/2RTL-CYVL">tens&#227;o de cordas segundo a Lei de Hooke</ref> (em ingl&#234;s), a qual, para grafos mais pequenos, normalmente cria visualiza&#231;&#245;es limpas e de leitura f&#225;cil. A visualiza&#231;&#227;o embutida acima mostra-lhe que existe um &#250;nico grande <hi rend="bold">componente</hi> de n&#243;s conectados (no centro) e v&#225;rios componentes pequenos com apenas uma ou duas conex&#245;es nas periferias. Esta &#233; uma estrutura de rede relativamente comum. Sabendo que existem m&#250;ltiplos componentes na rede ir&#225; limitar de forma &#250;til as calcula&#231;&#245;es que o leitor querer&#225; realizar nela. Ao dispor o n&#250;mero de conex&#245;es (conhecidas como <hi rend="bold">grau</hi>, ver abaixo) como o tamanho dos n&#243;s, a visualiza&#231;&#227;o tamb&#233;m mostra que existem alguns n&#243;s com muitas conex&#245;es que mant&#234;m o componente central intricado. Estes grandes n&#243;s s&#227;o conhecidos como <emph><hi rend="bold">hubs</hi></emph>, e o facto de eles aparecem t&#227;o claramente aqui d&#225;-lhe uma pista em rela&#231;&#227;o ao que o leitor encontrar&#225; quando medir a <hi rend="bold">centralidade</hi> na pr&#243;xima sec&#231;&#227;o.</p>
<p>Visualiza&#231;&#245;es, no entanto, apenas o levam at&#233; certo ponto. Com quantas mais redes trabalhar, mais o leitor se aperceber&#225; que a maior parte parece similar o suficiente ao ponto de ser dif&#237;cil distinguir uma da outra. M&#233;tricas quantitativas deixam-no diferenciar redes, aprender sobre as suas Topologias, e tornar uma confus&#227;o de n&#243;s e <emph>edges</emph> em algo a partir do qual se pode aprender.</p>
<p>Uma boa m&#233;trica com a qual come&#231;ar &#233; a <hi rend="bold">densidade</hi> de rede. Isto &#233;, simplesmente, o r&#225;cio de <emph>edges</emph> reais na rede face a todas as <emph>edges</emph> poss&#237;veis na rede. Numa rede n&#227;o direcionada como esta, <emph>poderia</emph> haver uma &#250;nica <emph>edge</emph> entre quaisquer dois n&#243;s, mas como o leitor viu na visualiza&#231;&#227;o, apenas algumas dessas <emph>edges</emph> poss&#237;veis est&#227;o realmente presentes. A densidade de rede d&#225;-lhe uma ideia r&#225;pida do qu&#227;o intimamente pr&#243;xima a sua rede &#233;.</p>
<p>E as boas not&#237;cias s&#227;o que muitas destas m&#233;tricas requerem comandos simples e unilineares no Python. Daqui para a frente, o leitor pode continuar a construir o seu bloco de c&#243;digo das sec&#231;&#245;es anteriores. O leitor n&#227;o tem de apagar nada que j&#225; tenha digitado, e porque criou o seu objeto rede <code rend="inline">G</code> no bloco de c&#243;digo acima, todas as m&#233;tricas a partir daqui devem trabalhar corretamente.</p>
<p>O leitor pode calcular a densidade da rede executando <code rend="inline">nx.density(G)</code>. No entanto, a melhor maneira de fazer isto &#233; armazenar a sua m&#233;trica numa vari&#225;vel para refer&#234;ncia futura, e imprimir essa vari&#225;vel, como:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_18" corresp="code_explorar-analisar-dados-rede-python_18.txt" lang="language-python" rend="block"/></ab>
<p>O <emph>output</emph> da densidade &#233; um n&#250;mero, ent&#227;o &#233; isso que o leitor ver&#225; quando imprimir o valor. Neste caso, a densidade da nossa rede &#233;, aproximadamente, 0.0248. Numa escala de 0 a 1, n&#227;o &#233; uma rede muito densa, o que confere com o que o leitor consegue ver na visualiza&#231;&#227;o<ref type="footnotemark" target="#note_10"/>. Um 0 significaria que n&#227;o existem quaisquer conex&#245;es de todo, e um 1 indicaria que todas as <emph>edges poss&#237;veis</emph> est&#227;o presentes (uma rede perfeitamente conectada): esta rede <emph>quaker</emph> est&#225; na extremidade inferior dessa escala, mas, mesmo assim, longe do 0.</p>
<p>Uma medida de caminho mais curta &#233; um pouco mais complexa. Ela calcula a s&#233;rie mais curta poss&#237;vel de n&#243;s e <emph>edges</emph> que se situam entre quaisquer dois n&#243;s, algo dif&#237;cil de ver em visualiza&#231;&#245;es de grandes redes. Esta medida corresponde, essencialmente, a encontrar amigos de amigos---se a minha m&#227;e conhece algu&#233;m que eu n&#227;o conhe&#231;o, ent&#227;o a minha m&#227;e &#233; o caminho mais curto entre mim e essa pessoa. O jogo <emph>Six Degrees of Kevin Bacon</emph>, a partir do qual o <ref target="http://sixdegreesoffrancisbacon.com/">nosso projeto</ref> (em ingl&#234;s) retira o nome, &#233; basicamente um jogo que consiste em encontrar os caminhos mais curtos (com um <hi rend="bold">comprimento de caminho</hi> de seis ou menos) de Kevin Bacon a qualquer outro ator.</p>
<p>Para calcular um caminho mais curto, o leitor precisa de passar por v&#225;rias vari&#225;veis de <emph>input</emph> (informa&#231;&#227;o que d&#225; a uma fun&#231;&#227;o do Python): o grafo inteiro, o seu n&#243; <emph>source</emph>, e o seu n&#243; <emph>target</emph>. Vamos procurar o caminho mais curto entre Margaret Fell e George Whitehead. Como us&#225;mos nomes para identificar unicamente os nossos n&#243;s nesta rede, o leitor pode aceder a esses n&#243;s (como a <emph><hi rend="bold">source</hi></emph> e o <emph><hi rend="bold">target</hi></emph> do seu caminho) usando os nomes diretamente.</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_19" corresp="code_explorar-analisar-dados-rede-python_19.txt" lang="language-python" rend="block"/></ab>
<p>Dependendo do tamanho da sua rede, isto pode demorar algum tempo para calcular, visto que o Python primeiro encontra todos os caminhos poss&#237;veis e depois escolhe o mais curto. O <emph>output</emph> de <code rend="inline">shortest_path</code> ser&#225; uma lista dos n&#243;s que inclu&#237; a "source" (Fell), o "target" (Whitehead), e os n&#243;s entre eles. Neste caso, n&#243;s podemos ver que o fundador dos <emph>quakers</emph>, George Fox, se encontra no caminho mais curto entre eles. Como Fox &#233; tamb&#233;m um <emph><hi rend="bold">hub</hi></emph> (ver centralidade de grau, abaixo) com muitas conex&#245;es, n&#243;s podemos supor que v&#225;rios caminhos mais curtos passam por ele como mediador. O que &#233; que isto pode indicar sobre a import&#226;ncia dos fundadores dos <emph>quakers</emph> para a sua rede social?</p>
<p>O Python inclu&#237; v&#225;rias ferramentas que calculam os caminhos mais curtos. Existem fun&#231;&#245;es para os comprimentos dos caminhos mais curtos, para todos os caminhos mais curtos, e para saber se um caminho existe ou n&#227;o de todo na <ref target="https://perma.cc/3MJE-7MQQ">documenta&#231;&#227;o</ref> (em ingl&#234;s). O leitor poderia usar uma fun&#231;&#227;o separada para encontrar o comprimento do caminho <emph>Fell-Whitehead</emph> que acab&#225;mos de calcular, ou poderia simplesmente tomar o comprimento da lista menos um<ref type="footnotemark" target="#note_11"/>, assim:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_20" corresp="code_explorar-analisar-dados-rede-python_20.txt" lang="language-python" rend="block"/></ab>
<p>Existem muitas m&#233;tricas de rede derivadas dos comprimentos de caminho mais curtos. Uma tal medida &#233; o <hi rend="bold">di&#226;metro</hi>, que &#233; o mais longo de todos os caminhos mais curtos. Depois de calcular todos os caminhos mais curtos entre cada par de n&#243;s poss&#237;vel na rede, o di&#226;metro &#233; o comprimento do caminho entre os dois n&#243;s que est&#227;o mais afastados. A medida est&#225; projetada para lhe dar um senso do tamanho geral da rede, a dist&#226;ncia duma extremidade da rede &#224; outra.</p>
<p>O di&#226;metro usa um comando simples: <code rend="inline">nx.diameter(G)</code>. No entanto, executar este comando no grafo <emph>quaker</emph> dar&#225; uma mensagem de erro indicando que o Grafo n&#227;o est&#225; conectado ("<emph>not connected</emph>"). Isto significa apenas que o seu grafo, como o leitor j&#225; viu, tem mais que um componente. Porque existem alguns n&#243;s que n&#227;o t&#234;m um caminho de todo com outros, &#233; imposs&#237;vel encontrar todos os caminhos mais curtos. Veja novamente a visualiza&#231;&#227;o do seu grafo:</p>
<figure><desc>Visualiza&#231;&#227;o de rede baseada em for&#231;a dos dados *quakers*, criado no Gephi.</desc><graphic url="exploring-and-analyzing-network-data-with-python-1.png"/></figure>
<p>Como n&#227;o h&#225; caminho entre n&#243;s dum componente e n&#243;s doutro, <code rend="inline">nx.diameter()</code> retorna a mensagem de erro "<emph>not connected</emph>". O leitor pode remediar isto, primeiro, ao descobrir se o seu Grafo est&#225; conectado ("<emph>is connected</emph>") (<emph>i.e.</emph> tudo um componente) e, se n&#227;o conectado, descobrir apenas o componente mais largo e calcular o di&#226;metro somente desse componente. Aqui est&#225; o c&#243;digo:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_21" corresp="code_explorar-analisar-dados-rede-python_21.txt" lang="language-python" rend="block"/></ab>
<p>Como n&#243;s tom&#225;mos o componente mais largo, n&#243;s podemos assumir que n&#227;o h&#225; nenhum di&#226;metro mais largo para os outros componentes. Portanto, esta figura &#233; uma boa representa&#231;&#227;o para o di&#226;metro de todo o Grafo. O di&#226;metro de rede do componente mais largo desta rede &#233; 8: existe um comprimento de rede de 8 entre os dois n&#243;s mais afastados na rede. Ao contr&#225;rio da densidade, que &#233; apresentada de 0 a 1, &#233; dif&#237;cil saber a partir deste n&#250;mero somente se 8 &#233; um di&#226;metro largo ou curto. Para algumas m&#233;tricas globais, pode ser melhor compar&#225;-lo a redes de tamanho e forma similar<ref type="footnotemark" target="#note_12"/>.</p>
<p>O c&#225;lculo estrutural final que o leitor far&#225; nesta rede concerne o conceito de <hi rend="bold">fechamento tri&#225;dico</hi>. Fechamento tri&#225;dico sup&#245;e que se duas pessoas conhecem a mesma pessoa, elas provavelmente conhecem-se mutuamente. Se Fox conhece tanto Fell como Whitehead, ent&#227;o Fell e Whitehead podem perfeitamente conhecer-se mutuamente, completando um <hi rend="bold">tri&#226;ngulo</hi> na visualiza&#231;&#227;o de tr&#234;s <emph>edges</emph> conectando Fox, Fell e Whitehead. O n&#250;mero destes tri&#226;ngulos fechados na rede pode ser usado para descobrir aglomerados e comunidades de indiv&#237;duos que se conhecem todos intimamente.</p>
<p>Uma forma de medir o fechamento tri&#225;dico &#233; o chamado <hi rend="bold">coeficiente de aglomera&#231;&#227;o</hi> por causa desta tend&#234;ncia aglomeradora, mas a medida estrutural de rede que o leitor aprender&#225; &#233; conhecida como <hi rend="bold">transitividade</hi><ref type="footnotemark" target="#note_13"/>. Transitividade &#233; o r&#225;cio de todos os tri&#226;ngulos sobre todos os tri&#226;ngulos poss&#237;veis. Um tri&#226;ngulo poss&#237;vel existe quando uma pessoa (Fox) conhece duas pessoas (Fell e Whitehead). Ent&#227;o, transitividade, como a densidade, expressa qu&#227;o interconectado um grafo &#233; em termos dum r&#225;cio de conex&#245;es reais sobre as poss&#237;veis. Lembre-se, medidas como a transitividade e a densidade lidam com <emph>probabilidades</emph> e n&#227;o com <emph>certezas</emph>. Todos os <emph>outputs</emph> do seu <emph>script</emph> no Python devem ser interpretados, como qualquer outro objeto de pesquisa. A transitividade permite-lhe uma forma de pensar sobre todas as rela&#231;&#245;es no seu grafo que <emph>podem</emph> existir, mas que, atualmente, n&#227;o existem.</p>
<p>O leitor pode calcular a transitividade numa s&#243; linha, da mesma forma que calculou a densidade:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_22" corresp="code_explorar-analisar-dados-rede-python_22.txt" lang="language-python" rend="block"/></ab>
<p>Tal como a densidade, transitividade &#233; numerada de 0 a 1, e o leitor pode ver que a transitividade da rede &#233; de cerca de 0.1694, um valor um pouco mais alto que o da sua densidade de 0.0248. Porque o grafo n&#227;o &#233; muito denso, existem menos <emph>tri&#226;ngulos poss&#237;veis</emph>, o que pode resultar numa transitividade relativamente mais elevada. Isto &#233;, n&#243;s que j&#225; t&#234;m v&#225;rias conex&#245;es far&#227;o provavelmente parte destes tri&#226;ngulos fechados. Para suportar isto, o leitor querer&#225; saber mais sobre n&#243;s com muitas conex&#245;es.</p>
<h2>Centralidade</h2>
<p>Depois de obter algumas medidas b&#225;sicas da estrutura da rede inteira, um bom pr&#243;ximo passo &#233; descobrir quais n&#243;s s&#227;o os mais importantes na sua rede. Na an&#225;lise de redes, medidas da import&#226;ncia dos n&#243;s s&#227;o referidas como medidas de <hi rend="bold">centralidade</hi>. Porque existem v&#225;rias maneiras de abordar a quest&#227;o "Que n&#243;s s&#227;o os mais importantes?",  existem v&#225;rias formas diferentes de calcular a centralidade. Aqui, o leitor aprender&#225; sobre as tr&#234;s medidas de centralidade mais comuns: o grau, a centralidade de intermedia&#231;&#227;o, e a centralidade adjacente.</p>
<p>O <hi rend="bold">grau</hi> &#233; a forma mais simples e comum de encontrar n&#243;s importantes. O grau dum n&#243; &#233; a soma das suas <emph>edges</emph>. Se um n&#243; tem tr&#234;s linhas a estenderem-se a outros n&#243;s, o seu grau &#233; de tr&#234;s. Cinco <emph>edges</emph>, o seu grau &#233; de cinco. &#201; extremamente simples. Como cada uma dessas edges ter&#225; sempre um n&#243; na outra extremidade, o leitor pode pensar no grau como o n&#250;mero de pessoas &#224;s quais qualquer pessoa est&#225; diretamente conectada. Os n&#243;s com os graus mais elevados numa rede social s&#227;o as pessoas que conhecem mais pessoas. Estes n&#243;s s&#227;o geralmente referidos como <emph><hi rend="bold">hubs</hi></emph>, e calcular o grau &#233; a forma mais r&#225;pida de identificar os <emph>hubs</emph>.</p>
<p>Calcular a centralidade para cada n&#243; no NetworkX n&#227;o &#233; exatamente t&#227;o simples como as m&#233;tricas de toda a rede acima, mas continua a envolver comandos unilineares. Todos os comandos de centralidade que o leitor aprender&#225; nesta sec&#231;&#227;o produzem dicion&#225;rios nos quais as chaves s&#227;o os n&#243;s e os valores s&#227;o as medidas de centralidade. Isto significa que eles est&#227;o prontos para adicionar de volta &#224; nossa rede como um atributo de n&#243;, como o leitor fez na &#250;ltima sec&#231;&#227;o. Comece por calcular o grau e adicione-o como um atributo &#224; sua rede.</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_23" corresp="code_explorar-analisar-dados-rede-python_23.txt" lang="language-python" rend="block"/></ab>
<p>O leitor acabou de executar o m&#233;todo <code rend="inline">G.degree()</code> na lista completa de n&#243;s na sua rede (<code rend="inline">G.nodes()</code>). Como o leitor adicionou-o como um atributo, agora pode ver o grau de William Penn, bem como com o resto da sua informa&#231;&#227;o se aceder ao seu n&#243; diretamente:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_24" corresp="code_explorar-analisar-dados-rede-python_24.txt" lang="language-python" rend="block"/></ab>
<p>Mas estes resultados s&#227;o &#250;teis para mais do que simplesmente adicionar atributos ao seu objeto Grafo. Como o leitor j&#225; est&#225; no Python, pode organizar e compar&#225;-los. O leitor pode usar a fun&#231;&#227;o incorporada <code rend="inline">sorted()</code> para organizar um dicion&#225;rio com as suas chaves ou valores e encontrar o <emph>top</emph> vinte dos n&#243;s por grau. Para fazer isto, o leitor vai precisar de usar <code rend="inline">itemgetter</code>, o qual n&#243;s import&#225;mos no in&#237;cio do tutorial. Usando <code rend="inline">sorted</code> e <code rend="inline">itemgetter</code>, pode organizar o dicion&#225;rio de graus assim:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_25" corresp="code_explorar-analisar-dados-rede-python_25.txt" lang="language-python" rend="block"/></ab>
<p>Aqui, h&#225; muitas coisas a acontecer nos bastidores, mas concentre-se s&#243; nas tr&#234;s vari&#225;veis de <emph>input</emph> que o leitor deu a <code rend="inline">sorted()</code>. A primeira &#233; o dicion&#225;rio, <code rend="inline">degree_dict.items()</code>, que quer organizar. A segunda &#233; o que organizar por: neste caso, item "1" &#233; o segundo item no par, ou o valor do seu dicion&#225;rio. Finalmente, o leitor diz a <code rend="inline">sorted()</code> para ir em <code rend="inline">reverse</code> para que os n&#243;s de grau mais elevado apare&#231;am primeiro na lista resultante. Assim que o leitor tiver criado esta lista organizada, pode iterar por ela e usar a <emph>list slicing</emph><ref type="footnotemark" target="#note_6"/> para obter somente os primeiros 20 n&#243;s:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_26" corresp="code_explorar-analisar-dados-rede-python_26.txt" lang="language-python" rend="block"/></ab>
<p>Como o leitor pode ver, o grau de Penn &#233; 18, relativamente elevado para esta rede. Mas digitar estas informa&#231;&#245;es de classifica&#231;&#227;o ilustra as limita&#231;&#245;es do grau como uma medida de centralidade. O leitor provavelmente n&#227;o precisava que o NetworkX lhe dissesse que William Penn, l&#237;der <emph>quaker</emph> e fundador da Pensilv&#226;nia, era importante. A maioria das redes sociais ter&#227;o somente alguns <emph>hubs</emph> de grau muito elevado, com o resto de grau similar e baixo<ref type="footnotemark" target="#note_14"/>. O grau pode inform&#225;-lo sobre os maiores <emph>hubs</emph>, mas n&#227;o pode dizer-lhe muito sobre o resto dos n&#243;s. E, em muitos casos, esses <emph>hubs</emph> sobre os quaiso est&#225; a informar (como o Penn ou como a cofundadora do Quakerismo, Margaret Fell, com um grau de 13) n&#227;o s&#227;o especialmente surpreendentes. Neste caso, quase todos os <emph>hubs</emph> s&#227;o fundadores da religi&#227;o ou, noutros casos, figuras pol&#237;ticas importantes.</p>
<p>Felizmente, existem outras medidas de centralidade que lhe podem dizer mais do que s&#243; os <emph>hubs</emph>. A <ref target="https://perma.cc/VF28-JDCR">centralidade adjacente</ref> (em ingl&#234;s) &#233; um tipo de extens&#227;o do grau---analisa uma combina&#231;&#227;o dos <emph>edges</emph> dum n&#243; e as <emph>edges</emph> dos vizinhos desse n&#243;. Centralidade adjacente preocupa-se se um n&#243; &#233; um <emph>hub</emph>, mas tamb&#233;m se preocupa com quantos <emph>hubs</emph> um n&#243; est&#225; conectado. &#201; calculado como um valor de 0 a 1: quanto mais pr&#243;ximo do um, maior a centralidade. A centralidade adjacente &#233; &#250;til para compreender que n&#243;s podem obter informa&#231;&#227;o a outros n&#243;s rapidamente. Se o leitor conhece muitas pessoas bem-conectadas, poderia espalhar uma mensagem muito eficientemente. Se o leitor usou o Google, ent&#227;o est&#225; j&#225; mais ou menos familiarizado com a centralidade adjacente. O seu algoritmo de PageRank usa uma extens&#227;o desta f&#243;rmula para decidir que p&#225;ginas de internet s&#227;o colocadas no topo da lista de resultados.</p>
<p>A <ref target="https://perma.cc/C55J-7XAJ">centralidade de intermedia&#231;&#227;o</ref> (em ingl&#234;s) &#233; um pouco diferente das outras duas calcula&#231;&#245;es na medida em que n&#227;o se preocupa com o n&#250;mero de <emph>edges</emph> que qualquer n&#243; ou grupo de n&#243;s tem. A centralidade de intermedia&#231;&#227;o observa todos os <hi rend="bold">caminhos mais curtos</hi> que passam por um n&#243; em particular (ver acima). Para fazer isto, tem que primeiro calcular todos os poss&#237;veis caminhos mais curtos na sua rede, por isso mantenha em mente que a centralidade de intermedia&#231;&#227;o vai demorar mais tempo para calcular que as outras medidas de centralidade (mas n&#227;o ser&#225; um problema num <emph>dataset</emph> desta dimens&#227;o). A centralidade de intermedia&#231;&#227;o, que tamb&#233;m &#233; expressa numa escala de 0 a 1, &#233; particularmente boa a encontrar n&#243;s que conectam duas partes distintas duma rede. Se o leitor &#233; a &#250;nica coisa conectando dois aglomerados, cada comunica&#231;&#227;o entre esses aglomerados tem que passar por si. Em contraste com um <emph>hub</emph>, este tipo de n&#243; &#233; regularmente referido como um <emph><hi rend="bold">broker</hi></emph>. A centralidade de intermedia&#231;&#227;o n&#227;o &#233; a &#250;nica maneira de encontrar <emph>brokerage</emph> (e outros m&#233;todos s&#227;o mais sistem&#225;ticos), mas &#233; uma forma r&#225;pida de lhe dar uma ideia de quais n&#243;s s&#227;o importantes, n&#227;o porque t&#234;m muitas conex&#245;es eles pr&#243;prios, mas porque eles situam-se <emph>entre</emph> grupos, dando &#224; rede conectividade e coes&#227;o.</p>
<p>Estas duas medidas de centralidade s&#227;o ainda mais simples de executar que um grau---eles n&#227;o precisam de receber uma lista de n&#243;s, s&#243; o grafo <code rend="inline">G</code>. O leitor pode execut&#225;-las com estas fun&#231;&#245;es:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_27" corresp="code_explorar-analisar-dados-rede-python_27.txt" lang="language-python" rend="block"/></ab>
<p>O leitor pode organizar a centralidade de intermedia&#231;&#227;o (ou a adjacente) ao mudar os nomes das vari&#225;veis no c&#243;digo organizador acima, como:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_28" corresp="code_explorar-analisar-dados-rede-python_28.txt" lang="language-python" rend="block"/></ab>
<p>O leitor notar&#225; que muitos, mas n&#227;o todos, dos n&#243;s que t&#234;m graus elevados tamb&#233;m t&#234;m uma centralidade de intermedia&#231;&#227;o alta. De facto, centralidade de intermedia&#231;&#227;o apresenta duas mulheres, Elizabeth Leavens e Mary Penington, cuja import&#226;ncia tinha sido obscurecida pela m&#233;trica da centralidade de grau. Uma vantagem de fazer estes c&#225;lculos no Python &#233; que o leitor pode rapidamente comparar dois conjuntos de c&#225;lculos. E se o leitor quiser saber quais dos n&#243;s com alta centralidade de intermedia&#231;&#227;o t&#234;m graus baixos? Isto &#233; o mesmo que dizer: quais n&#243;s de alta intermedia&#231;&#227;o s&#227;o inesperados? Pode usar uma combina&#231;&#227;o da lista organizada acima:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_29" corresp="code_explorar-analisar-dados-rede-python_29.txt" lang="language-python" rend="block"/></ab>
<p>O leitor pode confirmar a partir destes resultados que algumas pessoas, como Leavens e Penington, t&#234;m alta centralidade de intermedia&#231;&#227;o, mas baixo grau. Isto pode significar que estas mulheres eram <emph>brokers</emph> importantes, conectando partes d&#237;spares do grafo. O leitor tamb&#233;m pode aprender coisas inesperadas sobre pessoas sobre as quais j&#225; se sabe algo---nesta lista, consegue ver que Penn tem um grau inferior ao do fundador <emph>quaker</emph> George Fox, mas uma centralidade de intermedia&#231;&#227;o mais elevada. Isto &#233; o mesmo que dizer, simplesmente conhecer mais pessoas n&#227;o &#233; tudo.</p>
<p>Isto aborda somente a superf&#237;cie do que pode ser feito com m&#233;tricas de rede no Python. O NetworkX oferece dezenas de fun&#231;&#245;es e medidas para o leitor usar em v&#225;rias combina&#231;&#245;es, e pode usar Python para estender estas medidas de formas quase ilimitadas. Uma linguagem de programa&#231;&#227;o como o Python ou o R dar-lhe-&#225; a flexibilidade para explorar a sua rede computacionalmente de formas que outros <emph>interfaces</emph> n&#227;o podem ao permitir-lhe combinar e comparar os resultados estat&#237;sticos da sua rede com outros atributos dos seus dados (como as datas e ocupa&#231;&#245;es que adicionou &#224; rede no in&#237;cio deste tutorial!).</p>
<h2>No&#231;&#245;es Avan&#231;adas do NetworkX: Dete&#231;&#227;o de Comunidades com Modularidade</h2>
<p>Outra coisa regularmente questionada sobre o <emph>dataset</emph> duma rede &#233; quais s&#227;o os subgrupos e comunidades dentro da estrutura social mais larga. A sua rede &#233; uma fam&#237;lia grande e feliz na qual todos se conhecem? Ou &#233; uma cole&#231;&#227;o de subgrupos mais pequenos que est&#227;o conectados por um ou dois intermedi&#225;rios? O campo da dete&#231;&#227;o de comunidades em redes est&#225; desenhado para responder a estas quest&#245;es. Existem v&#225;rias formas de calcular comunidades, cliques, e aglomerados na sua rede, mas o m&#233;todo mais popular atualmente &#233; a <hi rend="bold">modularidade</hi>. A modularidade &#233; uma medida de densidade relativa na sua rede: uma comunidade (chamada um <hi rend="bold">m&#243;dulo</hi> ou <hi rend="bold">classe</hi> modular) tem uma densidade elevada em rela&#231;&#227;o a outros n&#243;s dentro do seu m&#243;dulo, mas densidade baixa com os outros de fora. A modularidade d&#225;-lhe uma pontua&#231;&#227;o geral de qu&#227;o fracioanda a sua rede &#233;, e essa pontua&#231;&#227;o pode ser usada para <hi rend="bold">repartir</hi> a rede e evidenciar as comunidades individuais<ref type="footnotemark" target="#note_15"/>.</p>
<p>Redes muito densas s&#227;o geralmente mais dif&#237;ceis de dividir em reparti&#231;&#245;es sensatas. Felizmente, como o leitor descobriu anteriormente, esta rede n&#227;o &#233; assim t&#227;o densa. N&#227;o existem tantas conex&#245;es reais quanto conex&#245;es poss&#237;veis, e existem componentes desconectados de todo. Vale a pena repartir esta rede esparsa com modularidade e ver se os resultados fazem sentido hist&#243;rico e anal&#237;tico.</p>
<p>A dete&#231;&#227;o e reparti&#231;&#227;o de comunidades no NetworkX requere um pouco mais de configura&#231;&#227;o do que algumas das outras m&#233;tricas. Existem algumas abordagens incorporadas para a dete&#231;&#227;o de comunidades (como o <ref target="https://perma.cc/K59Y-WZRX"><emph>minimum cut</emph></ref> (em ingl&#234;s)), mas modularidade n&#227;o vem inclu&#237;da com o NetworkX. Felizmente, existe um <ref target="https://github.com/taynaud/python-louvain/">m&#243;dulo adicional no Python</ref> (em ingl&#234;s) que o leitor pode usar com o NetworkX, e que j&#225; instalou e importou no in&#237;cio deste tutorial. O leitor pode ler a <ref target="https://perma.cc/KW5K-ZX67">documenta&#231;&#227;o completa</ref> (em ingl&#234;s) para todas as fun&#231;&#245;es que oferece, mas para a maior parte dos prop&#243;sitos da dete&#231;&#227;o de comunidades, querer&#225; apenas <code rend="inline">best_partition()</code>:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_30" corresp="code_explorar-analisar-dados-rede-python_30.txt" lang="language-python" rend="block"/></ab>
<p>O m&#233;todo <code rend="inline">greedy_modularity_communities()</code> tenta determinar o n&#250;mero de comunidades apropriadas para o grafo, e agrupa todos os n&#243;s em subconjuntos baseados nestas comunidades. Ao contr&#225;rio das fun&#231;&#245;es de centralidade, o c&#243;digo acima n&#227;o criar&#225; um dicion&#225;rio. Ao inv&#233;s, criar&#225; uma lista especial de objetos "<emph>frozenset</emph>" (similar a listas). Existe um conjunto para cada grupo, e os conjuntos cont&#234;m os nomes das pessoas em cada grupo. Para adicionar esta informa&#231;&#227;o &#224; sua rede na maneira agora familiar, o leitor tem que primeiro criar um dicion&#225;rio que classifique cada pessoa com um valor num&#233;rico para o grupo ao qual pertencem:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_31" corresp="code_explorar-analisar-dados-rede-python_31.txt" lang="language-python" rend="block"/></ab>
<p>Como sempre, o leitor pode combinar estas medidas com outras. Por exemplo, aqui est&#225; como encontrar os n&#243;s de centralidade adjacente mais elevada na classe modular 0 (a primeira):</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_32" corresp="code_explorar-analisar-dados-rede-python_32.txt" lang="language-python" rend="block"/></ab>
<p>Usando a centralidade adjacente como um <emph>ranking</emph> pode dar-lhe uma ideia das pessoas importantes nesta classe modular. O leitor notar&#225; que algumas destas pessoas, especialmente William Penn, William Bradford (<emph>n&#227;o</emph> o fundador de Plymouth em que estar&#225; a pensar<ref type="footnotemark" target="#note_16"/>) e James Logan, passaram muito tempo na Am&#233;rica. Tamb&#233;m, Bradford e Tace Sowle eram ambos impressores <emph>quakers</emph> proeminentes. Com um pouco de pesquisa, n&#243;s podemos descobrir que existem tanto raz&#245;es geogr&#225;ficas como ocupacionais que explicam que este grupo de pessoas se juntem. Isto &#233; uma indica&#231;&#227;o de que a modularidade est&#225; a trabalhar como esperado.</p>
<p>Em redes mais pequenas como esta, uma tarefa comum &#233; encontrar e listar todas as classes modulares e seus membros<ref type="footnotemark" target="#note_17"/>. O leitor pode fazer isto ao percorrer pela lista <code rend="inline">communities</code>:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_33" corresp="code_explorar-analisar-dados-rede-python_33.txt" lang="language-python" rend="block"/></ab>
<p>Note no c&#243;digo acima que est&#225; a filtrar qualquer classe modular com dois ou menos n&#243;s, na linha <code rend="inline">if len(c) &gt; 2</code>. O leitor recordar-se-&#225; da visualiza&#231;&#227;o que existiam v&#225;rios componentes pequenos da rede com apenas dois n&#243;s. A modularidade encontrar&#225; estes componentes e trat&#225;-los-&#225; como classes separadas (visto que eles n&#227;o est&#227;o conectados a mais nada). Ao filtr&#225;-los, o leitor obt&#233;m uma ideia melhor das classes modulares maiores dentro do principal componente da rede.</p>
<p>Trabalhando s&#243; com o NetworkX tr&#225;-lo-&#225; longe, e o leitor pode encontrar muito sobre classes modulares apenas ao trabalhar com os dados diretamente. Mas quase sempre quer visualizar os seus dados (e, talvez, expressar a modularidade como a cor de n&#243;). Na pr&#243;xima sec&#231;&#227;o, o leitor ir&#225; aprender como exportar os seus dados do NetworkX para uso noutros programas.</p>
</div>
      <div type="1"><head>Exportar Dados</head>
<p>O NetworkX suporta um grande n&#250;mero de formatos de ficheiros para <ref target="https://perma.cc/X65S-HRCF">exporta&#231;&#227;o de dados</ref> (em ingl&#234;s). Se o leitor quiser exportar uma lista de <emph>edges</emph> em texto simples para carregar no Palladio, existe um <ref target="https://perma.cc/P9ES-57X3"><emph>wrapper</emph> conveniente</ref> (em ingl&#234;s) para isso. Frequentemente, no <emph>Six Degrees of Francis Bacon</emph>, n&#243;s exportamos dados do NetworkX no <ref target="https://perma.cc/SF8Z-DWPW">formato JSON especializado do D3</ref> (em ingl&#234;s), para visualiza&#231;&#227;o no navegador de internet. O leitor poderia at&#233; <ref target="https://perma.cc/Y6QJ-5VM8">exportar</ref> (em ingl&#234;s) o seu grafo como um <ref target="https://perma.cc/87NA-KCK4"><emph>dataframe</emph> do Pandas</ref> (em ingl&#234;s) se existissem opera&#231;&#245;es estat&#237;sticas mais avan&#231;adas que quisesse executar. Existem v&#225;rias op&#231;&#245;es, e se o leitor tiver adicionado diligentemente todas as suas m&#233;tricas de volta no seu objeto Grafo como atributos, todos os seus dados ser&#227;o exportados duma s&#243; vez.</p>
<p>A maior parte das op&#231;&#245;es de exporta&#231;&#227;o funcionam da mesma maneira, por isso, para este tutorial o leitor aprender&#225; como exportar os seus dados para o formato GEXF do Gephi. Assim que tiver exportado o ficheiro, o leitor pode fazer o <emph>upload</emph> <ref target="https://gephi.org/users/supported-graph-formats/">diretamente para o Gephi</ref> (em ingl&#234;s) para a visualiza&#231;&#227;o.</p>
<p>Exportar dados &#233;, normalmente, um simples comando unilinear. Tudo o que &#233; preciso &#233; escolher um nome de ficheiro. Neste caso, usaremos <code rend="inline">quaker_network.gexf</code>. Para exportar, digite:</p>
<ab><code xml:id="code_explorar-analisar-dados-rede-python_34" corresp="code_explorar-analisar-dados-rede-python_34.txt" lang="language-python" rend="block"/></ab>
<p>&#201; s&#243;! Quando executar o seu <emph>script</emph> no Python, colocar&#225; automaticamente o novo ficheiro GEXF no mesmo diret&#243;rio que o seu ficheiro Python.<ref type="footnotemark" target="#note_18"/></p>
</div>
      <div type="1"><head>Conclus&#245;es</head>
<p>Agora, tendo realizado e revisto uma pan&#243;plia de m&#233;tricas de rede no Python, o leitor tem as evid&#234;ncias a partir das quais os argumentos se contr&#245;em e se retiram conclus&#245;es sobre esta rede de <emph>quakers</emph> na Gr&#227;-Bretanha moderna. O leitor sabe, por exemplo, que a rede tem uma <hi rend="bold">densidade</hi> relativamente baixa, sugerindo associa&#231;&#245;es t&#233;nues e/ou dados originais imcompletos. O leitor sabe que a comunidade est&#225; organizada em torno de v&#225;rios <emph><hi rend="bold">hubs</hi></emph> desproporcionalmente grandes, entre eles fundadores da denomina&#231;&#227;o, como Margaret Fell e George Fox, bem como l&#237;deres pol&#237;ticos e religiosos importantes, como William Penn. Mais &#250;til, o leitor sabe sobre mulheres com graus relativamente baixos, como Elizabeth Leavens e Mary Penington, que (como resultado de centralidade de intermedia&#231;&#227;o elevada) podem ter agido como <emph><hi rend="bold">brokers</hi></emph>, conectando m&#250;ltiplos grupos. Finalmente, o leitor aprendeu que a rede &#233; feita dum grande <hi rend="bold">componente</hi> e muitos muito pequenos. No interior desse grande componente, existem v&#225;rias <hi rend="bold">comunidades</hi> distintas, algumas das quais parecem organizadas em torno do tempo ou local (como Penn e os seus associados estadunidenses). Por causa dos metadados que adicionou &#224; sua rede, o leitor tem as ferramentas para explorar estas m&#233;tricas em profundidade e para, potencialmente, explicar alguns dos recursos estruturais que identificou.</p>
<p>Cada uma destas descobertas &#233; um convite para mais pesquisa ao inv&#233;s dum ponto final ou prova. A an&#225;lise de redes &#233; um conjunto de ferramentas para perguntar quest&#245;es espec&#237;ficas sobre a estrutura das rela&#231;&#245;es num <emph>dataset</emph>, e o NetworkX providencia um interface relativamente simples a muitas das t&#233;cnicas e m&#233;tricas comuns. As redes s&#227;o uma maneira &#250;til de estender a sua pesquisa a um grupo ao providenciar informa&#231;&#245;es sobre a estrutura da comunidade, e n&#243;s esperamos que o leitor ser&#225; inspirado por este tutorial para usar m&#233;tricas para enriquecer a sua pr&#243;pria pesquisa e para explorar a flexibilidade da an&#225;lise de redes para al&#233;m da visualiza&#231;&#227;o.</p>
<p><ref type="footnotemark" target="#note_1"/> : <hi rend="bold">Nota de tradu&#231;&#227;o</hi>: Como o leitor poder&#225; confirmar mais abaixo, os autores desta li&#231;&#227;o transformaram os dados aqui analisados num gr&#225;fico, sem explicar tal passo, visto que o artigo lida com a an&#225;lise dos dados, e n&#227;o com a sua visualiza&#231;&#227;o. Se desejar, pode ler tamb&#233;m a li&#231;&#227;o aqui referida e voltar a esta para confirmar se o seu gr&#225;fico se assemelha ao dos quatro autores. Aconselhamos que o fa&#231;a ap&#243;s ter conclu&#237;do todos os passos aqui descritos.</p>
<p><ref type="footnotemark" target="#note_2"/> : Em muitos (mas n&#227;o todos os) casos, <code rend="inline">pip</code> ou <code rend="inline">pip3</code> ser&#227;o instalados automaticamente com o Python3.</p>
<p><ref type="footnotemark" target="#note_3"/> : <hi rend="bold">Nota de tradu&#231;&#227;o</hi>: Isto pode estender-se ao uso de comandos, na sua <emph>shell</emph>, nomeadamente aquando da instala&#231;&#227;o do pip e de pacotes (ver Prepara&#231;&#227;o dos Dados e Instala&#231;&#227;o do NetworkX).</p>
<p><ref type="footnotemark" target="#note_4"/> : Algumas instala&#231;&#245;es s&#243; querer&#227;o que o leitor digite <code rend="inline">pip</code> sem "3," mas no Python 3, <code rend="inline">pip3</code> &#233; a mais comum. Se um n&#227;o funcionar, tente o outro!</p>
<p><ref type="footnotemark" target="#note_5"/> : <hi rend="bold">Nota de tradu&#231;&#227;o</hi>: &#201; importante lembrar que existem varia&#231;&#245;es entre as diferentes vers&#245;es do NetworkX que podem resultar em erros ou outputs diferentes. Tal &#233; o caso da 2.6, com a qual obtivemos uma mensagem de erro durante a avalia&#231;&#227;o da modularidade e uma resposta diferente com a fun&#231;&#227;o print(nx.info(G)) daquela apresentada com a 2.4.</p>
<p><ref type="footnotemark" target="#note_6"/> : Existem algumas t&#233;cnicas <emph>pyth&#243;nicas</emph> que este c&#243;digo usa. A primeira &#233; a 'compreens&#227;o de lista' (<emph>list comprehensions</emph>), que incorpora <emph>loops</emph> (<code rend="inline">for n in nodes</code>) para criar novas listas (em par&#234;ntesis retos), assim: <code rend="inline">new_list = [item for item in old_list]</code>. A segunda &#233; a <emph>list slicing</emph>, que permite-lhe subdividir ou "<emph>slice</emph>" ("cortar") a lista. A nota&#231;&#227;o da <emph>list slicing</emph> <code rend="inline">[1:]</code> toma tudo <emph>exceto</emph> o primeiro item na lista. O 1 informa o Python para come&#231;ar com o segundo item nesta lista (no Python, o leitor come&#231;a a contar do 0), e os dois pontos dizem ao Python para tomar tudo at&#233; ao fim da lista. Como a primeira linha em ambas destas listas &#233; a fila de cabe&#231;alho de cada CSV, n&#243;s n&#227;o queremos que esses cabe&#231;alhos sejam inclu&#237;dos nos nossos dados.</p>
<p><ref type="footnotemark" target="#note_7"/> : Dicion&#225;rios s&#227;o um tipo de dados incorporados no Python, constru&#237;dos com pares de chave-valor. Pense numa chave como a palavra-chave num dicion&#225;rio, e o valor como a sua defini&#231;&#227;o. Chaves t&#234;m que ser &#250;nicas (s&#243; uma de cada por dicion&#225;rio), mas os valores podem ser qualquer coisa. Dicion&#225;rios s&#227;o representados por chavetas, com chaves e valores separados por dois pontos: <code rend="inline">{key1:value1, key2:value2, ...}</code>. Dicion&#225;rios s&#227;o uma das maneiras mais r&#225;pidas de armazenar valores que o leitor pode necessitar mais tarde. De facto, um objeto Grafo do NetworkX &#233;, ele pr&#243;prio, feito de dicion&#225;rios aninhados.</p>
<p><ref type="footnotemark" target="#note_8"/> : Note que este c&#243;digo usa par&#234;ntesis retos de duas formas. Usa n&#250;meros em par&#234;ntesis retos para aceder &#237;ndices espec&#237;ficos numa lista de n&#243;s (por exemplo, o ano de nascimento no <code rend="inline">node[4]</code>), mas tamb&#233;m para designar uma <emph>chave</emph> (sempre <code rend="inline">node[0]</code>, o ID) a qualquer um dos nossos dicion&#225;rios vazios: <code rend="inline">dictionary[key] = value</code>. Conveniente!</p>
<p><ref type="footnotemark" target="#note_9"/> : Por uma quest&#227;o de simplicidade, removemos quaisquer n&#243;s que <emph>n&#227;o est&#227;o conectados a quaisquer outros</emph> do <emph>dataset</emph> antes de termos come&#231;ado. Isto foi feito simplesmente para reduzir a desordem, mas tamb&#233;m &#233; muito comum de se ver muitos destes n&#243;s solteiros no seu <emph>dataset</emph> de rede comum.</p>
<p><ref type="footnotemark" target="#note_10"/> : Mas mantenha em mente que isto &#233; a densidade de <emph>toda</emph> a rede, incluindo esses componentes n&#227;o conectados a flutuar em &#243;rbita. Existem v&#225;rias conex&#245;es poss&#237;veis entre e com eles. Se o leitor tivesse tomado a densidade somente do componente maior, poderia ter obtido um n&#250;mero diferente. O leitor poderia faz&#234;-lo ao encontrar o componente mais largo como n&#243;s lhe mostramos na pr&#243;xima sec&#231;&#227;o sobre o <hi rend="bold">di&#226;metro</hi>, e, depois, ao executar o mesmo m&#233;todo de densidade somente nesse componente.</p>
<p><ref type="footnotemark" target="#note_11"/> : N&#243;s tomamos o comprimento da lista <emph>menos um</emph> porque n&#243;s queremos o n&#250;mero de <emph>edges</emph> (ou passos) entre os n&#243;s listados aqui, ao inv&#233;s do n&#250;mero de n&#243;s.</p>
<p><ref type="footnotemark" target="#note_12"/> : A forma mais correta de fazer este tipo de compara&#231;&#227;o &#233; criar <emph>grafos aleat&#243;rios</emph> de tamanho id&#234;ntico para ver se as m&#233;tricas diferem da norma. O NetworkX oferece v&#225;rias ferramentas para <ref target="https://perma.cc/7Z4U-KAY7">gerar grafos aleat&#243;rios</ref> (em ingl&#234;s).</p>
<p><ref type="footnotemark" target="#note_13"/> : Porque se chama transitividade? O leitor pode recordar-se da propriedade transitiva de Geometria das aulas de Matem&#225;tica no Ensino Secund&#225;rio: se A=B e B=C, o A deve ser igual a C. Semelhantemente, no fechamento tri&#225;dico, se a pessoa A conhece a pessoa B e a pessoa B conhece a pessoa C, ent&#227;o a pessoa A provavelmente conhece a pessoa C: logo, transitividade.</p>
<p><ref type="footnotemark" target="#note_14"/> : Aqueles com experi&#234;ncia em Estat&#237;stica notar&#227;o que grau em redes sociais segue tipicamente uma <emph>lei de pot&#234;ncia</emph>, mas isto n&#227;o &#233; nem pouco usual, nem especialmente &#250;til saber.</p>
<p><ref type="footnotemark" target="#note_15"/> : Embora n&#227;o venhamos a cobri-lo neste tutorial, &#233; geralmente boa ideia obter a clasifica&#231;&#227;o modular global primeiro para determinar se o leitor aprender&#225; qualquer coisa ao repartir a sua rede de acordo com a modularidade. Para ver a classifica&#231;&#227;o geral da modularidade, tome as comunidades que calculou com <code rend="inline">communities = community.best_partition(G)</code> e execute <code rend="inline">global_modularity = community.modularity(communities, G)</code>. E depois basta aplicar <code rend="inline">print(global_modularity)</code>.</p>
<p><ref type="footnotemark" target="#note_16"/> : <hi rend="bold">Nota de tradu&#231;&#227;o</hi>: <ref target="https://perma.cc/2EKN-TJPW">Plymouth</ref> foi a primeira col&#243;nia inglesa permanente na regi&#227;o da Nova Inglaterra, no nordeste dos Estados Unidos da Am&#233;rica, tendo sido fundada em 1620 por v&#225;rios colonos puritanos, entre os quais um tal <ref target="https://perma.cc/UA8V-J4CX">William Bradford</ref>. Este <ref target="https://perma.cc/TW4C-QWUY">outro</ref> referido foi um importante impressor <emph>quaker</emph>.</p>
<p><ref type="footnotemark" target="#note_17"/> : Em redes grandes, as listas seriam provavelmente ilegivelmente longas, mas o leitor poderia obter uma ideia de todas as classes modulares duma s&#243; vez ao visualizar a rede e adicionar cor aos n&#243;s baseada na sua classe modular.</p>
<p><ref type="footnotemark" target="#note_18"/> : Cada formato de ficheiro que &#233; export&#225;vel &#233; tamb&#233;m import&#225;vel. Se o leitor tiver um ficheiro GEXF do Gephi que quer p&#244;r no NetworkX, digitaria <code rend="inline">G = nx.read_gexf('some_file.gexf')</code>.</p>
</div>
    </body>
  </text>
</TEI>
