<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:id="generer-jeu-donnees-texte-ocr">
  <teiHeader>
 <fileDesc>
  <titleStmt>
   <title>G&#233;n&#233;rer un jeu de donn&#233;es structur&#233; &#224; partir d&#8217;un texte oc&#233;ris&#233;</title>
  <author type="original_author">Jon Crump</author><editor type="reviewers">Brandon Hawk</editor><author type="translators">Antoine Gourlay</author><editor type="translation-reviewers"><persName>Floriane Chiffoleau</persName><persName>Jean-Luc Mirepoix</persName></editor><editor type="editors">Fred Gibbs</editor></titleStmt>
  <publicationStmt>
   <idno type="doi">10.46430/phfr0020</idno><date type="published">11/25/2014</date><date type="translated">11/19/2021</date><p>Lesson reviewed and published in Programming Historian.</p>
  </publicationStmt>
  <sourceDesc>
  <p>Born digital, in a markdown format. Original file: <ref type="original_file" target="#generating-an-ordered-data-set-from-an-OCR-text-file"/>.</p><p>There are other translations: <ref target=""/></p></sourceDesc>
 </fileDesc>
 <profileDesc><abstract><p>Ce tutoriel pr&#233;sente des strat&#233;gies pour traiter la sortie OCR brute issue d&#8217;un texte scann&#233;, l&#8217;analyser afin d'isoler et de corriger les &#233;l&#233;ments essentiels des m&#233;tadonn&#233;es, et g&#233;n&#233;rer un ensemble de donn&#233;es structur&#233; (un dictionnaire Python) &#224; partir de celle-ci.</p></abstract><textClass><keyword xml:lang="en">data-manipulation</keyword></textClass></profileDesc>
</teiHeader>
  <text xml:lang="fr">
    <body>
      <div type="2"><head>Objectifs de la le&#231;on</head>
<p>Ce tutoriel pr&#233;sente des strat&#233;gies pour obtenir un jeu de donn&#233;es ordonn&#233; (un dictionnaire de donn&#233;es Python) &#224; partir d'un document scann&#233; qui sera trait&#233; de fa&#231;on &#224; en extraire et &#233;ventuellement &#224; en corriger les &#233;l&#233;ments de m&#233;tadonn&#233;es. Les exemples pr&#233;sent&#233;s sont sp&#233;cifiques &#224; un texte particulier mais la strat&#233;gie globale ainsi que certaines proc&#233;dures plus caract&#233;ristiques peuvent &#234;tre appliqu&#233;es pour traiter n'importe quel document scann&#233;, m&#234;me si ceux-ci ne sont pas forc&#233;ment similaires au document pr&#233;sent&#233; ici.</p>
</div>
      <div type="2"><head>Introduction</head>
<p>On rencontre souvent le cas de l'historien(ne) impliqu&#233;(e) dans un projet num&#233;rique et d&#233;sirant travailler avec des documents num&#233;ris&#233;s, se disant&#8239;: &#171;&#8239;OK, je n'ai qu'&#224; scanner l'ensemble de ces ressources documentaires d'une incroyable richesse et exploiter les documents num&#233;riques obtenus&#8239;!&#8239;&#187;. (Ceux d'entre nous qui se sont retrouv&#233;s dans ce cas de figure ont un petit sourire d&#233;sabus&#233; au coin des l&#232;vres). Ces historien(ne)s d&#233;couvrent bien vite que m&#234;me les meilleurs syst&#232;mes de <link target="https://fr.wikipedia.org/wiki/Reconnaissance_optique_de_caract%C3%A8res">reconnaissance optique de caract&#232;res</link> ou OCR (<emph>optical character recognition</emph>) entra&#238;nent un nombre d'erreurs important. Alors les historien(ne)s se disent&#8239;: &#171;&#8239;OK, je vais r&#233;unir des fonds et constituer une arm&#233;e d'&#233;tudiants, diplom&#233;s ou non, ou m&#234;me de n'importe quel gamin sachant lire et &#233;crire, pour corriger les approximations de mon OCR&#8239;&#187;. (Le sourire d&#233;sabus&#233; s'accentue sur les visages).</p>
<ol>
<li>
<p>Il y a tr&#232;s peu de fonds accord&#233;s &#224; ce type de recherche. De plus en plus, l'attention se porte sur les projets concernant les domaines du traitement automatique des langues (TAL), de la fouille de donn&#233;es (Data Mining), du Machine Learning, de l'analyse des graphes et apparent&#233;s, si bien que la question de produire de la documentation num&#233;ris&#233;e exploitable est d&#233;laiss&#233;e. Sur le sujet, on a tendance &#224; penser que Google s'occupe d&#233;j&#224; des num&#233;risations, n'est ce pas&#8239;? Et quel pourrait bien &#234;tre le probl&#232;me avec les scans de Google&#8239;? Et bien, vous trouverez la r&#233;ponse &#224; la fin...</p>
</li>
<li>
<p>M&#234;me si vous trouviez le moyen de r&#233;unir un grand nombre de petites mains pour vous assister dans votre projet, il y a de grandes chances pour qu'une collection de chartes italiennes &#233;crites au <span style="font-variant:small-caps;">XII</span><sup>e</sup> si&#232;cle, traduites et publi&#233;es en 1935, les plongent dans un &#233;tat de profonde d&#233;pression, fassent saigner leurs yeux et que le r&#233;sultat soit toujours une grosse pile de documents contenant toujours une grande quantit&#233; d'erreurs sur lequel vous devrez encore effectuer un travail <hi rend="bold">difficile</hi> et <hi rend="bold">fastidieux</hi> afin de les rendre exploitables.</p>
</li>
</ol>
<p>Parcourir un document ligne par ligne et corriger les erreurs de l'OCR quand elles se pr&#233;sentent est une source d'erreurs in&#233;vitables. Il existe toutefois des moyens d'&#233;viter une partie de ce travail fastidieux en automatisant certaines t&#226;ches. Un langage de script tel que Perl ou Python peut vous permettre d'identifier et de traiter les erreurs communes de l'OCR et de les corriger &#224; l'aide des <link target="https://fr.wikipedia.org/wiki/Expression_r%C3%A9guli%C3%A8re">expressions r&#233;guli&#232;res</link>, une fa&#231;on d'identifier des motifs dans un texte (voir le tutoriel sur les <link target="/en/lessons/cleaning-ocrd-text-with-regular-expressions">expressions r&#233;guli&#232;res de L.T O'Hara)</link>. Cependant, les expressions r&#233;guli&#232;res ne vous seront utiles que si les expressions que vous recherchez sont r&#233;guli&#232;res bien s&#251;r. Malheureusement, une grande partie de ce que vous obtiendrez en sortie apr&#232;s avoir utilis&#233; l'OCR sera tout sauf <emph>r&#233;gulier</emph>. Si vous pouviez structurer ces donn&#233;es, votre outil d'analyse d'expression r&#233;guli&#232;re deviendrait beaucoup plus utile.</p>
<p>Que se passerait-il si, par exemple, votre OCR interpr&#233;tait les cha&#238;nes de caract&#232;res telles que &#171;&#8239;21 July, 1921&#8239;&#187; en &#171;&#8239;2l July, 192l&#8239;&#187;, rempla&#231;ant les &#171;&#8239;1&#8239;&#187; par des &#171;&#8239;l&#8239;&#187;. Vous appr&#233;cieriez grandement de savoir &#233;crire un script de recherche et remplacement de toutes les instances de &#171;&#8239;2l&#8239;&#187; en &#171;&#8239;21&#8239;&#187;, mais que se passerait-il dans le cas o&#249; vous auriez un grand nombre d'occurences de cette cha&#238;ne de caract&#232;re dans votre document&#8239;: &#171;&#8239;2lb. hammers&#8239;&#187;. Vous obtiendriez alors des &#171;&#8239;21b hammer&#8239;&#187;, ce que vous ne souhaitiez &#233;videmment pas. Si seulement vous pouviez dire &#224; votre script de ne changer les &#171;&#8239;2l&#8239;&#187; en &#171;&#8239;21&#8239;&#187; que dans les sections contenant des dates et non des unit&#233;s de mesures. Si vous aviez &#224; disposition un ensemble de donn&#233;es stuctur&#233;, vous pourriez faire &#231;a.</p>
<p>Bien souvent, les documents que les historien(ne)s souhaitent num&#233;riser sont d&#233;j&#224; des structures ordonn&#233;es de donn&#233;es&#8239;: une collection ordonn&#233;e de documents issus d'une source primaire, un code juridique ou encore un cartulaire. Mais la structure &#233;ditoriale impos&#233;e &#224; ces ressources est g&#233;n&#233;ralement con&#231;ue pour un type particulier de technologie d&#8217;extraction de donn&#233;es, c'est-&#224;-dire un codex, un livre. Pour un texte num&#233;ris&#233;, la structure utilis&#233;e sera diff&#233;rente. Si vous pouvez vous d&#233;barrasser de l&#8217;infrastructure li&#233;e au livre et r&#233;organiser le texte selon les sections et les divisions qui vous int&#233;ressent, vous vous retrouverez avec des donn&#233;es sur lesquelles il sera beaucoup plus facile d'effectuer des recherches et des op&#233;rations de remplacement, et en bonus, votre texte deviendra imm&#233;diatement exploitable dans une multitude d&#8217;autres contextes.</p>
<p>C'est l&#224; qu'un langage de script comme Python devient tr&#232;s utile. Pour notre projet nous avons voulu pr&#233;parer certains des documents d&#8217;une collection du <span style="font-variant:small-caps;">XII</span><sup>e</sup> si&#232;cle d&#8217;<emph>imbreviatura</emph> du scribe italien connu sous le nom de <link target="http://www.worldcat.org/oclc/17591390">Giovanni Scriba</link> afin qu&#8217;ils puissent &#234;tre trait&#233;s par des historien(ne)s &#224; des fins d&#8217;analyse TAL ou autres. Les pages de l'&#233;dition de 1935 ressemblent &#224; cela&#8239;:</p>
<figure><desc>GS page 110</desc><graphic url="gs_pg110.png"/></figure>
<p>Le document issu du traitement OCR &#224; partir du fichier scann&#233; ressemble &#224; cela malgr&#233; les nombreuses am&#233;liorations apport&#233;es (j'ai redimensionn&#233; les lignes les plus longues afin qu'elles s'adaptent &#224; la mise en page)&#8239;:</p>
<pre><code xml:id="code_generer-jeu-donnees-texte-ocr_0" type="block" corresp="code_generer-jeu-donnees-texte-ocr_0.txt"/></pre>
<p>Dans le scan de l&#8217;original, l'&#339;il du lecteur analyse facilement la page&#8239;: la mise en page a un sens. Mais comme vous pouvez le voir, r&#233;duit &#224; un texte simple comme celui-ci, aucune des m&#233;tadonn&#233;es impliqu&#233;es par la mise en page et la typographie ne peut &#234;tre diff&#233;renci&#233;e par des processus automatis&#233;s.</p>
<p>Vous pouvez constater &#224; partir du scan que chaque charte comporte les m&#233;tadonn&#233;es qui lui sont associ&#233;es&#8239;:</p>
<ul>
<li>Num&#233;ro de charte</li>
<li>Num&#233;ro de page</li>
<li>Num&#233;ro de folio</li>
<li>Un r&#233;sum&#233; italien, se terminant par une date quelconque</li>
<li>Une ligne, qui se termine habituellement par un crochet fermant (]) qui repr&#233;sente une note de marge dans l&#8217;original</li>
<li>Un ensemble de marqueurs de bas de page num&#233;rot&#233;s, dont la repr&#233;sentation textuelle appara&#238;t au bas de chaque page de fa&#231;on s&#233;quentielle, et red&#233;marrant &#224; partir de 1 sur chaque nouvelle page.</li>
<li>Le texte latin de la charte elle-m&#234;me</li>
</ul>
<p>Tout cela est typique de ce type de ressources, bien que les conventions d'&#233;ditions puissent varier. Le fait est qu'il s'agit bien d'un ensemble <hi rend="bold">ordonn&#233;</hi> de donn&#233;es et non simplement d'une cha&#238;ne de caract&#232;res interminable. Avec des scripts Python assez simples, nous pouvons transformer notre sortie OCR en un ensemble de donn&#233;es ordonn&#233;es, dans ce cas un <link target="https://docs.python.org/fr/3/tutorial/datastructures.html#dictionaries">dictionnaire Python</link>, <hi rend="bold">avant</hi> de commencer &#224; apporter des corrections au texte en lui-m&#234;me. Avec un tel jeu de donn&#233;es ordonn&#233; en main, nous pouvons apporter des &#233;l&#233;ments de correction, et potentiellement effectuer beaucoup d&#8217;autres types de t&#226;ches, de mani&#232;re plus efficace. </p>
<p>Ainsi, le but de ce tutoriel est de prendre un fichier texte brut, comme la sortie OCR ci-dessus, et de le transformer en un dictionnaire Python avec des champs pour le texte latin de la charte et pour chacun des &#233;l&#233;ments de m&#233;tadonn&#233;es mentionn&#233;s ci-dessus&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_1" type="block" corresp="code_generer-jeu-donnees-texte-ocr_1.txt"/></pre>
<p>Souvenez-vous qu'il s'agit simplement d'une repr&#233;sentation textuelle d'une structure de donn&#233;es h&#233;berg&#233;e quelque part dans la m&#233;moire de votre machine. Python d&#233;signe ce type de structure par le terme &#171;&#8239;dictionnaire&#8239;&#187;, mais d'autres langages de programmation y font r&#233;f&#233;rence en tant que &#171;&#8239;hachage&#8239;&#187; ou &#171;&#8239;tableau associatif&#8239;&#187;. Le fait est qu&#8217;il est infiniment plus facile de faire n&#8217;importe quelle sorte d&#8217;analyse ou de manipulation d&#8217;un texte num&#233;rique s&#8217;il est sous une telle forme, plut&#244;t que sous la forme d&#8217;un fichier texte brut. L&#8217;avantage est qu&#8217;une telle structure de donn&#233;es peut &#234;tre interrog&#233;e, ou des calculs peuvent &#234;tre effectu&#233;s sur les donn&#233;es, sans avoir &#224; analyser le texte.</p>
</div>
      <div type="2"><head>Quelques informations utiles avant de d&#233;marrer</head>
<p>Nous allons emprunter quelques fonctions r&#233;dig&#233;es par d&#8217;autres. Elles repr&#233;sentent toutes les deux des programmes assez sophistiqu&#233;s. Comprendre ce qui se passe dans ces fonctions est instructif, mais pas indispensable. Lire et r&#233;utiliser le code des autres est une bonne fa&#231;on d'apprendre la programmation, et repr&#233;sente le c&#339;ur du mouvement open source. M&#234;me si vous ne comprenez pas tout &#224; fait comment elles fonctionnent, vous pouvez n&#233;anmoins tester des fonctions comme celle-ci pour voir si elles fonctionnent vraiment, et les adapter &#224; votre probl&#233;matique si elles sont pertinentes.</p>
<div type="3"><head>La distance de Levenshtein</head>
<p>Vous remarquerez que certaines des m&#233;tadonn&#233;es &#233;num&#233;r&#233;es ci-dessus sont li&#233;es &#224; des pages et que d&#8217;autres sont li&#233;es &#224; la charte. Le but, c&#8217;est de les s&#233;parer les unes des autres. Il y a une classe de donn&#233;es li&#233;es &#224; la page qui ne nous est pas utile dans ce contexte, et seulement significative dans le contexte d&#8217;un livre physique&#8239;: les en-t&#234;tes et pieds de page. Dans notre document, ils prennent cette forme-ci sur les feuilles recto (dans un codex, un livre, <emph>recto</emph> est la page de droite, et <emph>verso</emph> son inverse, la page de gauche)&#8239;:</p>
<figure><desc>en-t&#234;te recto</desc><graphic url="gs_recto_header.png"/></figure>
<p>et cette forme-l&#224; sur les feuilles <emph>verso</emph>&#8239;:</p>
<figure><desc>en-t&#234;te verso</desc><graphic url="gs_verso_header.png"/></figure>
<p>Nous aimerions pr&#233;server la pagination pour chaque page de la charte, mais le texte d&#8217;en-t&#234;te ne nous est pas utile et va simplement rendre toute op&#233;ration de recherche ou de remplacement plus complexe. Nous aimerions donc l'identifier et le remplacer par une cha&#238;ne qui est facile &#224; trouver avec une expression r&#233;guli&#232;re, et enfin stocker le num&#233;ro de page.
Malheureusement, les expressions r&#233;guli&#232;res ne vous seront pas d'une grande utilit&#233; dans le cas pr&#233;sent. Ces en-t&#234;tes peuvent appara&#238;tre sur n&#8217;importe quelle ligne du document obtenu apr&#232;s le traitement OCR, et l'efficacit&#233; avec laquelle le logiciel OCR peut les traiter est limit&#233;e. Voici quelques exemples d&#8217;en-t&#234;tes de page, <emph>recto</emph> et <emph>verso</emph>, dans notre sortie OCR brute.</p>
<pre><code xml:id="code_generer-jeu-donnees-texte-ocr_2" type="block" corresp="code_generer-jeu-donnees-texte-ocr_2.txt"/></pre>
<p>Ces cha&#238;nes de caract&#232;res ne sont pas assez r&#233;guli&#232;res pour &#234;tre identifi&#233;es de fa&#231;on fiable avec des expressions r&#233;guli&#232;res; cependant, si vous savez ce &#224; quoi les cha&#238;nes sont cens&#233;es ressembler, vous pouvez composer une sorte d&#8217;algorithme de similarit&#233; de cha&#238;ne pour tester chaque cha&#238;ne par rapport &#224; un mod&#232;le et mesurer la probabilit&#233; qu&#8217;il s&#8217;agisse d&#8217;un en-t&#234;te de page. Heureusement, je n&#8217;ai pas eu &#224; composer un tel algorithme, <link target="https://fr.wikipedia.org/wiki/Distance_de_Levenshtein">Vladimir Levenshtein l&#8217;a fait pour nous en 1965</link>. Un langage informatique peut encoder cet algorithme de plusieurs fa&#231;ons ; voici une fonction Python efficace qui fera tr&#232;s bien l'affaire&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_3" type="block" corresp="code_generer-jeu-donnees-texte-ocr_3.txt"/></pre>
<p>Encore une fois, il s'agit d'un algorithme assez sophistiqu&#233;, mais pour notre objectif tout ce que nous avons besoin de savoir c&#8217;est que la fonction <code type="inline">lev()</code> prend deux cha&#238;nes comme param&#232;tres et retourne un nombre qui indique la &#171;&#8239;distance&#8239;&#187; entre les deux cha&#238;nes, ou combien de changements ont d&#251; &#234;tre apport&#233;s pour aller de la premi&#232;re cha&#238;ne &#224; seconde. Donc&#8239;: <code type="inline">lev("fizz", "buzz")</code> retourne &#171;&#8239;2&#8239;&#187;.</p>
</div><div type="3"><head>Des chiffres romains aux chiffres arabes</head>
<p>Vous remarquerez aussi que dans l&#8217;&#233;dition publi&#233;e, les chartes sont num&#233;rot&#233;es en chiffres romains. Convertir des chiffres romains en arabe constitue un d&#233;fi tr&#232;s formateur en Python. Voici la solution la plus propre et la plus &#233;l&#233;gante que je connaisse&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_4" type="block" corresp="code_generer-jeu-donnees-texte-ocr_4.txt"/></pre>
<p>Ex&#233;cutez ce &lt;<link target="/assets/chiffres_romains_arabes.txt">petit script</link>&gt; pour voir en d&#233;tail comment <code type="inline">rome2ar</code> fonctionne. Une programmation &#233;l&#233;gante comme celle-ci peut presque s'apparenter &#224; de la po&#233;sie.</p>
</div></div>
      <div type="2"><head>D'autres informations importantes</head>
<p>Si vous avez besoin d'importer des modules faisant partie de la biblioth&#232;que standard de Python, il faudra que les premi&#232;res lignes de votre programme soient les imports de ces modules. Si besoin, voir le tutoriel de Fred Gibbs sur <link target="/fr/lecons/installation-modules-python-pip"><emph>l'installation des biblioth&#232;ques Python avec pip</emph></link>.</p>
<ol>
<li>
<p>Le premier est le module "re" (expression r&#233;guli&#232;re) <code type="inline">import re</code>. Les expressions r&#233;guli&#232;res sont vos amies. Cependant, n&#8217;oubliez pas la blague de Jamie Zawinski&#8239;:</p>
<blockquote>
<p>Quand elles se retrouvent confront&#233;es &#224; un probl&#232;me, certaines personnes se disent&#8239;: &#171;&#8239;Je n'ai qu'&#224; utiliser les expressions r&#233;guli&#232;res&#8239;!&#8239;&#187; Elles se retrouvent alors avec deux probl&#232;mes.</p>
</blockquote>
<p>(Je vous recommande une nouvelle fois de jeter un coup d&#8217;&#339;il &#224; la pr&#233;sentation de L.T. O&#8217;Hara ici sur le site du Programming Historian <link target="/en/lessons/cleaning-ocrd-text-with-regular-expressions">Cleaning OCR&#8217;d text with Regular Expressions</link>)</p>
</li>
<li>
<p>Vous devrez r&#233;aliser l'import d'une biblioth&#232;que Python qui nous sera utile&#8239;: <code type="inline">from pprint import pprint</code>. Il s'agit d'un outil de formatage pour les objets Python comme les listes et les dictionnaires. Vous en aurez besoin parce que les dictionnaires Python sont beaucoup plus faciles &#224; lire s&#8217;ils sont format&#233;s.</p>
</li>
<li>
<p>L'import <code type="inline">from collections import Counter</code> nous sera utile pour la section <link target="/en/lessons/generer-jeu-donnees-texte-ocr#identifier-notes-bas-de-page">Identifier les notes de bas de page &#224; l'aide d'une expression r&#233;guli&#232;re</link> que nous aborderons juste apr&#232;s. Ce n&#8217;est pas vraiment n&#233;cessaire, mais nous allons faire des op&#233;rations de comptage qui exigeraient beaucoup de lignes de code et cela nous &#233;pargnera du temps. Le module des collections a beaucoup d'utilit&#233; et vaut la peine qu'on se familiarise avec. Encore une fois, voir la pr&#233;sentation Pymotw de Doug Hellmann concernant le module des <link target="https://docs.python.org/fr/3/library/collections.html">collections</link>. Je souligne &#233;galement que son livre <link target="https://doughellmann.com/books/the-python-3-standard-library-by-example/">The Python Standard Library By Example</link> vaut le co&#251;t.</p>
</li>
</ol>
</div>
      <div type="2"><head>Un petit aper&#231;u des expressions r&#233;guli&#232;res telles qu'elles sont impl&#233;ment&#233;es en Python</head>
<p><link target="/en/lessons/cleaning-ocrd-text-with-regular-expressions#introduction">L&#8217;introduction</link> de L.T. O&#8217;Hara &#224; l&#8217;utilisation d&#8217;expressions r&#233;guli&#232;res en Python est inestimable. Dans ce contexte, nous devrions passer en revue quelques principes de base sur l&#8217;impl&#233;mentation par Python d&#8217;expressions r&#233;guli&#232;res, le module <code type="inline">re</code>, qui fait partie de la biblioth&#232;que standard de Python.</p>
<ol>
<li><code type="inline">re.compile()</code> cr&#233;e un objet de type expression r&#233;guli&#232;re qui a un certain nombre de m&#233;thodes. Vous devriez vous familiariser avec <code type="inline">.match()</code>, et <code type="inline">.search()</code>, mais aussi <code type="inline">.findall()</code> et <code type="inline">.finditer()</code>.</li>
<li>Gardez &#224; l&#8217;esprit la diff&#233;rence entre <code type="inline">.match()</code> et <code type="inline">.search()</code>: <code type="inline">.match()</code> ne cherche une correspondance qu&#8217;au <hi rend="bold">d&#233;but</hi> d&#8217;une ligne, alors que <code type="inline">.search()</code> parcourt toute la ligne mais <hi rend="bold">s&#8217;arr&#234;te &#224; la premi&#232;re correspondance</hi> et ne retourne que la premi&#232;re occurrence qu&#8217;il trouve.</li>
<li><code type="inline">.match()</code> et <code type="inline">.search()</code> retournent les correspondances sous forme d'objets. Pour r&#233;cup&#233;rer la cha&#238;ne de caract&#232;res correspondante, vous aurez besoin de <code type="inline">mymatch.group(0)</code>. Si votre expression r&#233;guli&#232;re compil&#233;e contient des parenth&#232;ses de regroupement (comme notre regex 'slug' ci-dessous), vous pouvez les r&#233;cup&#233;rer sous forme de sous-cha&#238;nes de la cha&#238;ne appari&#233;e en utilisant <code type="inline">mymatch.group(1)</code> etc.</li>
<li><code type="inline">.findall()</code> et <code type="inline">.finditer()</code> retourneront <hi rend="bold">toutes</hi> les occurrences de la cha&#238;ne correspondante ; <code type="inline">.findall()</code> les retournera sous forme de liste de cha&#238;nes, mais <code type="inline">.finditer()</code> retourne un <hi rend="bold">it&#233;rateur d&#8217;objets correspondant aux occurrences</hi>. (lisez la documentation sur la m&#233;thode <link target="https://docs.python.org/fr/3/library/re.html#re.finditer">.finditer()</link>.</li>
</ol>
<div type="1"><head>Traitement it&#233;ratif  de fichiers textes</head>
<p>Nous allons commencer avec un seul fichier issu d'un traitement OCR. Nous g&#233;n&#233;rerons it&#233;rativement de nouvelles versions corrig&#233;es de ce fichier en l&#8217;utilisant comme entr&#233;e pour nos scripts Python. Parfois notre script va apporter des corrections automatiques mais, le plus souvent, nos scripts vont simplement nous alerter de l&#8217;endroit o&#249; se trouvent les probl&#232;mes dans le fichier d&#8217;entr&#233;e, et nous allons apporter des corrections manuellement. Ainsi, pour les premi&#232;res op&#233;rations, nous voudrons produire de nouveaux fichiers textes r&#233;vis&#233;s que nous utiliserons comme entr&#233;es pour les traitements &#224; venir. Chaque fois que vous produisez un fichier texte, vous devrez le versioner et le dupliquer pour pouvoir toujours y revenir. La prochaine fois que vous ex&#233;cutez votre code (au moment ou vous le d&#233;veloppez) vous pourriez alt&#233;rer le fichier et il sera toujours plus simple de restaurer l&#8217;ancienne version.</p>
<p>Le code de ce tutoriel est fortement &#233;dit&#233;&#8239;; il n&#8217;est <hi rend="bold">pas</hi> exhaustif. Au fur et &#224; mesure que vous peaufinerez vos fichiers d&#8217;entr&#233;e, vous &#233;crirez beaucoup de petits scripts <emph>ad hoc</emph> pour v&#233;rifier l&#8217;efficacit&#233; de ce que vous avez fait jusqu&#8217;&#224; pr&#233;sent. La gestion des versions vous permettra de mener vos exp&#233;rimentations sans compromettre le travail d&#233;j&#224; r&#233;alis&#233;.</p>
<h2>Un mot sur le d&#233;ploiement du code dans ce tutoriel</h2>
<p>Le code propos&#233; dans ce tutoriel est valable pour la version 3 de Python.</p>
<p>Lorsque vous &#233;crivez du code dans un fichier texte et que vous l&#8217;ex&#233;cutez, soit en ligne de commande, soit &#224; partir de votre &#233;diteur de texte ou de l&#8217;IDE, l&#8217;interpr&#233;teur Python ex&#233;cute le code ligne par ligne, de haut en bas. Ainsi, le code au bas de la page d&#233;pendra souvent du code au-dessus.</p>
<p>Une fa&#231;on d&#8217;utiliser les extraits de code de la section 2 pourrait &#234;tre de les r&#233;unir dans un seul fichier et de commenter les lignes que vous ne voulez pas ex&#233;cuter. Chaque fois que vous ex&#233;cuterez le fichier, vous voudrez avoir la certitude qu&#8217;il y a un d&#233;roulement logique &#224; partir de la ligne <code type="inline">#!</code> en haut, &#224; travers vos diff&#233;rentes <code type="inline">import</code>s et dans la d&#233;claration de variables globales, et &#224; chaque boucle ou bloc.</p>
<p>Sinon, chacune des sous-sections de la section 2 peut &#233;galement &#234;tre trait&#233;e comme un script &#224; part et chacun devra alors faire sa propre <code type="inline">import</code>ation et d&#233;claration de variables globales.</p>
<p>Dans la section 3, &#171; Cr&#233;ation du dictionnaire &#187;, vous utiliserez un ensemble de donn&#233;es stock&#233;es en m&#233;moire (le dictionnaire des <code type="inline">chartes</code>) qui sera g&#233;n&#233;r&#233; &#224; partir du texte d&#8217;entr&#233;e le plus r&#233;cent et coh&#233;rent que vous avez. Vous voudrez donc conserver un unique module Python dans lequel vous d&#233;finirez en premier lieu le dictionnaire, avec vos d&#233;clarations d&#8217;<code type="inline">import</code> et l&#8217;attribution de variables globales, suivi de chacune des quatre boucles qui modifieront le dictionnaire.</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_5" type="block" corresp="code_generer-jeu-donnees-texte-ocr_5.txt"/></pre>
<h2>D&#233;coupage du texte par pages</h2>
<p>Tout d&#8217;abord, nous voulons trouver tous les en-t&#234;tes de page pr&#233;sents au <emph>recto</emph> et au <emph>verso</emph> et les remplacer par des cha&#238;nes coh&#233;rentes que nous pouvons facilement identifier avec une expression r&#233;guli&#232;re. Le code suivant recherche des lignes qui sont similaires &#224; ce que nous savons &#234;tre nos en-t&#234;tes de page jusqu'&#224; un certain seuil. Il faudra quelques exp&#233;rimentations pour trouver ce seuil pour votre texte. Comme mes en-t&#234;tes <emph>recto</emph> et <emph>verso</emph> sont &#224; peu pr&#232;s de la m&#234;me longueur, les deux ont le m&#234;me score de similitude de 26.</p>
<blockquote>
<p>NOTA BENE&#8239;: la fonction <code type="inline">lev()</code> d&#233;crite ci-dessus retourne une mesure de la &#171;&#8239;distance&#8239;&#187; entre deux cha&#238;nes, donc, plus la cha&#238;ne d&#8217;en-t&#234;te de page est courte, plus il est probable que cette technique ne fonctionnera pas. Si votre en-t&#234;te de page est simplement &#171;&#8239;en-t&#234;te&#8239;&#187;, alors toute ligne compos&#233;e d&#8217;un mot de sept lettres pourrait vous donner une distance de cha&#238;ne de 7, par exemple&#8239;: <code type="inline">lev("en-t&#234;te", "palavas")</code> retourne '7', ce qui ne vous &#233;claire pas plus. Dans notre texte, cependant, les cha&#238;nes d&#8217;en-t&#234;te sont assez longues et complexes pour vous donner des indications significatives, par exemple&#8239;:</p>
</blockquote>
<p><code type="inline">lev("UNE CHA&#206;NE LAMBDA DE M&#202;ME LONGUEUR: 38", 'IL CARTOLARE DI GIOVANNI SCRIBA')</code></p>
<p>retourne 33, mais une de nos cha&#238;nes d&#8217;en-t&#234;te, m&#234;me estropi&#233;e par l&#8217;OCR, retourne 20&#8239;:</p>
<p><code type="inline">lev("IL CIRTOL4RE DI CIOVINN1 St'Itlltl     269", 'IL CARTOLARE DI GIOVANNI SCRIBA')</code></p>
<p>Nous pouvons donc utiliser <code type="inline">lev()</code> pour trouver et modifier nos cha&#238;nes d&#8217;en-t&#234;te ainsi&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_6" type="block" corresp="code_generer-jeu-donnees-texte-ocr_6.txt"/></pre>
<p>Il y a beaucoup de calculs qui s'&#233;x&#233;cutent dans la fonction <code type="inline">lev()</code>. Il n&#8217;est pas tr&#232;s efficace de l&#8217;appeler sur toutes les lignes de notre texte, donc cela pourrait prendre un certain temps, selon la longueur de notre texte. Nous n&#8217;avons que 803 chartes dans le vol. 1. C&#8217;est un nombre qui reste modeste. Si cela prend 30 secondes ou m&#234;me une minute pour ex&#233;cuter notre sc&#233;nario, alors qu&#8217;il en soit ainsi.</p>
<p>Si nous ex&#233;cutons ce script sur notre texte apr&#232;s traitement OCR, nous obtenons une sortie qui ressemble &#224; ceci&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_7" type="block" corresp="code_generer-jeu-donnees-texte-ocr_7.txt"/></pre>
<p>Pour chaque ligne, la sortie nous indique si c'est la page <emph>verso</emph> ou <emph>recto</emph>, le &#171;&#8239;score&#8239;&#187; de Levenshtein, puis le texte de la ligne (avec toutes les erreurs dedans). Notez que l'OCR a mal interpr&#233;t&#233; le chiffre de la page pour la page 429. Plus le &#171; score &#187; de Levenshtein est bas, plus la ligne se rapproche du mod&#232;le que vous lui avez donn&#233;.</p>
<p>Cela vous indique que le script a trouv&#233; 430 lignes qui sont probablement des en-t&#234;tes de page. Vous savez combien de pages il devrait y avoir, donc si le script n&#8217;a pas trouv&#233; tous les en-t&#234;tes, vous pouvez passer par la sortie en regardant les num&#233;ros de page, trouver les pages qu&#8217;il a manqu&#233;, et corriger les en-t&#234;tes manuellement, puis r&#233;p&#233;ter l'op&#233;ration jusqu&#8217;&#224; ce que le script trouve tous les en-t&#234;tes de page.</p>
<p>Une fois que vous avez trouv&#233; et corrig&#233; les en-t&#234;tes que le script n&#8217;a pas trouv&#233;s, vous pouvez alors &#233;crire le texte corrig&#233; dans un nouveau fichier qui servira de base pour les autres op&#233;rations ci-dessous. Donc &#224; la place de</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_8" type="block" corresp="code_generer-jeu-donnees-texte-ocr_8.txt"/></pre>
<p>Nous aurons le fichier texte&#8239;:</p>
<pre><code class="language-Python" xml:id="code_generer-jeu-donnees-texte-ocr_9" type="block" corresp="code_generer-jeu-donnees-texte-ocr_9.txt"/></pre>
<p>Notez que pour beaucoup des op&#233;rations suivantes, nous utiliserons <code type="inline">Gscriba = fin.readlines()</code> donc Gscriba sera une <hi rend="bold">liste python</hi> des lignes de notre texte d&#8217;entr&#233;e. Gardez cela &#224; l&#8217;esprit, car les boucles <code type="inline">for</code> que nous utiliserons d&#233;pendront du fait que nous allons it&#233;rer &#224; travers les lignes de notre texte dans l'ordre du document.</p>
<h2>D&#233;coupage du texte par charte (ou par section, lettre ou ce que vous souhaitez)</h2>
<p>Le texte est d&#233;coup&#233; en plusieurs sous parties que constituent nos chartes et celles-ci sont d&#233;limit&#233;es par des chiffres romains majuscules sur une ligne &#224; part. Nous avons donc besoin d&#8217;une regex pour trouver des chiffres romains de ce type. En voici une&#8239;: <code type="inline">romstr = re.compile(" s*[IVXLCDM]{2,}")</code>. Nous la placerons en haut de notre fichier comme variable &#171;&#8239;globale&#8239;&#187;, de sorte qu&#8217;elle sera accessible &#224; n&#8217;importe lequel des morceaux de code que nous &#233;crirons plus tard.</p>
<p>Le script ci-dessous va chercher des chiffres romains majuscules qui apparaissent sur une ligne &#224; part. Bon nombre de nos num&#233;ros de chartes &#233;choueront &#224; ce test et le script indiquera qu'il manque un num&#233;ro de charte, souvent parce qu&#8217;il y a quelque chose avant ou apr&#232;s sur la ligne&#8239;; ou, <code type="inline">KeyError</code>, souvent parce que l&#8217;OCR a brouill&#233; les caract&#232;res (par ex. CCG pour 300, XOII pour 492). Ex&#233;cutez ce script plusieurs fois, en corrigeant <code type="inline">out1.txt</code> comme vous savez maintenant le faire jusqu&#8217;&#224; ce que toutes les chartes soient prises en compte.</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_10" type="block" corresp="code_generer-jeu-donnees-texte-ocr_10.txt"/></pre>
<p>Puisque nous savons combien de chartes il devrait y avoir. &#192; la fin de notre boucle, la valeur de n devrait &#234;tre la m&#234;me que le nombre de chartes. Et, dans toute it&#233;ration de la boucle, si la valeur de n ne correspond pas au num&#233;ro de la charte qui suit, alors nous savons que nous avons un probl&#232;me quelque part, et les <code type="inline">print</code> pour l'affichage en console devraient nous aider &#224; le trouver.</p>
<p>Voici un exemple de sortie que notre script devrait nous donner&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_11" type="block" corresp="code_generer-jeu-donnees-texte-ocr_11.txt"/></pre>
<blockquote>
<p>NOTA BENE&#8239;: notre regex signalera une erreur pour les chiffres romains &#224; un chiffre (&#171; I &#187;, &#171; V &#187;, &#171; X &#187;, etc.). Vous pourriez les tester dans le code, mais parfois laisser une erreur connue et commune est une aide pour v&#233;rifier l&#8217;efficacit&#233; de ce que vous faites. Notre objectif est de nous assurer que toutes les incoh&#233;rences sur la ligne de num&#233;ro de la charte sont bien d&#233;tect&#233;es.</p>
</blockquote>
<p>Une fois que nous avons trouv&#233; et corrig&#233; tous les en-t&#234;tes de charte en chiffres romains, alors nous pouvons &#233;crire un nouveau fichier avec une cha&#238;ne facile &#224; trouver gr&#226;ce &#224; notre regex, une &#171;&#8239;slug&#8239;&#187;, pour chaque charte &#224; la place du nombre romain de d&#233;part. Mettez la boucle <code type="inline">for</code> ci-dessus en commentaire, et remplacez-la par celle-ci&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_12" type="block" corresp="code_generer-jeu-donnees-texte-ocr_12.txt"/></pre>
<p>Bien qu&#8217;il soit important en soi pour nous d&#8217;avoir transform&#233; notre sortie OCR de fa&#231;on fiable et de l'avoir divis&#233;e par page et par charte, la chose la plus importante &#224; propos de ces op&#233;rations est que vous connaissez le nombre de pages et de chartes, et que vous pouvez utiliser ces connaissances pour v&#233;rifier les op&#233;rations subs&#233;quentes. Si vous voulez r&#233;aliser une op&#233;ration pour chaque charte, vous pouvez v&#233;rifier si celle-ci a fonctionn&#233; ou non parce que vous pouvez compter le nombre de chartes sur lesquelles elle aura fonctionn&#233; pr&#233;alablement.</p>
<h2>Identifier les marqueurs de folio &#224; l'aide d'une expression r&#233;guli&#232;re</h2>
<p>Notre texte est tir&#233; de l&#8217;&#233;dition de 1935 de Giovanni Scriba. Il s&#8217;agit d&#8217;une transcription d&#8217;un manuscrit cartulaire sous la forme d&#8217;un livre reli&#233;. L&#8217;&#233;dition publi&#233;e conserve la pagination de l'original en notant o&#249; les pages originales changent&#8239;: [fo. 16 r.] le recto de la <span style="font-variant:small-caps;">16</span><sup>e</sup> feuille du livre, suivie de son verso[fo. 16 v.]. Il s&#8217;agit de m&#233;tadonn&#233;es que nous voulons pr&#233;server pour chacune des chartes afin qu&#8217;elles puissent &#234;tre r&#233;f&#233;renc&#233;es par rapport &#224; l&#8217;original, ainsi que par rapport &#224; l&#8217;&#233;dition publi&#233;e par num&#233;ro de page.</p>
<p>Bon nombre des marqueurs de folio (par ex. &#171;&#8239;[fo. 16 v.]&#8239;&#187;) apparaissent sur la m&#234;me ligne que le chiffre romain de l&#8217;en-t&#234;te de la charte. Pour normaliser ces en-t&#234;tes de chartes pour l&#8217;op&#233;ration ci-dessus, nous avons d&#251; cr&#233;er une rupture de ligne entre le marqueur de folio et le num&#233;ro de charte, de sorte que beaucoup de marqueurs de folio sont d&#233;j&#224; sur leur propre ligne. Cependant, il arrive que le folio change quelque part au milieu du texte de la charte. Nous voulons que ces balises restent l&#224; o&#249; elles sont&#8239;; nous devrons traiter ces deux cas diff&#233;remment. Dans les deux cas, nous devons nous assurer que tous les marqueurs de folio sont exempts d&#8217;erreurs afin de pouvoir les trouver de fa&#231;on fiable au moyen d&#8217;une expression r&#233;guli&#232;re. Encore une fois, puisque nous savons combien il y a de folios, nous pouvons savoir si nous les avons tous trouv&#233;s. Notez que parce que nous avons utilis&#233; <code type="inline">.readlines()</code>, <code type="inline">Gscriba</code> est une liste, donc le script ci-dessous va afficher en console le num&#233;ro de ligne du fichier
source ainsi que la ligne elle-m&#234;me. Cela va vous permettre d'identifier tous les marqueurs de folio correctement format&#233;s, de sorte que vous puissiez trouver et r&#233;parer ceux qui ont un probl&#232;me.</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_13" type="block" corresp="code_generer-jeu-donnees-texte-ocr_13.txt"/></pre>
<p>Nous voulons aussi nous assurer qu'aucune ligne ne poss&#232;de plus d'un marqueur de folio. Nous pouvons nous en assurer en faisant ceci&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_14" type="block" corresp="code_generer-jeu-donnees-texte-ocr_14.txt"/></pre>
<p>Comme vous l'avez fait pr&#233;cedemment, une fois que vous avez trouv&#233; et corrig&#233; tous les marqueurs de folio dans votre fichier d&#8217;entr&#233;e, enregistrez-le avec un nouveau nom et
utilisez-le comme entr&#233;e &#224; la section suivante.</p>
<h2>Identifier le r&#233;sum&#233; de la page en italien &#224; l'aide d'une expression r&#233;guli&#232;re</h2>
<p>Cette ligne est invariablement la premi&#232;re apr&#232;s l'en-t&#234;te de la charte.</p>
<figure><desc>Ligne de r&#233;sum&#233; en italien</desc><graphic url="gs_italian_summary.png"/></figure>
<p>&#201;tant donn&#233; que les en-t&#234;tes en chiffres romains sont maintenant facilement rep&#233;rables gr&#226;ce &#224; notre regex &#171;&#8239;slug&#8239;&#187;, nous pouvons maintenant isoler la ligne qui appara&#238;t imm&#233;diatement apr&#232;s. Nous savons aussi que les r&#233;sum&#233;s se terminent toujours par une sorte de r&#233;f&#233;rence dat&#233;e entre parenth&#232;ses. Ainsi, nous pouvons composer une expression r&#233;guli&#232;re pour trouver le &#171;&#8239;slug&#8239;&#187; et la ligne qui lui succ&#232;de&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_15" type="block" corresp="code_generer-jeu-donnees-texte-ocr_15.txt"/></pre>
<p>D&#233;composons cette regex en utilisant le mode verbeux (voir le tutoriel d&#8217;<link target="/en/lessons/cleaning-ocrd-text-with-regular-expressions">O&#8217;Hara</link>). Notre &#171;&#8239;slug&#8239;&#187; pour chaque charte prend la forme &#171; [~~~~ Gscriba_ccvii ::: : 207 ~~~~]&#187; par exemple. Le mod&#232;le compil&#233; ci-dessus est exactement &#233;quivalent &#224; celui-ci(notez le commutateur re.VERBOSE &#224; la fin)&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_16" type="block" corresp="code_generer-jeu-donnees-texte-ocr_16.txt"/></pre>
<p>Les parenth&#232;ses d&#233;limitent les groupes de matchs, de sorte que chaque fois que notre regex trouve une correspondance, nous pouvons nous r&#233;f&#233;rer dans notre code &#224; des morceaux sp&#233;cifiques de la correspondance qu&#8217;il a trouv&#233;&#8239;:</p>
<ul>
<li><code type="inline">match.group(0)</code> est l&#8217;ensemble de ce qui est captur&#233;, &#224; la fois notre " slug " et la ligne qui le suit.</li>
<li><code type="inline">match.group(1)</code> = &#171; [~~~~ Gscriba_&#187;</li>
<li><code type="inline">match.group(2)</code> = le num&#233;ro romain de la charte</li>
<li><code type="inline">match.group(3)</code> = le num&#233;ro arabe de la charte </li>
<li><code type="inline">match.group(4)</code> = l&#8217;ensemble de la ligne comprenant le r&#233;sum&#233; en italien jusqu&#8217;&#224; la date entre parenth&#232;ses</li>
<li><code type="inline">match.group(5)</code> = l&#8217;expression de la date entre parenth&#232;ses. Notez l'&#233;chappement des parenth&#232;ses.</li>
</ul>
<p>Parce que notre sortie OCR contient beaucoup de ces myst&#233;rieux espaces blancs (les logiciels OCR ne sont pas bons pour interpr&#233;ter les espaces blancs et vous &#234;tes susceptible d&#8217;obtenir des nouvelles lignes, onglets, espaces, tous m&#233;lang&#233;s sans raison apparente), nous voulons identifier cette regex comme sous-cha&#238;ne d&#8217;une plus grande cha&#238;ne, donc cette fois nous allons utiliser <code type="inline">.read()</code> au lieu de <code type="inline">.readlines()</code>. Et nous aurons &#233;galement besoin d&#8217;un compteur pour num&#233;roter les lignes que nous trouvons. Ce script indiquera les num&#233;ros de chartes lorsque la premi&#232;re ligne n&#8217;est pas conforme &#224; notre mod&#232;le regex. Cela se produit g&#233;n&#233;ralement s&#8217;il n&#8217;y a pas de saut de ligne apr&#232;s notre en-t&#234;te de charte, ou si la ligne de r&#233;sum&#233; a &#233;t&#233; divis&#233;e en plusieurs lignes.</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_17" type="block" corresp="code_generer-jeu-donnees-texte-ocr_17.txt"/></pre>
<p>Ex&#233;cutez de nouveau le script plusieurs fois jusqu&#8217;&#224; ce que toutes les lignes de r&#233;sum&#233; soient pr&#233;sentes et correctes, puis enregistrez-le avec un nouveau nom et r&#233;utilisez-le comme fichier d&#8217;entr&#233;e&#8239;:</p>
<h2>Identifier les notes de bas de page &#224; l'aide d'une expression r&#233;guli&#232;re</h2>
<p>Un des aspects les plus difficiles &#224; g&#233;rer est la convention &#233;ditoriale exasp&#233;rante qui consiste &#224; red&#233;marrer la num&#233;rotation des notes de bas de page avec chaque nouvelle page. Il est donc difficile d&#8217;associer un texte de note de bas de page (donn&#233;es li&#233;es &#224; la page) &#224; un marqueur de note de bas de page (donn&#233;es li&#233;es &#224; la charte). Avant de le faire, nous devons nous assurer que le texte de chaque note qui appara&#238;t au bas de la page, appara&#238;t aussi dans notre fichier source sur sa propre ligne distincte sans commencer par un espace blanc. Et, par ailleurs, qu&#8217;<hi rend="bold">aucun</hi> des marqueurs de note dans le texte n&#8217;appara&#238;t au d&#233;but d&#8217;une ligne. Aussi, nous devons veiller &#224; ce que chaque cha&#238;ne de note de bas de page, par exemple &#171;&#8239;(1)&#8239;&#187; apparait <hi rend="bold">exactement</hi> deux fois sur une page, une fois comme un marqueur dans le texte, et une fois au bas du texte de la note de bas de page. Le script suivant indique le num&#233;ro de page de toute page qui &#233;choue &#224; ce test, ainsi qu&#8217;une liste de la note de bas de page.</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_18" type="block" corresp="code_generer-jeu-donnees-texte-ocr_18.txt"/></pre>
<blockquote>
<p>Note&#8239;: les &#233;l&#233;ments de l&#8217;it&#233;rateur &#171;&#8239;i&#8239;&#187; sont des correspondances de cha&#238;nes. Nous voulons les cha&#238;nes qui ont &#233;t&#233; appari&#233;es,  <code type="inline">group(0)</code>, par ex. &#171;&#8239;(1)&#8239;&#187;. Et si nous faisons eval(&#171;&#8239;(1)&#8239;&#187;), nous obtenons un entier que nous pouvons ajouter &#224; notre liste.</p>
</blockquote>
<p>Notre <code type="inline">compteur</code> est une structure de donn&#233;es sp&#233;ciale tr&#232;s pratique. Nous savons que nous voulons que chaque valeur de notre <code type="inline">pgfnlist</code> apparaisse deux fois. Notre <code type="inline">compteur</code> nous donnera un hash (tableau clef/valeur), &#233;quivalent d'un dictionnaire Python o&#249; les cl&#233;s sont les &#233;l&#233;ments qui apparaissent, et les valeurs repr&#233;sentent les occurences de ces &#233;l&#233;ments. Comme ceci&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_19" type="block" corresp="code_generer-jeu-donnees-texte-ocr_19.txt"/></pre>
<p>Donc si pour une page donn&#233;e nous obtenons une liste de marqueurs de note de bas de page comme ceci <code type="inline">[1,2,3,1,3]</code>, alors le test <code type="inline">if 1 in c.values()</code> indiquera une erreur parce que nous savons que chaque &#233;l&#233;ment doit appara&#238;tre <hi rend="bold">exactement deux fois</hi>&#8239;:</p>
<pre><code class="language-Python" xml:id="code_generer-jeu-donnees-texte-ocr_20" type="block" corresp="code_generer-jeu-donnees-texte-ocr_20.txt"/></pre>
<p>Tandis que, si notre liste de marqueurs de note en bas de page pour la page est compl&#232;te <code type="inline">[1,2,3,1,2,3]</code>, alors&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_21" type="block" corresp="code_generer-jeu-donnees-texte-ocr_21.txt"/></pre>
<p>Comme pr&#233;c&#233;demment, ex&#233;cutez ce script plusieurs fois, corrigez votre fichier d&#8217;entr&#233;e manuellement lorsque vous d&#233;couvrez des erreurs, jusqu&#8217;&#224; ce que vous soyez satisfait(e) du r&#233;sultat et que toutes les notes de bas de page soient pr&#233;sentes et correctes pour chaque page. Puis enregistrez votre fichier d&#8217;entr&#233;e corrig&#233; avec un nouveau nom.</p>
<p>Notre fichier texte contient encore beaucoup d&#8217;erreurs issues du traitement OCR, mais nous l&#8217;avons maintenant parcouru et avons trouv&#233; et corrig&#233; tous les octets de m&#233;tadonn&#233;es sp&#233;cifiques que nous voulons dans notre ensemble de donn&#233;es ordonn&#233;es. Maintenant, nous pouvons utiliser notre fichier texte corrig&#233; pour construire un dictionnaire Python.</p>
</div><div type="1"><head>Cr&#233;er le dictionnaire de donn&#233;es</head>
<p>Maintenant que nous avons suffisamment nettoy&#233; l'OCR pour pouvoir diff&#233;rencier les parties constitutives de chacune des pages, nous pouvons trier les diff&#233;rents &#233;l&#233;ments de m&#233;tadonn&#233;es, et le texte de la charte elle-m&#234;me, dans leurs propres champs d&#8217;un dictionnaire Python.</p>
<p>Nous avons un certain nombre de choses &#224; faire&#8239;: num&#233;roter correctement chaque charte, chaque folio et chaque page&#8239;; s&#233;parer le r&#233;sum&#233; des annotations de la marge&#8239;; et, enfin, associer les textes de note de bas de page &#224; leur charte respective. Pour faire tout cela, il peut &#234;tre commode de d&#233;composer les t&#226;ches&#8239;:</p>
<h2>Cr&#233;er la structure du dictionnaire de donn&#233;es</h2>
<p>Nous allons commencer par g&#233;n&#233;rer un dictionnaire Python dont les cl&#233;s sont les num&#233;ros de charte, et dont les valeurs sont un dictionnaire imbriqu&#233; qui a des champs pour certaines des m&#233;tadonn&#233;es que nous voulons stocker pour chaque charte. Le dictionnaire aura la forme suivante&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_22" type="block" corresp="code_generer-jeu-donnees-texte-ocr_22.txt"/></pre>
<p>Pour ce premier passage, nous allons simplement cr&#233;er cette structure de base puis, dans les boucles suivantes, nous ajouterons et modifierons ce dictionnaire jusqu&#8217;&#224; ce que nous obtenions un dictionnaire pour chaque charte, et des champs pour toutes les m&#233;tadonn&#233;es de chacun des chartes. Une fois que cette boucle permet une identification des lignes qui nous int&#233;ressent (folio, page, en-t&#234;tes de charte) et cr&#233;e un conteneur vide pour les notes de bas de page, l'&#233;tape suivante sera d&#8217;ajouter les lignes restantes au champ de texte, qui est une liste Python.</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_23" type="block" corresp="code_generer-jeu-donnees-texte-ocr_23.txt"/></pre>
<h2>Ajouter les notes de la marge et le r&#233;sum&#233; de la page au dictionnaire de donn&#233;es</h2>
<p>Lorsque nous avons g&#233;n&#233;r&#233; le dictionnaire des dictionnaires ci-dessus, nous avons attribu&#233; des champs pour les notes de bas de page (juste une liste vide pour l&#8217;instant), un identifiant pour les chartes (charterID), un num&#233;ro de charte, le folio, et le num&#233;ro de page. Toutes les lignes restantes ont &#233;t&#233; ajout&#233;es &#224; une liste et attribu&#233;es au champ &#171;&#8239;texte&#8239;&#187;. Dans tous les cas, la premi&#232;re ligne du champ de texte de chaque charte devrait &#234;tre le r&#233;sum&#233; italien comme nous nous en sommes assur&#233;s ci-dessus. Dans la PLUPART des cas, la deuxi&#232;me ligne repr&#233;sente une sorte de notation marginale qui se termine habituellement par le caract&#232;re &#171; ] &#187; (que l'OCR interpr&#232;te souvent mal). Nous devons trouver les cas qui ne satisfont pas &#224; ce crit&#232;re, fournir ou corriger le &#171; ] &#187; manquant, et dans les cas o&#249; il n&#8217;y a pas de notation marginale, j&#8217;ai ajout&#233; la sp&#233;cification &#171;&#8239;aucune marge&#8239;&#187;. Le script suivant fera un &#171;&#8239;print&#8239;&#187; du num&#233;ro de la charte et des deux premi&#232;res lignes du champ de texte pour les chartes qui ne r&#233;pondent pas &#224; ces crit&#232;res. Ex&#233;cutez ce script sur chaque <code type="inline">charte</code> du dictionnaire des chartes, corrigez et mettez &#224; jour votre texte en cons&#233;quence.</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_24" type="block" corresp="code_generer-jeu-donnees-texte-ocr_24.txt"/></pre>
<blockquote>
<p>Note&#8239;: les blocs <code type="inline">try: except:</code> sont rendus n&#233;cessaires par le fait que, dans ma sortie OCR, les donn&#233;es de la page 214 ont en quelque sorte &#233;t&#233; oubli&#233;es. Cela arrive souvent. Num&#233;riser ou photographier chaque page d&#8217;un livre de 600 pages est fastidieux &#224; l&#8217;extr&#234;me. Il est tr&#232;s facile de sauter une page. Vous aurez in&#233;vitablement des anomalies comme celle-ci dans votre texte que vous devrez isoler et contourner. Le bloc <code type="inline">try: except:</code> de Python rend cela plus facile. Python est &#233;galement tr&#232;s utile ici en ce sens que vous pouvez aller beaucoup plus loin dans la gestion des exceptions que d'afficher &#171;&#8239;oups&#8239;&#187; dans votre console. Vous pourriez par exemple appeler une fonction sp&#233;cifique qui effectue une op&#233;ration tout &#224; fait distincte sur ces &#233;l&#233;ments anormaux.</p>
</blockquote>
<p>Une fois que nous sommes s&#251;rs que la ligne 1 et la ligne 2 dans le champ &#171; texte &#187; pour chaque charte du dictionnaire des <code type="inline">chartes</code> soient respectivement le r&#233;sum&#233; italien et la notation marginale, nous pouvons faire une autre it&#233;ration du dictionnaire des <code type="inline">chartes</code>, supprimer ces lignes du champ de texte et cr&#233;er de nouveaux champs dans la nouvelle entr&#233;e de la charte qui leurs seront d&#233;di&#233;s.</p>
<blockquote>
<p>NOTA BENE&#8239;: nous modifions maintenant une structure de donn&#233;es en m&#233;moire plut&#244;t que d&#8217;&#233;diter des fichiers de texte successifs. Ce script devrait donc &#234;tre <hi rend="bold">ajout&#233;</hi> &#224; celui ci-dessus qui a cr&#233;&#233; le squelette de votre dictionnaire. Le premier script cr&#233;e le dictionnaire des <code type="inline">chartes</code> en m&#233;moire, tandis que celui-ci le modifie.</p>
</blockquote>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_25" type="block" corresp="code_generer-jeu-donnees-texte-ocr_25.txt"/></pre>
<h2>Attribuer les notes de bas de page &#224; leur chartre respective puis les ajouter au dictionnaire de donn&#233;es</h2>
<p>La partie la plus difficile est de faire en sorte que les notes de bas de page apparaissent au bas de la page et soient associ&#233;es &#224; leurs chartes respectives. Puisque nous analysons n&#233;cessairement notre texte ligne par ligne, nous sommes confront&#233;s au probl&#232;me d&#8217;associer une r&#233;f&#233;rence donn&#233;e &#224; son texte appropri&#233; alors qu&#8217;il y a peut-&#234;tre beaucoup de lignes &#224; prendre en compte.</p>
<p>Pour cela, nous revenons &#224; la m&#234;me liste de lignes &#224; partir de laquelle nous avons construit le dictionnaire. Nous nous reposons sur le fait que tous les rep&#232;res figurent dans le texte de la charte, c'est-&#224;-dire qu'aucun d&#8217;entre eux ne se trouve au d&#233;but d&#8217;une ligne. De plus, chacun des textes de note de bas de page se trouve sur une ligne distincte commen&#231;ant par &#171;&#8239;(1)&#8239;&#187;, etc. Nous concevons des regex qui peuvent faire la distinction entre les deux et construisons un conteneur pour les retenir au fur et &#224; mesure que nous les it&#233;rons sur les lignes. Comme nous it&#233;rons sur les lignes du fichier texte, nous trouvons et attribuons des marqueurs et des textes &#224; notre conteneur temporaire et, ensuite, chaque fois que nous atteignons un saut de page, nous les assignons &#224; leurs champs appropri&#233;s dans nos <code type="inline">chartes</code> de dictionnaire Python existantes et r&#233;initialisons notre conteneur temporaire au <code type="inline">dictionnaire</code> vide.</p>
<p>Notez comment nous construisons ce conteneur temporaire. <code type="inline">fndict</code> commence comme un dictionnaire vide. Au fur et &#224; mesure que nous parcourons les lignes de notre texte d&#8217;entr&#233;e, si nous trouvons des marqueurs de note dans la ligne, nous cr&#233;ons une entr&#233;e dans <code type="inline">fndict</code> dont la cl&#233; est le num&#233;ro de note de bas de page et dont la valeur est un autre dictionnaire. Dans ce dictionnaire, nous inscrivons l&#8217;identit&#233; de la charte &#224; laquelle appartient la note de bas de page et nous cr&#233;ons un champ vide pour le texte de cette derni&#232;re. Lorsque nous trouvons les textes de note (<code type="inline">ntexts</code>) au bas de la page, nous recherchons le num&#233;ro de note de bas de page dans notre conteneur <code type="inline">fndict</code> et &#233;crivons le texte de la ligne au champ vide correspondant. Donc, &#224; la fin de la page, nous avons un dictionnaire de notes qui ressemble &#224; ceci&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_26" type="block" corresp="code_generer-jeu-donnees-texte-ocr_26.txt"/></pre>
<p>Nous avons maintenant toute l&#8217;information n&#233;cessaire pour attribuer les notes de bas de page &#224; la liste vide de &#171;&#8239;notes de bas de page&#8239;&#187; dans le dictionnaire des <code type="inline">chartes</code>&#8239;: le num&#233;ro de la note de bas de page (la cl&#233;), la charte &#224; laquelle elle appartient (<code type="inline">chid</code>) et le texte de la note de bas de page (<code type="inline">fntext</code>).</p>
<p>C&#8217;est une fa&#231;on de faire habituelle dans la programmation et tr&#232;s utile&#8239;: dans un processus it&#233;ratif quelconque, vous utilisez un accumulateur (notre <code type="inline">fndict</code>) pour recueillir des octets de donn&#233;es, puis lorsque lorsque la sentinelle que vous avez programm&#233;e rencontre une condition sp&#233;cifi&#233;e (le changement de page) elle fait quelque chose avec les donn&#233;es.</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_27" type="block" corresp="code_generer-jeu-donnees-texte-ocr_27.txt"/></pre>
<p>Notez que les blocs <code type="inline">try: except:</code> viennent de nouveau &#224; la rescousse. La boucle ci-dessus a cass&#233; parce que, dans 3 cas, il est apparu qu&#8217;il existait des notes en bas de page pour lesquelles il n&#8217;y avait pas de marqueurs dans le texte. Il s&#8217;agissait d&#8217;un oubli &#233;ditorial dans l&#8217;&#233;dition publi&#233;e et non d&#8217;une erreur de l'OCR. Le r&#233;sultat est que, quand j&#8217;ai essay&#233; de corriger l&#8217;entr&#233;e inexistante dans <code type="inline">fndict</code>, j&#8217;ai eu une <code type="inline">KeyError</code>. Ma clause <code type="inline">except</code> m&#8217;a permis de trouver et d&#8217;examiner l&#8217;erreur, de d&#233;terminer que cette derni&#232;re &#233;tait d&#233;j&#224; dans l&#8217;original et que rien de ce que je pouvais faire n'y changerait quoi que ce soit, de sorte que lors de la g&#233;n&#233;ration de la version finale des <code type="inline">chartes</code>, j&#8217;aie remplac&#233; la commande <code type="inline">print</code> par la commande <code type="inline">pass</code>. Les textes r&#233;dig&#233;s par les humains contiennent des erreurs&#8239;; on ne peut pas les contourner. <code type="inline">try: except :</code> existent pour composer avec cette r&#233;alit&#233;.</p>
<blockquote>
<p>NOTA BENE&#8239;: encore une fois, gardez &#224; l&#8217;esprit que nous modifions une structure de donn&#233;es en m&#233;moire plut&#244;t que d&#8217;&#233;diter des fichiers de texte successifs. Cette boucle devrait donc &#234;tre <hi rend="bold">ajout&#233;e</hi> &#224; votre script <hi rend="bold">sous</hi> le r&#233;sum&#233; et la boucle qui traite les marges, qui se trouve <hi rend="bold">sous</hi> la boucle qui a cr&#233;&#233; le squelette de votre dictionnaire.</p>
</blockquote>
<h2>Convertir les &#233;l&#233;ments de type date et les ajouter au dictionnaire de donn&#233;es</h2>
<p>Les dates sont difficiles &#224; traiter. Les &#233;tudiant(e)s en histoire qui travaillent sur l&#8217;histoire britanniques s&#8217;accrochent ainsi &#224; <link target="https://www.worldcat.org/title/handbook-of-dates-for-students-of-british-history/oclc/41238508">Cheyney</link> comme &#224; une bou&#233;e sur un oc&#233;an agit&#233;. Et, compte tenu de la fa&#231;on progressive par laquelle le calendrier gr&#233;gorien a &#233;t&#233; adopt&#233;, et des nombreuses variations locales, une juste appr&#233;ciation de la date pour les ressources m&#233;di&#233;vales n&#233;cessitera toujours des connaissances particuli&#232;res. N&#233;anmoins, ici aussi Python peut &#234;tre d&#8217;une certaine utilit&#233;.</p>
<p>Notre ligne de r&#233;sum&#233; en italien contient invariablement une date tir&#233;e du texte, commod&#233;ment s&#233;par&#233;e du reste de la ligne par des parenth&#232;ses. Nous pouvons donc les analyser et cr&#233;er des objets de <code type="inline">date</code> en Python. Ensuite, si nous le voulons, nous pouvons faire un simple calcul &#224; partir du calendrier.</p>
<p>Premi&#232;rement, nous devons trouver et corriger toutes les dates de la m&#234;me fa&#231;on que nous l&#8217;avons fait pour les autres &#233;l&#233;ments de m&#233;tadonn&#233;es. Vous devez donc concevoir un script de diagnostic qui it&#233;rera sur votre dictionnaire de <code type="inline">chartes</code>, signaler l&#8217;emplacement des erreurs dans votre texte puis les corriger manuellement. Quelque chose comme &#231;a&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_28" type="block" corresp="code_generer-jeu-donnees-texte-ocr_28.txt"/></pre>
<blockquote>
<p>Note&#8239;: lorsque vous utilisez les blocs <code type="inline">try/except</code>, vous devez g&#233;n&#233;ralement attraper des erreurs <hi rend="bold">sp&#233;cifiques</hi> dans la clause except, comme <code type="inline">ValueError</code> et autres ; cependant, dans les scripts ad hoc comme ceci, utiliser <code type="inline">sys.exc_info</code> est un moyen rapide d&#8217;obtenir des informations sur toute exception qui peut &#234;tre soulev&#233;e. (Le module <link target="https://pymotw.com/2/sys/index.html#module-sys">sys</link> est plein de ces trucs, utile pour le d&#233;bogage).</p>
</blockquote>
<p>Une fois que vous vous &#234;tes assur&#233;(e) que toutes les expressions de date entre parenth&#232;ses sont pr&#233;sentes, correctes et conformes &#224; votre expression r&#233;guli&#232;re, vous pouvez les extraire et les ajouter &#224; votre structure de donn&#233;es sous forme de dates, plut&#244;t que de simples cha&#238;nes de caract&#232;res. Pour cela, vous pouvez utiliser le module <code type="inline">datetime</code>.</p>
<p>Ce module, qui fait partie de la biblioth&#232;que standard, est un sujet vaste et devrait faire l&#8217;objet de son propre tutoriel, compte tenu de l&#8217;importance des dates pour les historien(ne)s. Comme avec beaucoup d&#8217;autres modules Python, une bonne introduction est <link target="https://pymotw.com/3/datetime/index.html">Pymotw</link> de Doug Hellmann (module de la semaine&#8239;!). Une biblioth&#232;que d&#8217;extension encore plus compl&#232;te est <link target="https://www.egenix.com/products/python/mxBase/mxDateTime/">mxDateTime</link>. Il suffit de dire ici que le module <code type="inline">datetime.date</code> attend des param&#232;tres comme ceci&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_29" type="block" corresp="code_generer-jeu-donnees-texte-ocr_29.txt"/></pre>
<p>Voici donc notre boucle pour analyser les dates &#224; la fin des lignes de r&#233;sum&#233; en italien et les stocker dans notre dictionnaire de chartes (en nous souvenant que nous voulons modifier la structure de donn&#233;es de nos chartes cr&#233;&#233;es pr&#233;c&#233;demment)&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_30" type="block" corresp="code_generer-jeu-donnees-texte-ocr_30.txt"/></pre>
<p>Sur 803 chartes, 29 ne seraient pas correctement analys&#233;es, principalement parce que la date inclut seulement mois et ann&#233;e. Vous pouvez stocker ces cha&#238;nes, mais vous avez deux types de donn&#233;es qui correspondent &#224; des dates. Ou vous pouvez fournir un 01 comme jour par d&#233;faut et ainsi stocker un objet date Python, mais <span style="font-variant:small-caps;">1</span><sup>er</sup> janvier 1160 n&#8217;est pas la m&#234;me chose que janvier 1160 et donc d&#233;forme vos m&#233;tadonn&#233;es. Ou vous pouvez simplement faire comme moi et vous r&#233;f&#233;rer au texte source pertinent&#8239;: la ligne de r&#233;sum&#233; en italien dans l&#8217;&#233;dition imprim&#233;e.</p>
<p>Une fois que vous avez des objets date, vous pouvez faire le calcul de la date. Supposons que nous voulions trouver toutes les chartes de moins de 3 semaines avant ou apr&#232;s No&#235;l 1160.</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_31" type="block" corresp="code_generer-jeu-donnees-texte-ocr_31.txt"/></pre>
<p>Ce qui nous donnera le r&#233;sultat suivant&#8239;:</p>
<pre><code class="language-Python" xml:id="code_generer-jeu-donnees-texte-ocr_32" type="block" corresp="code_generer-jeu-donnees-texte-ocr_32.txt"/></pre>
<p>Sympa, n'est-ce pas&#8239;?</p>
</div><div type="1"><head>Notre structure de donn&#233;es finale</head>
<p>Maintenant, nous avons suffisamment corrig&#233; notre texte pour diff&#233;rencier les octets de m&#233;tadonn&#233;es que nous voulons capturer, et nous avons aussi cr&#233;&#233; une structure de donn&#233;es en m&#233;moire, notre dictionnaire de <code type="inline">chartes</code>, en faisant 4 it&#233;rations, chacune prolongeant et modifiant le dictionnaire en m&#233;moire.</p>
<ol>
<li>Cr&#233;er le squelette</li>
<li>S&#233;parer le <code type="inline">r&#233;sum&#233;</code> et les lignes <code type="inline">de marge</code> et leur attribuer des champs dans le dictionnaire</li>
<li>Recueillir et attribuer des notes de bas de page &#224; leurs chartes respectives</li>
<li>Analyser les dates dans le champ r&#233;sum&#233; et les ajouter &#224; leur charte respective</li>
</ol>
<p>Imprimez en console notre dictionnaire en utilisant <code type="inline">pprint(charters)</code> et vous verrez quelque chose comme ceci&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_33" type="block" corresp="code_generer-jeu-donnees-texte-ocr_33.txt"/></pre>
<p>Imprimer en console votre dictionnaire Python comme une cha&#238;ne litt&#233;rale peut &#234;tre une bonne id&#233;e. Pour un texte de cette taille, le fichier r&#233;sultant est parfaitement g&#233;rable, peut &#234;tre envoy&#233; et lu dans un programme de r&#233;ponse en Python tr&#232;s simplement en utilisant <code type="inline">eval()</code> ou coll&#233; directement dans un fichier de module Python. D&#8217;autre part, si vous voulez un moyen encore plus fiable le de s&#233;rialiser dans un contexte exclusivement Python, regardez dans <link target="https://docs.python.org/3.7/library/pickle.html">Pickle</link>. Si vous avez besoin de le d&#233;placer vers un autre contexte, Javascript par exemple, ou des triplestores <code type="inline">RDF</code>, le module <link target="https://docs.python.org/3.7/library/json.html#module-json">json</link> de Python fera tr&#232;s bien l'affaire. Si jamais vous devez obtenir une sortie XML, je suis vraiment d&#233;sol&#233; pour vous, mais le module Python <link target="https://lxml.de/">lxml</link> pourra peut-&#234;tre un peu att&#233;nuer vos souffrances.</p>
<h2>Du d&#233;sordre &#224; l'ordre, hip hip hip...</h2>
<p>Maintenant que nous avons une structure de donn&#233;es ordonn&#233;e, nous pouvons faire beaucoup de choses avec elle. Un exemple tr&#232;s simple&#8239;: ajoutons un code qui affiche des <code type="inline">chartes</code> comme HTML pour l&#8217;affichage sur un site web&#8239;:</p>
<pre><code class="language-python" xml:id="code_generer-jeu-donnees-texte-ocr_34" type="block" corresp="code_generer-jeu-donnees-texte-ocr_34.txt"/></pre>
<p>Ouvrez le fichier r&#233;sultant avec un navigateur web et vous obtenez une &#233;dition num&#233;rique parfaitement format&#233;e.</p>
<figure><desc>Exemple de charte format&#233;e en HTML</desc><graphic url="gs_gscriba207.png"/></figure>
<p>&#202;tre en mesure d'obtenir cela avec votre sortie OCR en grande partie non corrig&#233;e n&#8217;est pas un avantage anecdotique. Si vous tenez &#224; &#233;mettre une &#233;dition &#233;lectronique propre et sans erreur, vous devez faire un certain travail de correction. Avoir un texte source format&#233; pour la lecture est crucial&#8239;; de plus, si votre correcteur peut changer la police, l&#8217;espacement, la couleur, la mise en page, et ainsi de suite &#224; volont&#233;, vous pouvez augmenter consid&#233;rablement sa pr&#233;cision et sa productivit&#233;. Avec cet exemple dans un navigateur web moderne, peaufiner ces param&#232;tres avec quelques d&#233;clarations CSS simples est facile. </p>
<p>Ainsi, notre probl&#232;me de d&#233;part, le nettoyage OCR, est maintenant beaucoup plus g&#233;rable parce que nous pouvons cibler des expressions r&#233;guli&#232;res pour les types sp&#233;cifiques de m&#233;tadonn&#233;es que nous avons&#8239;: erreurs dans le r&#233;sum&#233; en italien ou dans le texte latin&#8239;? Ou nous pourrions concevoir des routines de recherche et de remplacement uniquement pour des chartes sp&#233;cifiques ou des groupes de chartes.</p>
<p>Au-del&#224; de cela, il y a beaucoup de choses que vous pouvez faire avec un ensemble de donn&#233;es ordonnn&#233;es, y compris l'alimenter gr&#226;ce &#224; un outil de balisage comme <link target="http://brat.nlplab.org/">le &#171;&#8239;brat&#8239;&#187;</link> dont nous nous sommes servis pour le projet ChartEx. Des sp&#233;cialistes peuvent alors commencer &#224; ajouter des couches de balisage s&#233;mantique, m&#234;me si vous ne faites plus de correction d&#8217;erreur OCR. En outre, avec un ensemble de donn&#233;es ordonnn&#233;es, nous pouvons obtenir toutes sortes de sorties&#8239;: TEI (Text Encoding Initiative) ou EAD (Encoded Archival Description). Ou encore vous pouvez lire votre ensemble de donn&#233;es directement dans une base de donn&#233;es relationnelle ou un r&#233;pertoire de stockage qui associe une cl&#233; et une valeur. Toutes ces choses sont tout bonnement impossibles, si vous travaillez seulement avec un simple fichier texte.</p>
<p>Les morceaux de code ci-dessus ne sont en aucun cas une solution cl&#233; en main pour nettoyer une sortie OCR lambda. Il n'existe pas de telle baguette magique. L&#8217;approche de Google pour scanner le contenu des biblioth&#232;ques de recherche menace de nous noyer dans un oc&#233;an de mauvaises donn&#233;es. Pire encore, elle &#233;lude un fait fondamental du savoir num&#233;rique&#8239;: les sources num&#233;riques sont difficiles &#224; obtenir. Des textes num&#233;riques fiables, flexibles et utiles n&#233;cessitent une r&#233;daction soign&#233;e et une conservation p&#233;renne. Google, Amazon, Facebook et d'autres g&#233;ants du Web n&#8217;ont pas &#224; se soucier de la qualit&#233; de leurs donn&#233;es, juste de leur quantit&#233;. Les historien(ne)s, par contre, doivent d&#8217;abord se soucier de l&#8217;int&#233;grit&#233; de leurs sources.</p>
<p>Les vastes projets d&#8217;&#233;dition des <span style="font-variant:small-caps;">XVIII</span><sup>e</sup> et <span style="font-variant:small-caps;">XIX</span><sup>e</sup> si&#232;cles, tels que la S&#233;rie Rolls, la Monumenta Germaniae Historica et beaucoup d&#8217;autres, nous ont l&#233;gu&#233; un tr&#233;sor de ressources mat&#233;rielles &#224; travers une &#233;norme quantit&#233; de travail tr&#232;s minutieux et d&#233;taill&#233; par des arm&#233;es d&#8217;&#233;rudits d&#233;vou&#233;s et bien form&#233;s. Leur t&#226;che &#233;tait la m&#234;me que la n&#244;tre&#8239;: transmettre fid&#232;lement l&#8217;h&#233;ritage de l&#8217;histoire de ses formes ant&#233;rieures sous une forme plus moderne, le rendant ainsi plus largement accessible. Nous ne pouvons pas faire moins. Nous avons des outils puissants &#224; notre disposition, mais m&#234;me si cela peut changer l&#8217;ampleur de la t&#226;che, cela ne change pas pour autant sa nature.</p>
</div></div>
    </body>
  </text>
</TEI>
