<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:id="introduccion-a-powershell">
  <teiHeader>
 <fileDesc>
  <titleStmt>
   <title>Introducci&#243;n a la l&#237;nea de comandos de Windows con PowerShell</title>
  <author role="original_author">Ted Dawson</author><editor role="reviewers"><persName>Erin N. Bush</persName><persName>Derek Price</persName></editor><author role="translators">Victor Gayol</author><editor role="translation-reviewers"><persName>Silvia Guti&#233;rrez</persName><persName>Jos&#233; Antonio Motilla</persName></editor><editor role="editors">Jeri E. Wieringa</editor></titleStmt>
  <publicationStmt>
   <idno type="doi">10.46430/phes0037</idno><date type="published">07/21/2016</date><date type="translated">06/02/2018</date><p>Lesson reviewed and published in Programming Historian.</p>
  </publicationStmt>
  <sourceDesc>
  <p>Born digital, in a markdown format. Original file: <ref type="original_file" target="#intro-to-powershell"/>.</p><p>There are other translations: <ref target=""/></p></sourceDesc>
 </fileDesc>
 <profileDesc><abstract><p>En este tutorial aprender&#225;s las bases de PowerShell de Windows, la interfaz de l&#237;nea de comandos est&#225;ndar de computadoras con Windows.</p></abstract><textClass><keywords><term xml:lang="en">data-manipulation</term><term xml:lang="en">get-ready</term></keywords></textClass></profileDesc>
</teiHeader>
  <text xml:lang="es">
    <body>
      <div type="1"><head>Introducci&#243;n</head>
<p>En este tutorial aprender&#225;s las bases de PowerShell de Windows, la interfaz de l&#237;nea de comandos est&#225;ndar de computadoras con Windows. Si eres usuario de Mac o Linux deber&#237;as consultar la <ref target="/es/lecciones/introduccion-a-bash">Introducci&#243;n a la l&#237;nea de comandos en Bash</ref>. Si ya est&#225;s familiarizado con el uso de Bash, es posible que puedas comenzar con PowerShell solamente con ver la <ref target="#referencia-rapida">tabla al final de esta lecci&#243;n</ref>.</p>
<p>El tutorial est&#225; dividido en dos secciones principales. En la primera secci&#243;n, "<ref target="#para-empezar">Para empezar</ref>", aprender&#225;s a realizar tareas b&#225;sicas de escritorio como crear y abrir archivos y carpetas con PowerShell. En la segunda secci&#243;n, "<ref target="#haciendo-m%C3%A1s">Haciendo m&#225;s</ref>", obtendr&#225;s un vistazo de algunas de las caracter&#237;sticas que hacen que el trabajo en l&#237;nea de comandos sea particularmente eficiente y aprendas lo b&#225;sico para poder explorar m&#225;s por tu cuenta. Tambi&#233;n te preparar&#225;s para <ref target="#Utilizaci%C3%B3n-de-herramientas-de-l%C3%ADnea-de-comandos-y-ejecuci%C3%B3n-de-secuencias-de-comandos-en-Python">ejecutar <emph>scripts</emph> de Python desde la l&#237;nea de comandos</ref>.</p>
<p>Este tutorial fue escrito para PowerShell 5.0. Si est&#225;s usando una versi&#243;n anterior, encontrar&#225;s algunas peque&#241;as diferencias de sintaxis que debes ser capaz de superar con la peque&#241;a ayuda de un buscador.</p>
</div>
      <div type="1"><head>&#191;Qu&#233; es PowerShell y por qu&#233; es &#250;til?</head>
<p>Windows PowerShell es una <hi rend="bold">interfaz de l&#237;nea de comandos</hi> para computadoras Windows. Una interfaz de l&#237;nea de comandos (CLI, por sus siglas en ingl&#233;s) es un programa que te permite hacer que tu computadora ejecute tareas utilizando &#243;rdenes escritas en vez de hacer clic sobre las im&#225;genes en el escritorio como en una <hi rend="bold">interfaz gr&#225;fica de usuario</hi> (GUI, por sus siglas en ingl&#233;s). T&#233;cnicamente, PowerShell es m&#225;s que s&#243;lo una CLI; puedes obtener una visi&#243;n general de sus caracter&#237;sticas en <ref target="https://es.wikipedia.org/wiki/Windows_PowerShell">Wikipedia</ref>. El uso de la l&#237;nea de comandos tiene muchas ventajas. Hace posible automatizar tareas y hacer muchas cosas con una orden. Lo que es m&#225;s importante, una serie de herramientas de valor para los humanistas s&#243;lo se pueden ejecutar desde la l&#237;nea de comandos, incluyendo muchas de las que puedes aprender en <emph>The Historian</emph> en espa&#241;ol, como <ref target="/en/lessons/topic-modeling-and-mallet">Mallet</ref> (en ingl&#233;s), <ref target="/es/lecciones/escritura-sostenible-usando-pandoc-y-markdown">Pandoc</ref>, o <ref target="/en/lessons/automated-downloading-with-wget">Wget</ref> (en ingl&#233;s). La l&#237;nea de comandos es tambi&#233;n el mejor lugar para trabajar con los programas que has construido y personalizado para tu propia investigaci&#243;n utilizando lenguajes de programaci&#243;n como Python.</p>
</div>
      <div type="1"><head>Para empezar</head>
<p>En primer lugar aprender&#225;s a navegar a trav&#233;s de tus archivos y a realizar algunas tareas b&#225;sicas que haces todos los d&#237;as en la computadora.</p>
</div>
      <div type="1"><head>Abrir PowerShell</head>
<p>Busca PowerShell en tu computadora. Probablemente tengas varias opciones, como "PowerShell", "PowerShell ISE" y "PowerShell (x86)". El ISE (entorno integrado de secuencias de &#243;rdenes -<emph>integrated scripting environment</emph>) es una herramienta &#250;til que te permite escribir <emph>scripts</emph> al vuelo y tambi&#233;n cuenta con una b&#250;squeda de todos los comandos de PowerShell. En este momento es m&#225;s de lo que necesitamos. El "X86" es compatible con versiones anteriores del sistema operativo (si has estado en el mundo de las computadoras por alg&#250;n tiempo, recordar&#225;s los viejos procesadores de Intel de los a&#241;os 80 y 90 llamados "286", 2386", "486", y as&#237; sucesivamente. Eso es lo que permite el "X86", pues es una versi&#243;n de 32 bits). Pero queremos 64-bits y lo m&#225;s simple, as&#237; que vamos a utilizar el llamado solamente "Windows PowerShell". Posiblemente quieras agregarlo a tu barra de tareas: haz clic con el bot&#243;n derecho para obtener la opci&#243;n. Al abrirlo, se ver&#225; as&#237;:</p>
<figure><desc>Puesta en marcha de PowerShell</desc><graphic url="intro-to-powershell1.png"/></figure>
<p>Si no quieres blanco sobre azul, haz clic con el bot&#243;n derecho en la barra superior, selecciona "propiedades" y ve a "colores" para cambiar las cosas. Deber&#225;s cerrar y volver a abrir PowerShell para que se vea correctamente.</p>
<div type="2"><head>Navegaci&#243;n</head>
<p>Algo bueno de PowerShell es que siempre sabr&#225;s d&#243;nde est&#225;s porque te lo dice en el prompt. En mi caso, yo veo:</p>
<p><code rend="inline">C:\Users\Ted&gt;</code></p>
<p>Debes ver algo similar pero con tu nombre de usuario. En caso de que no sea as&#237;, escribe:</p>
<p><code rend="inline">sl ~</code></p>
<p>Aseg&#250;rate de incluir el espacio. Esto te llevar&#225; a tu directorio personal: <code rend="inline">C:\Users\TUNOMBREDEUSUARIO</code> donde "TUNOMBREDEUSUARIO" se reemplaza con el nombre de tu cuenta en la m&#225;quina. "Directorio" es s&#243;lo otra palabra para "carpeta", y PowerShell considera tu carpeta de usuario como inicio -no el escritorio. El escritorio es realmente otra carpeta dentro de tu carpeta de usuario, es decir, un subdirectorio del directorio usuario. Introducir <code rend="inline">sl ~</code> es como abrir la carpeta llamada "usuarios" y desde ah&#237; TUNOMBREDEUSUARIO utilizando la GUI. Comencemos aprendiendo como moverte entre los directorios y ver su contenido.</p>
<div type="3"><head>Ver contenido del directorio con <code rend="inline">Get-ChildItem</code> (<code rend="inline">gci</code>, <code rend="inline">ls</code>)</head>
<p>Nuestra primera orden es <code rend="inline">Get-ChildItem</code>. Escr&#237;bela y oprime Enter. Ver&#225;s una lista de todo lo que hay en tu directorio actual. En mi caso se ver&#225; as&#237;:</p>
<figure><desc>Listado del contenido del directorio con `Get-ChildItem`</desc><graphic url="intro-to-powershell2.png"/></figure>
<p>Toma en cuenta que en realdad no escrib&#237; <code rend="inline">GetChildItem</code>. Solamente <code rend="inline">gci</code>. Los comandos que aprenderemos son todos de la forma "Verbo-Sustantivo" (<emph>Verb-Noun</emph>). Son llamados "cmdlets" (pronunciado "commandlets") y se supone que su forma hace m&#225;s f&#225;cil recordar lo que hacen y predecir otros <emph>cmdlets</emph> similares. Debido a que los <emph>cmdlets</emph> son bastante largos, la mayor&#237;a de ellos tienen alias m&#225;s elegantes que puedes utilizar en su lugar. Primero presentar&#233; los <emph>cmdlets</emph> con sus nombres, pero siempre usar&#233; los alias est&#225;ndar, porque son mucho m&#225;s r&#225;pidos para trabajar. Es importante tener en cuenta que muchos <emph>cmdlets</emph> tienen varios alias. Por ejemplo, <code rend="inline">Get-ChildItem</code>,<code rend="inline"> gci</code>, <code rend="inline">dir</code> y<code rend="inline"> ls</code> hacen exactamente lo mismo. Aunque no sorprende que <code rend="inline">gci</code> sea la abreviatura de<code rend="inline"> Get-ChildItem</code>, es posible que te preguntes de d&#243;nde provienen <code rend="inline">dir</code> y<code rend="inline"> ls</code>.</p>
<p>PowerShell es relativamente nuevo (se lanz&#243; por primera vez en 2006), y sus dise&#241;adores esperaban que muchas personas que lo utilizar&#237;an ya tendr&#237;an experiencia con algunas CLI existentes (interfaces de l&#237;nea de comandos), espec&#237;ficamente con el CLI m&#225;s antiguo de Microsoft llamado S&#237;mbolo de sistema (<emph>command prompt</emph>) o con Linux CLIs como Bash, que ahora tambi&#233;n es est&#225;ndar en OS X. Por lo tanto, muchos <emph>cmdlets</emph> tienen un alias que es el comando est&#225;ndar en uno de estos dos sistemas (y a menudo para ambos). En el ejemplo presente, <code rend="inline">dir</code> viene de S&#237;mbolo de sistema, y<code rend="inline"> ls</code> proviene de Bash. Utilizar&#233; los alias de estilo "PowerShell" en este tutorial, ya que hace m&#225;s f&#225;cil recordar los nombres reales de <emph>cmdlet</emph>. Sin embargo, intentar&#233; tambi&#233;n mencionar otros alias comunes, particularmente aquellos familiares para los usuarios de Bash. Si trabajas con mucha gente que usa OS X o Linux, puede ser bueno conocer estos nombres. La <ref target="#referencia-r%C3%A1pida">tabla en la parte inferior</ref> proporciona los <emph>cmdlets</emph> junto con sus alias est&#225;ndar de PowerShell y el equivalente de Bash m&#225;s cercano.</p>
<p>Sigue adelante e intenta usar <code rend="inline">gci</code>,<code rend="inline"> dir</code> y <code rend="inline">ls</code>. Obtendr&#225;s exactamente la misma lista de cosas. La mayor&#237;a de estas cosas ser&#225;n directorios. Uno de ellos debe ser tu escritorio. Vamos a entrar en ese directorio.</p>
</div><div type="3"><head>Navegar entre directorios con <code rend="inline">Set-Location</code> (<code rend="inline"> sl</code>, <code rend="inline">cd</code>)</head>
<p>Para desplazarte a tu escritorio, usaremos el <emph>cmdlet</emph> <code rend="inline">Set-Location</code>. Escribe en PowerShell:</p>
<p><code rend="inline">sl desktop</code></p>
<p>Esto le indica a PowerShell que se mueva al escritorio. Observa que puedes escribir "desktop" usando todas las letras min&#250;sculas, aunque cuando viste el contenido del directorio <code rend="inline">TUNOMBREDEUSUARIO</code>, "Desktop" se escribi&#243; con una "D" may&#250;scula. PowerShell no distingue entre may&#250;sculas y min&#250;sculas. Ahora que has cambiado tu ubicaci&#243;n, puedes usar <code rend="inline">gci</code> para ver una lista de todo lo que hay en tu escritorio, es decir, todo el directorio llamado<code rend="inline"> Desktop</code>. Si est&#225;s tan desorganizado como yo, esta ser&#225; una larga lista. Podemos volver al directorio <code rend="inline">TUNOMBREDEUSUARIO</code> escribiendo:</p>
<p><code rend="inline">sl ..</code></p>
<p>&#161;No olvides el espacio! Ahora escribe de nuevo:</p>
<p><code rend="inline">sl ..</code></p>
<p>Debes estar en el directorio <code rend="inline">Users</code>.</p>
<p>Ahora trata de volver al escritorio y luego de nuevo a <code rend="inline">Users</code>. Debe tomarte escribir cuatro comandos: <code rend="inline">sl TUNOMBREDEUSUARIO</code>, <code rend="inline">sl desktop</code>, <code rend="inline">sl ..</code>, <code rend="inline">sl ..</code>. Pero en realidad puedes hacerlo con s&#243;lo dos. Deber&#237;as estar en <code rend="inline">C:\Users&gt;</code> ahora mismo. En lugar de escribir <code rend="inline">sl TUNOMBREDEUSUARIO</code> y luego <code rend="inline">sl desktop</code>, puedes escribir solamente:</p>
<p><code rend="inline">sl TUNOMBREDEUSUARIO\desktop</code></p>
<p>&#161;Y llegar al escritorio con un comando! Del mismo modo, desde el escritorio, escribiendo:</p>
<p><code rend="inline">sl ..\..</code></p>
<p>Puedes volver a donde comenzaste con un comando. Si no tienes la resistencia del dedo me&#241;ique para escribir <code rend="inline">\</code> todo el tiempo, tambi&#233;n puedes escribir <code rend="inline">sl ../ ..</code>. No s&#243;lo PowerShell no distingue entre may&#250;sculas y min&#250;sculas, sino que tampoco le importa en qu&#233; direcci&#243;n va la barra. <code rend="inline">Sl ../ ..</code>, <code rend="inline">SL .. \ ..</code>, <code rend="inline">Set-Location .. \ ..</code> y <code rend="inline">set-location ../ ..</code> todos hacen exactamente lo mismo.</p>
</div><div type="3"><head>Creaci&#243;n de nuevos directorios con <code rend="inline">mkdir</code></head>
<p>Estamos avanzando hacia el trabajo con archivos. Antes de comenzar, hagamos un directorio donde podamos almacenar todo lo que estamos usando para esta lecci&#243;n. Navega de regreso a casa escribiendo:</p>
<p><code rend="inline">sl ~</code></p>
<p>Haremos un nuevo directorio dentro del directorio <code rend="inline">TUNOMBREDEUSUARIO</code>. Para ello, utilizaremos el comando <code rend="inline">mkdir</code>. Llama a tu directorio como quieras, pero trata de no usar espacios, ya que hacen que trabajar en l&#237;nea de comandos sea m&#225;s complicado de lo necesario. Voy a llamar a mi directorio "diversionConPowerShell". Entonces yo escribo:</p>
<p><code rend="inline">mkdir diversionConPowerShell</code></p>
<p>&#191;Viste c&#243;mo utilizo <ref target="https://es.wikipedia.org/wiki/CamelCase">CamelCase</ref> para evitar los espacios?</p>
<p>Otra forma com&#250;n de hacer esto es insertando gui&#243;n o gui&#243;n bajo, como en <code rend="inline">diversion_con_power_shell</code>. Sea cual sea el nombre de tu directorio, trata de evitar el uso de espacios. Una vez que has estado trabajando con PowerShell un poco, probablemente te encontrar&#225;s nombrando a tu nuevos archivos sin espacios por defecto. Este es un buen h&#225;bito ya que simplifica el trabajo en la l&#237;nea de comandos, as&#237; como al trabajar con lenguajes de programaci&#243;n como Python.</p>
<p>Sin embargo, es probable que tengas un mont&#243;n de archivos ya existentes con espacios en sus nombres. Para abrir estos en PowerShell, s&#243;lo tienes que utilizar comillas. Intentemos esto. Muevete a tu nuevo directorio utilizando:</p>
<p><code rend="inline">sl diversionConPowerShell</code></p>
<p>(O como hayas nombrado tu directorio). Escribe:</p>
<p><code rend="inline">gci</code></p>
<p>Y ver&#225;s que no hay nada aqu&#237;. &#161;Eso es porque no has puesto nada en &#233;l! Vamos a poner un nuevo directorio dentro con <code rend="inline">mkdir</code>. Llamaremos a este directorio "Directorio con un nombre largo y muchos espacios". Debido a que el nombre tiene espacios en &#233;l, tendremos que usar comillas para crearlo. Tipo</p>
<p><code rend="inline">mkdir "Directorio con un nombre largo y muchos espacios"</code></p>
<p>Presiona Enter. Ahora escribe:</p>
<p><code rend="inline">gci</code></p>
<p>Y ver&#225;s tu nuevo directorio. Supongamos que queremos movernos a este directorio. Tendr&#237;amos que escribir <code rend="inline">sl "Directorio con un nombre largo y muchos espacios"</code>. No solo tomar&#225; un tiempo escribirlo sino que, si nos equivocamos, PowerShell no podr&#225; encontrar nuestro directorio. En su lugar, escribe simplemente:</p>
<p><code rend="inline">sl d</code> y entonces oprime la tecla de tabulador.</p>
<p>Voil&#224;! &#161;PowerShell completa el nombre del directorio por nosotros, incluidas las comillas! El uso del tabulador para completar autom&#225;ticamente te ahorrar&#225; mucho tiempo. Notar&#225;s que cuando PowerShell complet&#243; el nombre, tambi&#233;n puso <code rend="inline">.\</code> al principio del nombre del directorio. El punto es solo una abreviatura de directorio actual. Cuando escribes &#243;rdenes, PowerShell siempre asume que hay un <code rend="inline">.\</code>al principio -en otras palabras, que te est&#225;s refiriendo a algo en el directorio actual-. Por lo tanto, no es necesario que escribas esta parte, a menos que quieras que PowerShell busque en otro lugar lo que est&#225;s pidiendo que haga, en cuyo caso puedes escribir la ruta de ese directorio. Por ejemplo: <code rend="inline">C:\directorio\bla\etc</code>.</p>
<p>Practiquemos un poco m&#225;s con directorios antes de comenzar con archivos.</p>
</div><div type="3"><head>Uso de <code rend="inline">Explorer</code>para ver directorios en la GUI</head>
<p>Hasta ahora hemos hecho dos directorios. He mencionado anteriormente que "directorio" es solo otra palabra para "carpeta". Puedes verlo al mirar tus nuevos directorios en la GUI. Windows llama a su GUI "Explorador de archivos" o simplemente "Explorador". Podemos llamar al Explorador desde PowerShell utilizando el comando "Explorer". Vuelve a la carpeta diversionConPowerShell con:</p>
<p><code rend="inline">sl ..</code></p>
<p>Ahora escribe:</p>
<p><code rend="inline">explorer .</code></p>
<p>Recuerda que el punto solamente significa "este directorio", y no tienes que escribir con may&#250;scula "explorer" porque las may&#250;sculas no importan en PowerShell. Explorador deber&#237;a haber abierto una ventana que muestra el contenido del directorio "diversi&#243;nConPowerShell". Organiza tus ventanas para que puedas ver tanto la imagen en Explorador como en PowerShell. Ahora podr&#225;s ver que lo que haces en PowerShell aparece en Explorador. El comando "Explorer" es extremadamente &#250;til. B&#225;sicamente, es como hacer doble clic en la GUI. De tal manera, puedes utilizarlo para abrir archivos y programas.</p>
</div><div type="3"><head>Eliminaci&#243;n con <code rend="inline">Remove-Item</code> (<code rend="inline">rm</code>)</head>
<p>Ahora que puedes ver los resultados de lo que haces en PowerShell, aprendamos a borrar cosas, por ejemplo, aquel directorio con el nombre largo. Primero crearemos algunos directorios m&#225;s. N&#243;mbralos "dir", "dir1", y "dir2". Puedes crear los tres con un solo comando escribiendo:</p>
<p><code rend="inline">mkdir dir, dir1, dir2</code></p>
<p>Genial, &#191;no? Deber&#237;as ver tus tres nuevos directorios en la ventana abierta de Explorador (en la GUI).</p>
<p>Ahora vamos a deshacernos de ese directorio con el nombre largo. Para ello utilizaremos el <emph>cmdlet</emph> <code rend="inline">Remove-Item</code> o <code rend="inline">rm</code>. Tienes que ser <hi rend="bold">muy cuidadoso</hi> con este <emph>cmdlet</emph> pues no transfiere los &#237;tems borrados a la papelera o basurero de reciclaje, sino que <hi rend="bold">los elimina de manera permanente</hi>, as&#237; que lo puedes considerar borrado sin posibilidad de recuperarlo. Escribe <code rend="inline">rm</code> seguido de un espacio y el nombre largo de ese directorio del que nos queremos deshacer. Quiz&#225; quieras utilizar la tecla de tabulador para completar autom&#225;ticamente el nombre. Sin embargo ten en cuenta que, como ahora tenemos varios directorios que comienzan con la letra "d", tendr&#225;s que escribir algo m&#225;s que la primera letra para que se complete autom&#225;ticamente. Escribe:</p>
<p><code rend="inline">rm dire</code> y entonces presiona la tecla de tabulaci&#243;n.</p>
<p>De manera alternativa, puedes escribir solamente <code rend="inline">rm</code> y oprimir la tecla de tabulador varias veces para desplazarte por todos tus directorios. Si fuiste m&#225;s all&#225; del que te interesa, solamente oprime la tecla de may&#250;scula (<emph>shift</emph>) con tabulador para desplazarte hacia atr&#225;s.</p>
<p>Antes de presionar la tecla <code rend="inline">Enter</code>, yo observo con atenci&#243;n lo que escrib&#237; para asegurarme de que estoy borrando el &#237;tem que quiero eliminar. Solo entonces hago clic en <code rend="inline">Enter</code>.</p>
<p>Adelante. Borra los otros tres directorios y observa c&#243;mo desaparecen del Explorador. Igual que con <code rend="inline">mkdir</code>, puedes borrar los tres directorios de una sola vez con un comando. Int&#233;ntalo.</p>
<p>Acabamos de eliminar los directorios <code rend="inline">dir</code>,<code rend="inline"> dir1</code> y <code rend="inline">dir2</code>. Pero resulta que los necesitamos para el siguiente ejemplo. As&#237; que vamos a crearlos de nuevo. Pero ahora, en lugar de escribir la instrucci&#243;n, vamos a oprimir la flecha hacia arriba del teclado un par de veces (o las que sean necesarias). En alg&#250;n punto deber&#225;s ver el comando que usaste para crear los tres directorios la primera vez. Una vez que encuentres esa l&#237;nea pulsa Enter y se volver&#225;n a crear. De la misma manera que usar el tabulador (<code rend="inline">tab</code>) para completar autom&#225;ticamente, el uso de las flechas arriba y abajo para desplazarte por los comandos recientes te ahorrar&#225; mucho tiempo. <hi rend="bold">Considera que no estamos deshaciendo el borrado que hicimos con anterioridad</hi>. Por el contrario, estamos usando un "acceso directo" para ingresar de nuevo un comando que hemos usado recientemente.</p>
</div><div type="3"><head>Entender la estructura de &#225;rbol del sistema de archivos de tu computadora</head>
<p>Ahora debes tener tres directorios dentro de tu directorio <code rend="inline">diversionConPowerShell</code>. Despl&#225;zate al interior del directorio <code rend="inline">dir</code> (utiliza <code rend="inline">sl dir</code>)</p>
<p>Es importante entender la manera en la que tu computadora organiza las cosas. Observa la ruta a tu directorio actual. La ruta es todo lo que escribiste despu&#233;s del <emph>prompt</emph>. En mi caso es:</p>
<p><code rend="inline">C:\Users\Ted\diverionConPowerShell\dir</code></p>
<p>Tu ruta debe verse bastante similiar. Lo que representa esta ruta en realidad es una structura parecida a un &#225;rbol que sigue el ordenador para llegar al punto en el que est&#225;s. El tronco del &#225;rbol es <code rend="inline">C:</code>, que es tu disco duro. En realidad, en la mayor&#237;a de las computadoras modernas <code rend="inline">C:</code>es una partici&#243;n de su disco duro. &#191;Por qu&#233; se llama <code rend="inline">C</code>? El ordenador asigna una letra a cada una de las unidades. <code rend="inline">A</code>y <code rend="inline">B</code>est&#225;n reservados para las dos unidades de disquettes que hace mucho tiempo utilizaban con frecuencia los usuarios para interactuar con los discos duros de sus computadoras. Aunque la mayor&#237;a de los ordenadores ya no los tienen, los nombres quedaron reservados.</p>
<p>Si <code rend="inline">C:</code> es el tronco del &#225;rbol, cada secci&#243;n de la ruta despu&#233;s de <code rend="inline">C:</code> es una rama, de la cual salen otras que est&#225;n por encima de ella. As&#237;, <code rend="inline">Users</code> es una rama de <code rend="inline">C:</code>, <code rend="inline">Ted</code> es una rama m&#225;s peque&#241;a que sale de <code rend="inline">Users</code> y as&#237; sucesivamente. Tambi&#233;n se puede usar la met&#225;fora de la herencia en lugar de la de la bot&#225;nica y llamar a cada rama un <code rend="inline">hijo</code> del directorio por encima de ella. Este es el lenguaje m&#225;s com&#250;n para describir las relaciones entre los directorios (de ah&#237; el cmdlet <code rend="inline">Get-ChildItem</code>), pero nos quedaremos con la met&#225;fora del &#225;rbol ya que, en la vida real, las relaciones de herencia pueden ser mucho m&#225;s complejas que la extremadamente jer&#225;rquica estructura seg&#250;n la cual est&#225; organizada tu computadora.</p>
<p>Entender que la ruta funciona como un &#225;rbol es importante para poder navegar por los directorios que no est&#225;n inmediatamente por encima o por debajo de tu directorio actual. Sabemos que hay un directorio llamado "dir1", y que &#233;ste directorio tambi&#233;n est&#225; en el directorio "diverionConPowerShell". Ve lo que sucede si intentas usar <code rend="inline">sl</code> para pasar directamente a &#233;l escribiendo:</p>
<p><code rend="inline">sl dir1</code></p>
<p>&#161;Esto arroja error!</p>
<figure><desc>Error por intentar saltar entre ramas</desc><graphic url="intro-to-powershell3.png"/></figure>
<p>El problema es que intentamos saltar de una rama a otra, y PowerShell s&#243;lo entiende nuestro movimiento si nos desplazamos a lo largo del &#225;rbol. Eso significa que primero tenemos que movernos hasta donde se encuentran las ramas de "dir1" y "dir", y luego volver a "dir1". Puedes hacerlo con un comando. Veamos si puedes imaginarlo antes de leer la siguiente l&#237;nea.</p>
<p>El comando es:</p>
<p><code rend="inline">sl ..\dir1</code></p>
<p>Esto le indica a PowerShell subir un directorio a <code rend="inline">diversionConPowerShell</code>, y luego bajar al directorio <code rend="inline">dir1</code>.</p>
</div><div type="3"><head>Moverse r&#225;pido con <code rend="inline">Push-Location</code>(<code rend="inline">pushd</code>) y <code rend="inline">Pop-Location</code> (<code rend="inline">popd</code>)</head>
<p>Antes de trabajar con archivos vamos a probar los comandos <code rend="inline">push</code>y <code rend="inline">popd</code>. Haz lo siguiente: ve hasta el tronco del &#225;rbol.<code rend="inline">C:</code>.deben ser cuatro directorios arriba del directorio en el que est&#225;s, por lo cual podr&#237;as escribir:</p>
<p><code rend="inline">sl ..\..\..\..</code></p>
<p>Entonces cambia de nuevo a <code rend="inline">dir1</code>. Pero en vez de escribir <code rend="inline">sl</code>antes de la ruta, escribe <code rend="inline">pushd</code>. Como esto:</p>
<p><code rend="inline">pushd users\TUNOMBREDEUSUARIO\diversionConPowerShell\dir1</code></p>
<p>Ahora estar&#225;s en el directorio como si hubieras escrito <code rend="inline">sl</code> al principio de la ruta. Pero aqu&#237; est&#225; la parte divertida. Ahora escribe:</p>
<p><code rend="inline">popd</code></p>
<p>Y pulsa Enter. Genial, &#191;no? El comando <code rend="inline">pushd</code> indica a PowerShell que se mueva a un directorio determinado desde tu directorio actual al que puedes ser devuelto con <code rend="inline">popd</code>. En otras palabras, <code rend="inline">popd</code> siempre te regresar&#225; al &#250;ltimo directorio en el cual estuviste antes de usar <code rend="inline">pushd</code>. Si quieres entender m&#225;s sobre lo que est&#225; pasando, lee sobre la <ref target="https://es.wikipedia.org/wiki/Pila_de_llamadas">pila de llamadas</ref> en Wikipedia. El uso de <code rend="inline">pushd</code> y <code rend="inline">popd</code> es muy &#250;til cuando te mueves con frecuencia entre dos directorios.</p>
</div></div><div type="2"><head>Trabajar con archivos</head>
<p>Ahora que sabes c&#243;mo moverte a trav&#233;s del sistema de archivos de tu computadora desde la l&#237;nea de comandos, vamos a trabajar manipulando archivos. Comenzaremos por aprender a <hi rend="bold">crear</hi> nuevos archivos, <hi rend="bold">copiarlos</hi> y <hi rend="bold">moverlos</hi>.</p>
<div type="3"><head>Crear archivos con <code rend="inline">New-Item</code> (<code rend="inline">ni</code>)</head>
<p>Primero, necesitamos algunos archivos para trabajar con ellos. Hagamos un nuevo documento de texto plano llamado "ejemplo.txt". Navega hasta el directorio <code rend="inline">diversionConPowerShell</code> -utiliza el tabulador para cada nombre de directorio que escribas y acelerar el proceso-, y escribe:</p>
<p><code rend="inline">ni ejemplo.txt</code></p>
<p>Presiona Enter. Despu&#233;s ecribe:</p>
<p><code rend="inline">gci</code></p>
<p>para que confirmes, en efecto, que ahora tienes el archivo <code rend="inline">ejemplo.txt</code> adem&#225;s de tus directorios. Necesitaremos varios archivos as&#237; que, adelante: crea <code rend="inline">ejemplo1.txt</code> y <code rend="inline">ejemplo2.txt</code>. No te sorprender&#225; saber que, incluyendo una coma, puedes hacer esto con un solo comando:</p>
<p><code rend="inline">ni ejemplo1.txt, ejemplo2.txt</code></p>
</div><div type="3"><head>Copiar y mover archivos con <code rend="inline">Copy-Item</code>(<code rend="inline">cp</code>) y <code rend="inline">Move-Item</code> (<code rend="inline">mv</code>)</head>
<p>Quiz&#225; deber&#237;amos haber puesto estos archivos en un directorio. Mov&#225;moslos. Pongamos <code rend="inline">ejemplo.txt</code> en <code rend="inline">dir</code> escribiendo:</p>
<p><code rend="inline">mv ejemplo.txt dir</code></p>
<p>Ahora escribe <code rend="inline">gci</code> y ver&#225;s que <code rend="inline">ejemplo.txt</code> ha desaparecido. Entra a <code rend="inline">dir</code> (<code rend="inline">sl dir</code>) y escribe <code rend="inline">gci</code> para que compruebes que &#161;ahora est&#225; ah&#237;! Tambi&#233;n puedes hacer esto sin cambiar de directorio escribiendo <code rend="inline">gci dir</code> desde el directorio <code rend="inline">diversionConPowerShell</code>. Regresa a <code rend="inline">diversionConPowerShell</code> y mueve <code rend="inline">ejemplo1.txt</code> a <code rend="inline">dir1</code> y <code rend="inline">ejemplo2.txt</code> a <code rend="inline">dir2</code>.</p>
<p>Tambi&#233;n podemos utilizar <code rend="inline">mv</code> para <hi rend="bold">renombrar</hi> &#237;tems. Usa <code rend="inline">sl</code> para moverte a <code rend="inline">dir</code>. Escribe <code rend="inline">gci</code> y deber&#225;s ver tu archivo <code rend="inline">ejemplo.txt</code>. Es un nombre aburrido, as&#237; que llam&#233;mosle <code rend="inline">benjamin.txt</code>. Escribe:</p>
<p><code rend="inline">mv ejemplo.txt benjamin.txt</code></p>
<p>Utiliza <code rend="inline">gci</code> de nuevo para confirmnar que tu documento ahora se llama <code rend="inline">bejamin.txt</code>.</p>
<p>Te sorprender&#225; que el mismo <emph>cmdlet</emph> se utiliza tanto para mover como para renombrar archivos. De hecho, la operaci&#243;n es la misma. En ambos casos le est&#225;s diciendo a la computadora que cambie el "nombre" de la ubicaci&#243;n del archivo, es decir, que cambie la <hi rend="bold">ruta</hi> que sigue para encontrar el archivo. En el primer ejemplo, la ruta comenz&#243; como:</p>
<p><code rend="inline">C:\Users\Ted\diversionConPowerShell\ejemplo.txt</code></p>
<p>Y luego cambi&#243; a:</p>
<p><code rend="inline">C:\Users\Ted\diversionConPowerShell\dir\ejemplo.txt</code></p>
<p>En el segundo ejemplo, la ruta cambi&#243; de:</p>
<p><code rend="inline">C:\Users\Ted\diversionConPowerShell\dir\ejemplo.txt</code></p>
<p>a:</p>
<p><code rend="inline">C:\Users\Ted\diversionConPowerShell\dir\benjamin.txt</code></p>
<p>Dicho de otro modo, en ambos ejemplos <code rend="inline">mv</code> solamente cambia la ruta. No te preocupes si esto no te hace sentido por ahora. S&#243;lo ten cuidado de escribir correctamente las rutas cuando utilices <code rend="inline">mv</code> porque, si no lo haces, puedes cambiar el nombre cuando lo que quieres es mover el archivo, o viceversa.</p>
<p>Adem&#225;s de mover archivos, tambi&#233;n quisi&#233;ramos copiarlos o eliminarlos. Para copiar archivos, utilizamos el <emph>cmdlet</emph> <code rend="inline">Copy-Item</code> o<code rend="inline"> cp</code>. Hagamos dos copias de <code rend="inline">benjamin.txt</code> y llam&#233;moslas <code rend="inline">steven.txt</code> y <code rend="inline">susie.txt</code>.</p>
<p><code rend="inline">cp benjamin.txt steven.txt</code></p>
<p><code rend="inline">cp benjamin.txt susie.txt</code></p>
<p>Tambi&#233;n podemos eliminar estos dos nuevos archivos con <code rend="inline">rm</code>, al igual que hicimnos con los directorios. Intenta hacerlo con un solo comando. Como siempre, ten cuidado cuando utilices <code rend="inline">rm</code>.</p>
<p>&#201;ste es el comando:</p>
<p><code rend="inline">rm steven.txt, susie.txt</code></p>
<p>&#161;Adi&#243;s Steven y Susie!</p>
<figure><desc>Mover, copiar y borrar</desc><graphic url="intro-to-powershell4.png"/></figure>
</div></div></div>
      <div type="1"><head>Haciendo m&#225;s</head>
<p>Bien, ahora ya podemos navegar, crear archivos, moverlos y borrarlos en PowerShell. Nos sentimos muy bien, muy <emph>geeks</emph> porque podemos hacer estas cosas desde la l&#237;nea de comandos. Pero esto no es realmente &#250;til ya que pod&#237;amos hacer estas cosas muy f&#225;cilmente con la interfaz gr&#225;fica de usuario. Ahora que sabemos estos fundamentos, sin embargo, podemos comenzar a aprender comandos algo m&#225;s complejos que pueden ser &#250;tiles en nuestro trabajo como humanistas digitales.</p>
<h3>Escribir en archivos con <code rend="inline">Write-Output</code> (<code rend="inline">write</code>, <code rend="inline">echo</code>) y redirecci&#243;n</h3>
<p>Tenemos un archivo vac&#237;o en nuestro directorio <code rend="inline">dir</code>. Eso no es muy interesante, as&#237; que vamos a a&#241;adir un poco de contenido. Podr&#237;amos abrir el archivo en el Bloc de notas y modificarlo de esa manera. Pero tambi&#233;n podemos a&#241;adirle contenido con &#243;rdenes desde la l&#237;nea de comandos. El <emph>cmdlet</emph> que utilizamos para esto es <code rend="inline">Write-Output</code>, o simplemente <code rend="inline">write</code>.</p>
<p>Prueba con esto:</p>
<p><code rend="inline">write "La t&#233;cnica de la reproducci&#243;n separa el objeto reproducido del dominio de la tradici&#243;n."</code></p>
<p>PowerShell debe imprimir esta frase directamente en la ventana de la l&#237;nea de comandos. Eso es todo lo que hace <code rend="inline">write</code>. Le dice a PowerShell "Imprime lo que yo escriba". Eso no es muy &#250;til dado que queremos poner este texto en nuestro documento. Para ello, usaremos algo llamado <hi rend="bold">redirecci&#243;n</hi>.</p>
<p>Redirecci&#243;n es una forma de decirle a PowerShell que tome los resultados de un comando y los coloque en alg&#250;n lugar que no sea en la ventana de PowerShell. Para redirigir un comando, ponemos un par&#233;ntesis angular derecho (<code rend="inline">&gt;</code>) entre el comando y el lugar donde queremos que vaya su salida. En este caso, queremos que la salida de nuestro comando <code rend="inline">write</code> termine en<code rend="inline"> benjamin.txt</code>. As&#237; que usamos la flecha hacia arriba para recuperar la declaraci&#243;n, y a&#241;adimos <code rend="inline">&gt; benjamin.txt</code> al final. Todo el asunto deber&#237;a ser as&#237;:</p>
<p><code rend="inline">write "La t&#233;cnica de la reproducci&#243;n separa el objeto reproducido del dominio de la tradici&#243;n." &gt; benjamin.txt</code></p>
<p>Cuando presiones Enter parecer&#225; que nada sucede. Esto se debe a que la instrucci&#243;n <code rend="inline">write</code> fue redirigida. Para ver qu&#233; es lo que realmente ocurri&#243;, usa <code rend="inline">gci</code> para ver el contenido de tu directorio. Ten en cuenta que la longitud de <code rend="inline">benjamin.txt</code> ya no es 0. &#161;Esto es porque acabamos de poner texto en &#233;l!</p>
<h3>Leer archivos con <code rend="inline">Get-Content</code> (<code rend="inline">gc</code>, <code rend="inline">cat</code>)</h3>
<p>Ya que <code rend="inline">gci</code> nos muestrta que hay algo en el archivo, ser&#237;a bueno poder ver qu&#233; frase pusimos en &#233;l. Podr&#237;amos hacerlo con el comando: <code rend="inline">notepad benjamin.txt</code>, lo que abrir&#237;a el documento en el Bloc de notas. Pero tambi&#233;n hay un <emph>cmdlet</emph> para imprimir el contenido del archivo en PowerShell que se llama <code rend="inline">Get-Content</code>. Escribe:</p>
<p><code rend="inline">gc benjamin.txt</code></p>
<p>&#161;Y ah&#237; est&#225; tu frase!</p>
<p>Ustilizar <code rend="inline">gc</code> es &#250;til por s&#237; mismo, pero no resulta tan interesante. Si lo combinamos con la redirecci&#243;n, podemos hacer mucho m&#225;s. Para empezar, podemos poner el contenido de un archivo en otro, casi igual que copiar un archivo. Ya sabes c&#243;mo hacerlo con <code rend="inline">cp</code>. Haz una copia de <code rend="inline">benjamin.txt</code> llamada <code rend="inline">benjamin1.txt</code> usando <code rend="inline">cp</code>. Ese comando se ver&#225; as&#237;:</p>
<p><code rend="inline">cp benjamin.txt benjamin1.txt</code></p>
<p>Ahora haz un archivo <code rend="inline">benjamin2.txt</code> con el mismo contenido que<code rend="inline"> benjamin.txt</code>, pero usando <code rend="inline">gc</code> y redirecci&#243;n. Intenta averiguar c&#243;mo se hace.</p>
<p>En caso de que no lo logres, aqu&#237; est&#225; la respuesta:</p>
<p><code rend="inline">gc benjamin.txt &gt; benjamin2.txt</code></p>
<p>Por supuesto que esto es solamente una forma m&#225;s engorrosa de hacer lo que ya podemos hacer con <code rend="inline">cp</code>. Pero la diferencia en estos m&#233;todos es sustancial porque al usar <code rend="inline">gc</code> podemos agregar informaci&#243;n a un archivo de texto sin reemplazar lo que ya est&#225; all&#237;, y tambi&#233;n podemos obtener el contenido de varios archivos de texto y ponerlos en otro.</p>
<p>En primer lugar vamos a aprender a adjuntar. Necesitamos algo que a&#241;adir a texto as&#237; que hagamos un nuevo archivo llamado <code rend="inline">siguiente.txt</code> y escribamos la frase "Haciendo muchas reproducciones sustituye una pluralidad de copias para una existencia &#250;nica." Podr&#237;amos hacer nuestro archivo primero con <code rend="inline">ni</code>, pero no es necesario. Si le decimos a PowerShell que escriba en un archivo que no est&#225; en tu directorio, lo crear&#225; para nosotros. As&#237; podemos simplemente escribir:</p>
<p><code rend="inline">write "Haciendo muchas reproducciones sustituye una pluralidad de copias para una existencia &#250;nica." &gt; siguiente.txt</code></p>
<p>Utiliza <code rend="inline">gc</code>para comprobar que se cre&#243; <code rend="inline">siguiente.txt</code> y que es realmente lo que queremos que sea.</p>
<p>Ahora vamos a agregar el contenido de <code rend="inline">siguiente.txt</code> a <code rend="inline">benjamin.txt</code> usando <code rend="inline">gc</code>y redirecci&#243;n. Parece simple, &#191;verdad? Int&#233;ntalo con este comando:</p>
<p><code rend="inline">gc siguiente.txt &gt; benjamin.txt</code></p>
<p>Luego comprueba lo que sucedi&#243; con el comando <code rend="inline">gc benjamin.txt</code>. Ver&#225;s que efectivamente pusiste el contenido de <code rend="inline">siguiente.txt</code> en<code rend="inline"> benjamin.txt</code>, pero has <emph>reemplazado</emph> el contenido que ya estaba all&#237; y &#161;esto no es lo que quer&#237;amos hacer!</p>
<p>Al usar <code rend="inline">&gt;</code>, le ordenamos a PowerShell que pusiera el contenido de un texto en otro y sobrescribi&#243; lo que ya estaba all&#237;. Podemos arreglar esto usando <code rend="inline">&gt;&gt;</code> para nuestro redireccionamiento en lugar de un solo <code rend="inline">&gt;</code>. Esto le dice a PowerShell que agregue la nueva informaci&#243;n. Prueba esto:</p>
<p><code rend="inline">gc siguiente.txt &gt;&gt; benjamin1.txt</code></p>
<p>Utiliza <code rend="inline">gc</code> para comprobar que <code rend="inline">benjamin1.text</code> ahora tiene ambas frases.</p>
<figure><desc>La diferencia entre `&gt;` y `&gt;&gt;`</desc><graphic url="intro-to-powershell5.png"/></figure>
<p>Ahora veamos c&#243;mo obtener el contenido de varios archivos al mismo tiempo.</p>
<h3>Trabajar con varios archivos a la vez usando caracteres comod&#237;n (<code rend="inline">*</code>)</h3>
<p>Ahora debes tener cuatro archivos en tu directorio, cada uno con una o dos frases del ensayo sobre el arte de Walter Benjamin. Es posible que hayas perdido la pista de lo que est&#225; exactamente en ellos. Utilicemos <code rend="inline">gc</code> para comprobar el contenido.</p>
<p>Podr&#237;amos ver cada uno individualmente. Pero como puedes haber adivinado se puede mostrar el contenido de los cuatro archivos con un solo comando. Escribe:</p>
<p><code rend="inline">gc benjamin.txt, benjamin1.txt, benjamin2.txt, siguiente.txt</code></p>
<p>y obtendr&#225;s la frase impresa tres veces. Podemos hacerlo a&#250;n m&#225;s r&#225;pidamente. Int&#233;ntalo:</p>
<p><code rend="inline">gc *.txt</code></p>
<p>El resultado ser&#225; exactamente el mismo. Lo que hace <code rend="inline">*.txt</code> es decirle a PowerShell que encuentre todo lo que termine con <code rend="inline">.txt</code>. El <code rend="inline">*</code> se llama <hi rend="bold">comod&#237;n</hi>, y se puede usar para reemplazar cualquier parte de un nombre de archivo. Escribe <code rend="inline">gc ben*</code> y obtendr&#225;s s&#243;lo los textos que comiencen con "ben". Dado que los &#250;nicos archivos de este directorio son los cuatro que queremos, puedes incluso escribir <code rend="inline">gc *</code> y obtener el contenido que nos interesa haciendo que PowerShell juestre todo lo que est&#225; en el directorio.</p>
<h3>B&#250;squedas con <code rend="inline">Select-String</code> (<code rend="inline">sls</code>)</h3>
<p>Por supuesto que no siempre queremos ver todo el contenido sino que querramos encontrar contenido espec&#237;fico. Al utilizar <code rend="inline">*</code>, podemos buscar varios archivos al mismo tiempo. Una de nuestras oraciones ten&#237;a algo acerca de "existencia &#250;nica", &#191;no? &#191;Donde fue eso? Podemos usar el <emph>cmdlet</emph> <code rend="inline">Select-String</code> para buscar fragmentos espec&#237;ficos de texto. Escribe:</p>
<p><code rend="inline">sls "existencia &#250;nica" *.txt</code></p>
<p>y PowerShell arrojar&#225; todas las l&#237;neas que contengan esa cadena de caracteres de cualquier archivo de nuestro directorio que termine en <code rend="inline">.txt</code>.</p>
<p>El uso de <code rend="inline">sls</code> en archivos tan peque&#241;os como los nuestros no nos ahorrar&#225; mucho tiempo comparado con el que ocupar&#237;amos si ley&#233;ramos los archivos nosotros mismos. Pero el uso de este <emph>cmdlet</emph> con un mayor n&#250;mero de archivos, m&#225;s largos, puede ser extraordinariamente &#250;til.</p>
<h3>Bucles infinitos y abortar procesos con <code rend="inline">control-c</code></h3>
<p>Veamos una tarea m&#225;s &#250;til que podemos lograr combinando <code rend="inline">gc</code>, comodines y redirecci&#243;n. Supongamos que tenemos muchos archivos diferentes que queremos combinar en un nuevo archivo, por ejemplo, porque hemos descargado cientos de letras de canciones que necesitamos analizar y  agrupar las de un solo artista en un archivo &#250;nico. Aunque podr&#237;amos hacer esto especific&#225;ndolos todos, es decir, <code rend="inline">gc texto1, texto2, texto3&gt; nuevotexto</code>, al tener cientos de textos puede resultar una tarea bastante engorrosa. Los comodines sirven para evitar esto.</p>
<p>Vamos a concatenar nuestros cuatro textos y colocar el resultado en un quinto texto. Quiz&#225; usar <code rend="inline">*.txt</code> puede parecer un auxiliar pr&#225;ctico. <hi rend="bold">Estamos a punto de hacer algo tonto, as&#237; que por favor, lee el siguiente p&#225;rrafo antes de escribir este comando!</hi></p>
<p>Intentemos</p>
<p><code rend="inline">gc *.txt &gt; granben.txt</code></p>
<p>Parecer&#225; que tu computadora no hace nada. Pero, a diferencia de otras veces cuando tu computadora aparenta que no ha hecho nada, esta vez el prompt del s&#237;mbolo del sistema no vuelve a aparecer. Si intentas escribir otro comando no suceder&#225; nada. Esto es porque PowerShell todav&#237;a est&#225; trabajando en tu &#250;ltimo comando. A medida que haces m&#225;s y m&#225;s cosas complicadas con PowerShell, es algo que a veces sucede -&#161;est&#225;s haciendo sudar a tu computadora!-. Pero, en este caso, PowerShell nunca dejar&#225; de trabajar con este comando ya que est&#225; en un bucle infinito. Afortunadamente, puedes abortar esta tarea con:</p>
<p><code rend="inline">control-c</code></p>
<p>La utilidad de <code rend="inline">control-c</code> es grande, ya que a veces puedes quedar atrapado accidentalmente en un bucle infinito o, simplemente, puedes hartarte de esperar a que tu computadora haga ciertas tareas extremadamente largas.</p>
<p>&#191;C&#243;mo nos quedamos atrapados en ese bucle? Le dijimos a PowerShell que pusiera todos los archivos que terminaran en <code rend="inline">.txt</code> en un nuevo archivo que terminara en <code rend="inline">.txt</code>. Dado que ese nuevo archivo ca&#237;a bajo la r&#250;brica de archivos que el equipo deb&#237;a concatenar y agregar a <code rend="inline">granben.txt</code>, lo a&#241;adi&#243;. Y luego, ya que ten&#237;a un archivo <code rend="inline">.txt</code> con nuevo contenido, lo a&#241;adi&#243; tambi&#233;n. Este es un excelente ejemplo de algo que a menudo olvidamos sobre nuestras computadoras: no son inteligentes. Son extremadamente potentes pero carecen absolutamente de sentido com&#250;n. Los humanos miramos las instrucciones e intentamos interpretarlas. "No puede significar, para m&#237;, agregar el contenido del texto final de nuevo en s&#237; mismo una y otra vez para siempre." Los ordenadores, por otro lado, hacen exactamente lo que les decimos, sin importar lo il&#243;gicos que sean nuestros mandamientos. A medida que adquieras experiencia trabajando con la l&#237;nea de comandos, te sentir&#225;s desconcertado por las interpretaciones excesivamente literales de sus comandos, pero tambi&#233;n aprender&#225;n a darle instrucciones que puede seguir. Los bucles infinitos deben evitarse a toda costa, pero se producir&#225;n, y cuando lo hagan, recuerda: <code rend="inline">control-c</code>.</p>
<h3>Especificaci&#243;n de <emph>cmdlets</emph> con par&#225;metros</h3>
<p>Hemos visto que tu computadora necesita que le digan cosas de manera muy exacta. Afortunadamente, PowerShell proporciona m&#233;todos para refinar los <emph>cmdlets</emph> a&#241;adiendo par&#225;metros.</p>
<p>Veamos un ejemplo: utiliza <code rend="inline">gci</code> para comprobar que tienes cinco archivos en tu directorio. Uno de ellos, <code rend="inline">granben.txt</code>, es muy grande. Escribe:</p>
<p><code rend="inline">gc granben.txt</code></p>
<p>PowerShell comenzar&#225; a descargar una cantidad excesiva de texto en la pantalla. Es posible que quieras interrumpir el proceso con <code rend="inline">control-c</code>, pero esto no es un bucle infinito, s&#243;lo se trasta de un archivo muy grande, por lo que puedes esperar a que todo se imprima, s&#243;lo que tardar&#225; un tiempo. Al final, puedes usar el <emph>cmdlet</emph> <code rend="inline">clear</code> si te molesta el gran bloque de texto en la pantalla.</p>
<p>Lo que queremos comprobar es que "granben.txt" est&#225; compuesto por las l&#237;neas de los otros textos, repetidas una y otra vez. Podemos hacer esto mirando s&#243;lo al principio y al final, y para ello, agregamos un <hi rend="bold">par&#225;metro</hi> a nuestro <emph>cmdlet</emph>.</p>
<p>Introduce esto:</p>
<p><code rend="inline">gc granben.txt -totalcount 10</code></p>
<p>Ver&#225;s las primeras 10 l&#237;neas de tu texto. Aseg&#250;rate de incluir el gui&#243;n, ya que de lo contrario PowerShell no sabr&#225; que <code rend="inline">-TotalCount</code> es un par&#225;metro. Ahora escribe:</p>
<p><code rend="inline">gc granben.txt -tail 10</code></p>
<p>y ver&#225;s las &#250;ltimas 10 l&#237;neas. Lo que hemos hecho es especificarle a nuestro <emph>cmdlet</emph> <code rend="inline">gc</code> los par&#225;metros <code rend="inline">-totalcount</code> y <code rend="inline">-tail</code>. Casi todos los <emph>cmdlets</emph> pueden ser refinados a&#241;adiendo par&#225;metros como este. Pero, &#191;c&#243;mo sabemos qu&#233; par&#225;metros est&#225;n disponibles?</p>
<h3>M&#225;s informaci&#243;n sobre <code rend="inline">Get-Help</code></h3>
<p>PowerShell no espera que memorices todos los par&#225;metros posibles para todos los <emph>cmdlets</emph>^. En su lugar, proporciona una forma sencilla de enumerarlos utilizando el <emph>cmdlet</emph> <code rend="inline">Get-Help</code>. Escribe</p>
<p><code rend="inline">Get-Help gc</code></p>
<p>y obtendr&#225;s una pantalla que se ve as&#237;:</p>
<figure><desc>P&#225;ginas de ayuda de `Get-Content`</desc><graphic url="intro-to-powershell6.png"/></figure>
<p>Tu p&#225;gina puede ser ligeramente distinta, pero la parte importante para mirar en este momento es la secci&#243;n llamada "SYNTAX". Esta nos muestra todos los par&#225;metros que podemos agregar a <code rend="inline">Get-Content</code>. Si est&#225;s tratando de recordar el nombre exacto de un par&#225;metro que has utilizado antes, esta ayuda ser&#225; suficiente. Sin embargo, no nos dice lo que realmente hacen los par&#225;metros.</p>
<p>Afortunadamente, el mismo <code rend="inline">Get-Help</code> tiene par&#225;metros y, agregando <code rend="inline">-online</code> al <emph>cmdlet</emph> <code rend="inline">Get-Help</code>, le indicas a PowerShell que pida a tu navegador abrir una p&#225;gina en el portal TechNet de Microsoft que explica todos los par&#225;metros (en ingl&#233;s). Escribe:</p>
<p><code rend="inline">Get-Help gc -online</code></p>
<figure><desc>La p&#225;gina de ayuda en l&#237;nea para `Get-Content`</desc><graphic url="intro-to-powershell7.png"/></figure>
<p>Ah&#237; podemos ver la descripci&#243;n completa de los par&#225;metros <code rend="inline">-TotalCount</code> y <code rend="inline">-Tail</code>.</p>
<h3>Soluci&#243;n del problema de bucle infinito con el par&#225;metro <code rend="inline">-exclude</code></h3>
<p>Observa de nuevo la ayuda de <code rend="inline">Get-Content</code> y ver&#225;s que uno de los par&#225;metros es <code rend="inline">-exclude</code>. Esto suena prometedor para tratar con nuestro problema del bucle infinito. La descripci&#243;n en l&#237;nea dice: Omite los elementos especificados. El valor de este par&#225;metro califica el par&#225;metro de <hi rend="bold">ruta</hi>. Introduzca un elemento o patr&#243;n de ruta, como "*.txt". Los comodines est&#225;n permitidos." El "par&#225;metro de ruta" es, normalmente, lo que escribes inmediatamente despu&#233;s de tu <emph>cmdlet</emph>. Indica a PowerShell d&#243;nde se va a aplicar el <emph>cmdlet</emph>. Cuando escribimos <code rend="inline">gc benjamin.txt</code>, <code rend="inline">benjamin.txt</code> es la ruta. En realidad, es una abreviatura de <code rend="inline">.\Benjamin.txt</code>, que a su vez es una abreviatura de <code rend="inline">C:\Users\TUNOMBREDEUSUARIO\diversionConPowerShell\dir\benjamin.txt</code>. Esa l&#237;nea le dice a su computadora el camino a seguir a trav&#233;s de la estructura de tu sistema de archivos, similar a la de un &#225;rbol, para encontrar el archivo que deseas. Entonces, lo que la ayuda nos est&#225; diciendo es que podemos omitir elementos espec&#237;ficos de nuestro <emph>cmdlet</emph> <code rend="inline">gc</code> a&#241;adiendo el par&#225;metro <code rend="inline">-exclude</code> y luego ingresando la ruta que queremos que excluya. Podemos utilizar esto para tomar el contenido de todos nuestros archivos <code rend="inline">.txt</code> y ponerlos en un nuevo archivo sin crear un bucle infinito. Trata de averiguar qu&#233; escribir, utilizando lo que hicimos con <code rend="inline">-totalcount</code> y<code rend="inline"> -tail</code> como referencia.</p>
<p>Esto es lo que yo hice. Primero elimin&#233; mi <code rend="inline">granben.txt</code> actual con <code rend="inline">rm</code>. Aunque esto no es realmente necesario, ya que al usar un solo <code rend="inline">&gt;</code> en el rediccionamiento reemplazar&#237;a el contenido actual de todos modos, pero es agradable tener un inicio limpio. Entonces escrib&#237;:</p>
<p><code rend="inline">gc *.txt -exclude granben.txt &gt; granben.txt</code></p>
<p>Voil&#224;!</p>
<p>A lo largo de este proceso, hemos estado agregando textos juntos o concaten&#225;ndolos. Puedes obtener m&#225;s informaci&#243;n sobre <ref target="https://es.wikipedia.org/wiki/Concatenaci%C3%B3n">concatenaci&#243;n en Wikipedia</ref>, y si quieres ver algunos ejemplos m&#225;s de concatenaci&#243;n usando PowerShell, echa un vistazo a esta <ref target="https://blogs.technet.microsoft.com/heyscriptingguy/2014/07/15/keep-your-hands-clean-use-powershell-to-glue-strings-together">entrada de blog</ref> (en ingl&#233;s), que te llevar&#225; al maravilloso mundo de las variables, algo m&#225;s all&#225; del alcance de este tutorial, pero acerca de las que vale la pena aprender.</p>
<h3>Obtener m&#225;s provecho de los <emph>cmdlets</emph> con Piping</h3>
<p>Tenemos ahora cinco documentos en nuestro directorio. Con el fin de poder hacer cosas realmente &#250;tiles con ellos necesitamos una herramienta m&#225;s: <hi rend="bold">canalizaci&#243;n</hi>. &#201;sta es una especie de redirecci&#243;n, pero en lugar de decirle a PowerShell que coloque los resultados de un <emph>cmdlet</emph> en otro lugar, le dice que tome la salida de un <emph>cmdlet</emph> y lo use como entrada para otro. Donde usamos <code rend="inline">&gt;</code> para la redirecci&#243;n, para las canalizaciones usamos <code rend="inline">|</code>.</p>
<p>Vamos a obtener a&#250;n mayor rendimiento de <code rend="inline">gc</code>, canalizando los resultados al <emph>cmdlet</emph> <code rend="inline">measure-object</code> (o simplemente <code rend="inline">measure</code>). Este &#250;ltimo <emph>cmdlet</emph> tiene varias propiedades. Para nuestro prop&#243;sito, lo usaremos para obtener el n&#250;mero de l&#237;neas, palabras y caracteres en nuestros archivos agregando los par&#225;metros <code rend="inline">-line</code>,<code rend="inline"> -word</code> y <code rend="inline">-character</code>, o simplemente<code rend="inline"> -l</code>, <code rend="inline">-w</code>, <code rend="inline">-c</code>. (Con los par&#225;metros, s&#243;lo necesitas escribir el nombre adecuado para identificar el par&#225;metro en cuesti&#243;n. Utiliza <code rend="inline">Get-Help</code> para averiguar cu&#225;l ser&#225; para un determinado <emph>cmdlet</emph>).</p>
<p>Escribe esto:</p>
<p><code rend="inline">gc benjamin.txt | measure -l -w -c</code></p>
<p>Lo que debes obtener es un recuento de las l&#237;neas, palabras y caracteres del texto. Por supuesto, podr&#237;as hacer esto f&#225;cilmente con tu procesador de textos. Sin embargo, el poder que te da trabajar en l&#237;nea de comandos es el de ser capaz de manipular muchas cosas a la vez y especificar lo que quieres hacer con mucha mayor precisi&#243;n. En este ejemplo significa que podemos contar palabras en varios de nuestros archivos a la vez, y que podemos agregar par&#225;metros adicionales para especificar exactamente c&#243;mo queremos contarlos.</p>
<p>Obt&#233;n el recuento de l&#237;neas, palabras y caracteres de todos los archivos en el directorio. No deber&#237;a sorprendernos que el comod&#237;n (<code rend="inline">*</code>) pueda ser tambi&#233;n de gran ayuda. Por ejemplo, puedes escribir:</p>
<p><code rend="inline">gc *.txt | measure -l -w -c</code></p>
<p>Con nuestros cinco peque&#241;os archivos esto todav&#237;a no resulta muy vistoso, pero habr&#237;as perdido m&#225;s tiempo usando el procesador de textos. Tambi&#233;n podr&#237;amos hacerlo con un directorio que contenga miles de archivos largos. Tambi&#233;n podemos controlar nuestras acciones con mayor precisi&#243;n con par&#225;metros adicionales. Utiliza <code rend="inline">Get-Help measure</code> para ver los par&#225;metros a tu disposici&#243;n. Podr&#237;amos ir a la ayuda en l&#237;nea para aprender m&#225;s sobre ellos, pero por ahora vamos a usar uno que se explica por s&#237; mismo como un ejemplo que consiste en ignorar los espacios en blanco: <code rend="inline">-IgnoreWhiteSpace</code>.</p>
<p>Utiliza la flecha hacia arriba para recuperar tu &#250;ltimo comando y agrega <code rend="inline">-ignorewhitespace</code> al final. Tambi&#233;n puedes escribir <code rend="inline">-ig</code>. Ten en cuenta que <code rend="inline">-i</code> solo no es suficiente, ya que no diferencia el par&#225;metro <code rend="inline">-IgnoreWhiteSpace</code> del par&#225;metro <code rend="inline">-InputObject</code>, como te lo indicar&#225; un &#250;til mensaje de error si lo intentar&#225;s. Ver&#225;s el mismo recuento pero con menos caracteres, porque esta vez PowerShell no cont&#243; los espacios. La ventaja de la precisi&#243;n es clara sobre el uso de un procesador de textos, donde es dif&#237;cil determinar si se ignora o no el espacio en blanco en primer lugar, dejando de lado las posibilidades de cambiar funciones seg&#250;n tus necesidades.</p>
<h2>Utilizaci&#243;n de herramientas de l&#237;nea de comandos y ejecuci&#243;n de secuencias de comandos en Python</h2>
<p>La raz&#243;n m&#225;s importante para familiarizarse con el uso de la l&#237;nea de comandos no es la mayor precisi&#243;n o capacidad para trabajar con archivos, si bien estas caracter&#237;sticas son &#250;tiles. Su importancia radica en que permite el acceso a muchas herramientas adicionales, como se mencion&#243; en la introducci&#243;n. Cuando se configura PowerShell para trabajar con algunas de estas herramientas, puede tener problemas ya que, a veces, Windows dispone las rutas incorrectamente. La soluci&#243;n a este problema requiere de una configuraci&#243;n correcta de las <ref target="https://es.wikipedia.org/wiki/Variable_de_entorno">variables de entorno</ref>, un tema que va m&#225;s all&#225; del alcance de este tutorial. Afortunadamente, hay mucha infortmaci&#243;n disponible en l&#237;nea y con un poco de b&#250;squeda dar&#225;s con la soluci&#243;n que necesitas. Debido a que muchas lecciones de <emph>The Programming Historian</emph> en espa&#241;ol requieren que utilices Python, echaremos un vistazo brevemente a la configuraci&#243;n para Python. Una vez hecho esto, estar&#225;s menos intimidado por las instrucciones para establecer variables de entorno para otros programas.</p>
<p>Si a&#250;n no tienes Python, o si te preguntas por qu&#233; deber&#237;as usarlo, consulta el <ref target="/es/lecciones/introduccion-e-instalacion">tutorial de Python</ref> aqu&#237; en <emph>The Historian</emph> en espa&#241;ol. En dicho tutorial, aprender&#225;s a configurar Python para ejecutar secuencias de comandos directamente en un editor de texto. Pero, generalmente, ser&#225; muy &#250;til poder ejecutar <emph>scripts</emph> desde la l&#237;nea de comandos. Para ello, necesitamos establecer una variable de entorno. Primero, necesitas saber el nombre del directorio donde Python est&#225; instalado en tu computadora. Introduce <code rend="inline">sl C:\</code> y luego utiliza <code rend="inline">gci</code>. Deber&#237;as ver un directorio llamado "Python" con el n&#250;mero de versi&#243;n al final. En mi computadora, el directorio es "Python27". Ahora le ordenamos a Windows que cree una variable de ruta (<emph>Path</emph>) que apunte a ese directorio introduciendo esto en PowerShell, reemplazando "Python27" por el nombre del directorio en tu computadora:</p>
<p><code rend="inline">[Environment]::SetEnvironmentVariable("Path", "$env:Path;C:\Python27", "User")</code></p>
<p>Esto le dice a Windows: "Oye, la ruta para Python es: C:\Python27". Si quieres entender exactamente c&#243;mo funciona esto, mira <ref target="https://technet.microsoft.com/en-us/library/ff730964.aspx">esta p&#225;gina</ref> (en ingl&#233;s) en el portal TechNet de Microsoft (el mismo portal que utilizas en l&#237;nea con <code rend="inline">Get-Help</code>).</p>
<p>Una vez que hayas corrido el comando anterior, sal de PowerShell y vuelve a iniciarlo. Entonces deber&#237;as poder abrir el int&#233;rprete de Python escribiendo <code rend="inline">python</code> en PowerShell. Para ejecutar <emph>scripts</emph>, simplemente escribe <code rend="inline">python</code> seguido de la ruta del <emph>script</emph> que quieres. Es m&#225;s f&#225;cil navegar primero al directorio que contiene el <emph>script</emph>, y luego simplemente escribir <code rend="inline">python nombre-de-script.py</code>.</p>
<p>Ahora ya est&#225;s preparado para ejecutar <emph>scripts</emph> de Python desde la l&#237;nea de comandos.</p>
</div>
      <div type="1"><head>Conclusi&#243;n</head>
<p>En este tutorial has aprendido algunos de los conceptos b&#225;sicos para trabajar con PowerShell, la interfaz de l&#237;nea de comandos de Windows. Ya sabes lo suficiente para usar PowerShell para muchas de las tareas cotidianas que haces en tu computadora y yo recomendar&#237;a usarlo para eso. Al principio puede resultar m&#225;s dif&#237;cil copiar un archivo y moverlo a un nuevo directorio desde la l&#237;nea de comandos, pero cuanto m&#225;s practiques m&#225;s natural ser&#225;. Eventualmente, te encontrar&#225;s c&#243;modamente trabajando en PowerShell, y ser&#225;s capaz de hacer muchas tareas m&#225;s f&#225;cilmente de esta manera.</p>
<p>Aunque s&#243;lo hemos dado un vistazo de lo que puede hacer PowerShell, ahora tienes suficientes conocimientos b&#225;sicos para aprender a hacer m&#225;s cosas. Hay muchos recursos &#250;tiles en l&#237;nea y los puedes hacer tuyos con Google. Tambi&#233;n es &#250;til saber que muchas discusiones sobre el uso de la l&#237;nea de comandos se basar&#225;n en Unix y otros sistemas *nix. En la mayor&#237;a de los casos, si simplemente escribes en un buscador los nombres de los comandos que est&#225;s utilizando junto con "PowerShell", encontrar&#225;s el <emph>cmdlet</emph> correspondiente.</p>
<p>Cuanto m&#225;s utilices PowerShell m&#225;s f&#225;cil ser&#225; descubrir capacidades que ni siquiera sab&#237;as que ten&#237;a tu computadora. Eventualmente, notar&#225;s c&#243;mo el uso de la GUI te ha restringido en el uso de la potencialidad de tu m&#225;qiuna. No dejar&#225;s de usar la GUI, pero te encontrar&#225;s iniciando PowerShell cada vez con mayor frecuencia para liberarte de estas limitaciones y utilizar tu computadora de manera m&#225;s completa. Tu computadora es como una navaja de bolsillo. La GUI s&#243;lo te permite abrir algunas cuchillas; &#161;pero con la l&#237;nea de comandos puedes abrirlas todas!</p>
</div>
      <table>
<row>
<cell role="label">Cmdlet</cell>
<cell role="label">Alias</cell>
<cell role="label">Bash Equivalent</cell>
<cell role="label">Description</cell>
</row>
<row>
<cell><code rend="inline">exit</code></cell>
<cell>none</cell>
<cell><code rend="inline">exit</code></cell>
<cell>Salir de PowerShell</cell>
</row>
<row>
<cell><code rend="inline">Get-Help</code></cell>
<cell>none</cell>
<cell><code rend="inline">man</code></cell>
<cell>Obtiene el archivo de ayuda de un <emph>cmdlet</emph>. La adici&#243;n del par&#225;metro <code rend="inline">-online</code> abre la p&#225;gina de ayuda en TechNet.</cell>
</row>
<row>
<cell>`</cell>
<cell>`</cell>
<cell>none</cell>
<cell>`</cell>
</row>
<row>
<cell><code rend="inline">&gt;</code></cell>
<cell>none</cell>
<cell><code rend="inline">&gt;</code></cell>
<cell>Redirecci&#243;n. Pone la salida del comando a la izquierda de <code rend="inline">&gt;</code> en un archivo a la derecha de <code rend="inline">&gt;</code>.</cell>
</row>
<row>
<cell><code rend="inline">Measure-Object</code></cell>
<cell><code rend="inline">measure</code></cell>
<cell>(<code rend="inline">wc</code>)</cell>
<cell>Obtiene informaci&#243;n estad&#237;stica sobre un objeto. Utiliza <code rend="inline">Get-Content</code> y dirige la salida a<code rend="inline"> Measure-Object</code> con los par&#225;metros <code rend="inline">-line</code>, <code rend="inline">-word</code> y <code rend="inline">-character</code> para obtener informaci&#243;n sobre el recuento de l&#237;neas, palabras o caracteres.</cell>
</row>
<row>
<cell><code rend="inline">Select-String</code></cell>
<cell><code rend="inline">sls</code></cell>
<cell>(<code rend="inline">grep</code>)</cell>
<cell>Busca contenido espec&#237;fico.</cell>
</row>
<row>
<cell><code rend="inline">Get-Content</code></cell>
<cell><code rend="inline">gc</code></cell>
<cell><code rend="inline">cat</code></cell>
<cell>Obtiene el contenido de un archivo y lo imprime en la pantalla. La adici&#243;n del par&#225;metro <code rend="inline">-TotalCount</code> seguido de un n&#250;mero x s&#243;lo imprime las primeras x l&#237;neas. A&#241;adiendo el par&#225;metro <code rend="inline">-Tail</code> seguido de un n&#250;mero x s&#243;lo imprime las x l&#237;neas finales.</cell>
</row>
<row>
<cell><code rend="inline">Write-Output</code></cell>
<cell><code rend="inline">write</code></cell>
<cell><code rend="inline">echo</code></cell>
<cell>Exporta lo que escribas. Utiliza la redirecci&#243;n para enviarlo a un archivo. La redirecci&#243;n con <code rend="inline">&gt;&gt;</code> a&#241;adir&#225; texto al archivo en lugar de sobrescribir el contenido.</cell>
</row>
<row>
<cell><code rend="inline">Copy-Item</code></cell>
<cell><code rend="inline">cp</code></cell>
<cell><code rend="inline">cp</code></cell>
<cell>Copia un archivo en una nueva ubicaci&#243;n. Requiere los mismos argumentos que mover, pero mantiene el archivo original en su ubicaci&#243;n.</cell>
</row>
<row>
<cell><code rend="inline">Move-Item</code></cell>
<cell><code rend="inline">mv</code></cell>
<cell><code rend="inline">mv</code></cell>
<cell>Mueve algo. Necesita dos argumentos. Primero un nombre de archivo (i.e. su ruta actual), luego la ruta de nueva nueva locaci&#243;n (incluido el nombre que debe tener ah&#237;). Si no se cambia la ruta, puede usarse para renombrar archivos.</cell>
</row>
<row>
<cell><code rend="inline">Remove-Item</code></cell>
<cell><code rend="inline">rm</code></cell>
<cell><code rend="inline">rm</code></cell>
<cell>Borra algo... &#161;de manera permanente!</cell>
</row>
<row>
<cell><code rend="inline">Explorer</code></cell>
<cell>none</cell>
<cell>(<code rend="inline">open</code>)</cell>
<cell>Abre algo utilizando el Explorador de archivos (la GUI)</cell>
</row>
<row>
<cell><code rend="inline">mkdir</code></cell>
<cell>none</cell>
<cell><code rend="inline">mkdir</code></cell>
<cell>Crea un nuevo directorio. (Ver <code rend="inline">New-Item</code>.)</cell>
</row>
<row>
<cell><code rend="inline">New-Item</code></cell>
<cell><code rend="inline">ni</code></cell>
<cell>(<code rend="inline">touch</code>)</cell>
<cell>Crea un nuevo &#237;tem. De no utilizarse un par&#225;metro, el &#237;tem ser&#225; un archivo por defecto. El uso de <code rend="inline">mkdir</code> es una abreviatura para incluir el par&#225;metro <code rend="inline">-ItemType dir</code>.</cell>
</row>
<row>
<cell><code rend="inline">Pop-Location</code></cell>
<cell><code rend="inline">popd</code></cell>
<cell><code rend="inline">popd</code></cell>
<cell>Regresa al directorio previo despues de usar <code rend="inline">pushd</code></cell>
</row>
<row>
<cell><code rend="inline">Push-Location</code></cell>
<cell><code rend="inline">pushd</code></cell>
<cell><code rend="inline">pushd</code></cell>
<cell>Cambiar al directorio.</cell>
</row>
<row>
<cell><code rend="inline">Set-Location</code></cell>
<cell><code rend="inline">sl</code></cell>
<cell><code rend="inline">cd</code></cell>
<cell>Cambia al directorio en la ruta de acceso dada. Si escribes <code rend="inline">..</code> en lugar de una ruta te mover&#225; hacia arriba un directorio.</cell>
</row>
<row>
<cell><code rend="inline">Get-ChildItem</code></cell>
<cell><code rend="inline">gci</code></cell>
<cell><code rend="inline">ls</code></cell>
<cell>Enlista los directorios y archivos en la ubicaci&#243;n actual.</cell>
</row>
</table>
    </body>
  </text>
</TEI>
