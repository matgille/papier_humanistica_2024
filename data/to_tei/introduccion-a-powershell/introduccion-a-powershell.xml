<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:id="introduccion-a-powershell" type="translation">
    <teiHeader>
        <fileDesc>
            <titleStmt>
                <title>Introducción a la línea de comandos de Windows con PowerShell</title>
                <author role="original_author">Ted Dawson</author>
                <editor role="reviewers">
                    <persName>Erin N. Bush</persName>
                    <persName>Derek Price</persName>
                </editor>
                <author role="translators">Victor Gayol</author>
                <editor role="translation-reviewers">
                    <persName>Silvia Gutiérrez</persName>
                    <persName>José Antonio Motilla</persName>
                </editor>
                <editor role="editors">Jeri E. Wieringa</editor>
            </titleStmt>
            <publicationStmt>
                <distributor>Programming Historian</distributor>
                <date type="translated">06/02/2018</date>
                <idno type="doi">10.46430/phes0037</idno>
                <date type="published">07/21/2016</date>
            </publicationStmt>
            <sourceDesc>
                <p>Born digital, in a markdown format. Original file: <ref type="original_file" target="#intro-to-powershell"/>.</p>
            </sourceDesc>
        </fileDesc>
        <profileDesc>
            <abstract>
                <p>En este tutorial aprenderás las bases de PowerShell de Windows, la interfaz de línea de comandos estándar de computadoras con Windows.</p>
            </abstract>
            <textClass>
                <keywords>
                    <term xml:lang="en">data-manipulation</term>
                    <term xml:lang="en">get-ready</term>
                </keywords>
            </textClass>
        </profileDesc>
    </teiHeader>
    <text xml:lang="es">
        <body>
            <div type="1">
                <head>Introducción</head>
                <p>En este tutorial aprenderás las bases de PowerShell de Windows, la interfaz de línea de comandos estándar de computadoras con Windows. Si eres usuario de Mac o Linux deberías consultar la <ref target="/es/lecciones/introduccion-a-bash">Introducción a la línea de comandos en Bash</ref>. Si ya estás familiarizado con el uso de Bash, es posible que puedas comenzar con PowerShell solamente con ver la <ref target="#referencia-rapida">tabla al final de esta lección</ref>.</p>
                <p>El tutorial está dividido en dos secciones principales. En la primera sección, "<ref target="#para-empezar">Para empezar</ref>", aprenderás a realizar tareas básicas de escritorio como crear y abrir archivos y carpetas con PowerShell. En la segunda sección, "<ref target="#haciendo-m%C3%A1s">Haciendo más</ref>", obtendrás un vistazo de algunas de las características que hacen que el trabajo en línea de comandos sea particularmente eficiente y aprendas lo básico para poder explorar más por tu cuenta. También te prepararás para <ref target="#Utilizaci%C3%B3n-de-herramientas-de-l%C3%ADnea-de-comandos-y-ejecuci%C3%B3n-de-secuencias-de-comandos-en-Python">ejecutar <emph>scripts</emph> de Python desde la línea de comandos</ref>.</p>
                <p>Este tutorial fue escrito para PowerShell 5.0. Si estás usando una versión anterior, encontrarás algunas pequeñas diferencias de sintaxis que debes ser capaz de superar con la pequeña ayuda de un buscador.</p>
            </div>
            <div type="1">
                <head>¿Qué es PowerShell y por qué es útil?</head>
                <p>Windows PowerShell es una <hi rend="bold">interfaz de línea de comandos</hi> para computadoras Windows. Una interfaz de línea de comandos (CLI, por sus siglas en inglés) es un programa que te permite hacer que tu computadora ejecute tareas utilizando órdenes escritas en vez de hacer clic sobre las imágenes en el escritorio como en una <hi rend="bold">interfaz gráfica de usuario</hi> (GUI, por sus siglas en inglés). Técnicamente, PowerShell es más que sólo una CLI; puedes obtener una visión general de sus características en <ref target="https://es.wikipedia.org/wiki/Windows_PowerShell">Wikipedia</ref>. El uso de la línea de comandos tiene muchas ventajas. Hace posible automatizar tareas y hacer muchas cosas con una orden. Lo que es más importante, una serie de herramientas de valor para los humanistas sólo se pueden ejecutar desde la línea de comandos, incluyendo muchas de las que puedes aprender en <emph>The Historian</emph> en español, como <ref target="/en/lessons/topic-modeling-and-mallet">Mallet</ref> (en inglés), <ref target="/es/lecciones/escritura-sostenible-usando-pandoc-y-markdown">Pandoc</ref>, o <ref target="/en/lessons/automated-downloading-with-wget">Wget</ref> (en inglés). La línea de comandos es también el mejor lugar para trabajar con los programas que has construido y personalizado para tu propia investigación utilizando lenguajes de programación como Python.</p>
            </div>
            <div type="1">
                <head>Para empezar</head>
                <p>En primer lugar aprenderás a navegar a través de tus archivos y a realizar algunas tareas básicas que haces todos los días en la computadora.</p>
            </div>
            <div type="1">
                <head>Abrir PowerShell</head>
                <p>Busca PowerShell en tu computadora. Probablemente tengas varias opciones, como "PowerShell", "PowerShell ISE" y "PowerShell (x86)". El ISE (entorno integrado de secuencias de órdenes -<emph>integrated scripting environment</emph>) es una herramienta útil que te permite escribir <emph>scripts</emph> al vuelo y también cuenta con una búsqueda de todos los comandos de PowerShell. En este momento es más de lo que necesitamos. El "X86" es compatible con versiones anteriores del sistema operativo (si has estado en el mundo de las computadoras por algún tiempo, recordarás los viejos procesadores de Intel de los años 80 y 90 llamados "286", 2386", "486", y así sucesivamente. Eso es lo que permite el "X86", pues es una versión de 32 bits). Pero queremos 64-bits y lo más simple, así que vamos a utilizar el llamado solamente "Windows PowerShell". Posiblemente quieras agregarlo a tu barra de tareas: haz clic con el botón derecho para obtener la opción. Al abrirlo, se verá así:</p>
                <figure>
                    <desc>Puesta en marcha de PowerShell</desc>
                    <graphic url="intro-to-powershell1.png"/>
                </figure>
                <p>Si no quieres blanco sobre azul, haz clic con el botón derecho en la barra superior, selecciona "propiedades" y ve a "colores" para cambiar las cosas. Deberás cerrar y volver a abrir PowerShell para que se vea correctamente.</p>
                <div type="2">
                    <head>Navegación</head>
                    <p>Algo bueno de PowerShell es que siempre sabrás dónde estás porque te lo dice en el prompt. En mi caso, yo veo:</p>
                    <p>
                        <code rend="inline">C:\Users\Ted&gt;</code>
                    </p>
                    <p>Debes ver algo similar pero con tu nombre de usuario. En caso de que no sea así, escribe:</p>
                    <p>
                        <code rend="inline">sl ~</code>
                    </p>
                    <p>Asegúrate de incluir el espacio. Esto te llevará a tu directorio personal: <code rend="inline">C:\Users\TUNOMBREDEUSUARIO</code> donde "TUNOMBREDEUSUARIO" se reemplaza con el nombre de tu cuenta en la máquina. "Directorio" es sólo otra palabra para "carpeta", y PowerShell considera tu carpeta de usuario como inicio -no el escritorio. El escritorio es realmente otra carpeta dentro de tu carpeta de usuario, es decir, un subdirectorio del directorio usuario. Introducir <code rend="inline">sl ~</code> es como abrir la carpeta llamada "usuarios" y desde ahí TUNOMBREDEUSUARIO utilizando la GUI. Comencemos aprendiendo como moverte entre los directorios y ver su contenido.</p>
                    <div type="3">
                        <head>Ver contenido del directorio con <code rend="inline">Get-ChildItem</code> (<code rend="inline">gci</code>, <code rend="inline">ls</code>)</head>
                        <p>Nuestra primera orden es <code rend="inline">Get-ChildItem</code>. Escríbela y oprime Enter. Verás una lista de todo lo que hay en tu directorio actual. En mi caso se verá así:</p>
                        <figure>
                            <desc>Listado del contenido del directorio con `Get-ChildItem`</desc>
                            <graphic url="intro-to-powershell2.png"/>
                        </figure>
                        <p>Toma en cuenta que en realdad no escribí <code rend="inline">GetChildItem</code>. Solamente <code rend="inline">gci</code>. Los comandos que aprenderemos son todos de la forma "Verbo-Sustantivo" (<emph>Verb-Noun</emph>). Son llamados "cmdlets" (pronunciado "commandlets") y se supone que su forma hace más fácil recordar lo que hacen y predecir otros <emph>cmdlets</emph> similares. Debido a que los <emph>cmdlets</emph> son bastante largos, la mayoría de ellos tienen alias más elegantes que puedes utilizar en su lugar. Primero presentaré los <emph>cmdlets</emph> con sus nombres, pero siempre usaré los alias estándar, porque son mucho más rápidos para trabajar. Es importante tener en cuenta que muchos <emph>cmdlets</emph> tienen varios alias. Por ejemplo, <code rend="inline">Get-ChildItem</code>,<code rend="inline"> gci</code>, <code rend="inline">dir</code> y<code rend="inline"> ls</code> hacen exactamente lo mismo. Aunque no sorprende que <code rend="inline">gci</code> sea la abreviatura de<code rend="inline"> Get-ChildItem</code>, es posible que te preguntes de dónde provienen <code rend="inline">dir</code> y<code rend="inline"> ls</code>.</p>
                        <p>PowerShell es relativamente nuevo (se lanzó por primera vez en 2006), y sus diseñadores esperaban que muchas personas que lo utilizarían ya tendrían experiencia con algunas CLI existentes (interfaces de línea de comandos), específicamente con el CLI más antiguo de Microsoft llamado Símbolo de sistema (<emph>command prompt</emph>) o con Linux CLIs como Bash, que ahora también es estándar en OS X. Por lo tanto, muchos <emph>cmdlets</emph> tienen un alias que es el comando estándar en uno de estos dos sistemas (y a menudo para ambos). En el ejemplo presente, <code rend="inline">dir</code> viene de Símbolo de sistema, y<code rend="inline"> ls</code> proviene de Bash. Utilizaré los alias de estilo "PowerShell" en este tutorial, ya que hace más fácil recordar los nombres reales de <emph>cmdlet</emph>. Sin embargo, intentaré también mencionar otros alias comunes, particularmente aquellos familiares para los usuarios de Bash. Si trabajas con mucha gente que usa OS X o Linux, puede ser bueno conocer estos nombres. La <ref target="#referencia-r%C3%A1pida">tabla en la parte inferior</ref> proporciona los <emph>cmdlets</emph> junto con sus alias estándar de PowerShell y el equivalente de Bash más cercano.</p>
                        <p>Sigue adelante e intenta usar <code rend="inline">gci</code>,<code rend="inline"> dir</code> y <code rend="inline">ls</code>. Obtendrás exactamente la misma lista de cosas. La mayoría de estas cosas serán directorios. Uno de ellos debe ser tu escritorio. Vamos a entrar en ese directorio.</p>
                    </div>
                    <div type="3">
                        <head>Navegar entre directorios con <code rend="inline">Set-Location</code> (<code rend="inline"> sl</code>, <code rend="inline">cd</code>)</head>
                        <p>Para desplazarte a tu escritorio, usaremos el <emph>cmdlet</emph>
                            <code rend="inline">Set-Location</code>. Escribe en PowerShell:</p>
                        <p>
                            <code rend="inline">sl desktop</code>
                        </p>
                        <p>Esto le indica a PowerShell que se mueva al escritorio. Observa que puedes escribir "desktop" usando todas las letras minúsculas, aunque cuando viste el contenido del directorio <code rend="inline">TUNOMBREDEUSUARIO</code>, "Desktop" se escribió con una "D" mayúscula. PowerShell no distingue entre mayúsculas y minúsculas. Ahora que has cambiado tu ubicación, puedes usar <code rend="inline">gci</code> para ver una lista de todo lo que hay en tu escritorio, es decir, todo el directorio llamado<code rend="inline"> Desktop</code>. Si estás tan desorganizado como yo, esta será una larga lista. Podemos volver al directorio <code rend="inline">TUNOMBREDEUSUARIO</code> escribiendo:</p>
                        <p>
                            <code rend="inline">sl ..</code>
                        </p>
                        <p>¡No olvides el espacio! Ahora escribe de nuevo:</p>
                        <p>
                            <code rend="inline">sl ..</code>
                        </p>
                        <p>Debes estar en el directorio <code rend="inline">Users</code>.</p>
                        <p>Ahora trata de volver al escritorio y luego de nuevo a <code rend="inline">Users</code>. Debe tomarte escribir cuatro comandos: <code rend="inline">sl TUNOMBREDEUSUARIO</code>, <code rend="inline">sl desktop</code>, <code rend="inline">sl ..</code>, <code rend="inline">sl ..</code>. Pero en realidad puedes hacerlo con sólo dos. Deberías estar en <code rend="inline">C:\Users&gt;</code> ahora mismo. En lugar de escribir <code rend="inline">sl TUNOMBREDEUSUARIO</code> y luego <code rend="inline">sl desktop</code>, puedes escribir solamente:</p>
                        <p>
                            <code rend="inline">sl TUNOMBREDEUSUARIO\desktop</code>
                        </p>
                        <p>¡Y llegar al escritorio con un comando! Del mismo modo, desde el escritorio, escribiendo:</p>
                        <p>
                            <code rend="inline">sl ..\..</code>
                        </p>
                        <p>Puedes volver a donde comenzaste con un comando. Si no tienes la resistencia del dedo meñique para escribir <code rend="inline">\</code> todo el tiempo, también puedes escribir <code rend="inline">sl ../ ..</code>. No sólo PowerShell no distingue entre mayúsculas y minúsculas, sino que tampoco le importa en qué dirección va la barra. <code rend="inline">Sl ../ ..</code>, <code rend="inline">SL .. \ ..</code>, <code rend="inline">Set-Location .. \ ..</code> y <code rend="inline">set-location ../ ..</code> todos hacen exactamente lo mismo.</p>
                    </div>
                    <div type="3">
                        <head>Creación de nuevos directorios con <code rend="inline">mkdir</code>
                        </head>
                        <p>Estamos avanzando hacia el trabajo con archivos. Antes de comenzar, hagamos un directorio donde podamos almacenar todo lo que estamos usando para esta lección. Navega de regreso a casa escribiendo:</p>
                        <p>
                            <code rend="inline">sl ~</code>
                        </p>
                        <p>Haremos un nuevo directorio dentro del directorio <code rend="inline">TUNOMBREDEUSUARIO</code>. Para ello, utilizaremos el comando <code rend="inline">mkdir</code>. Llama a tu directorio como quieras, pero trata de no usar espacios, ya que hacen que trabajar en línea de comandos sea más complicado de lo necesario. Voy a llamar a mi directorio "diversionConPowerShell". Entonces yo escribo:</p>
                        <p>
                            <code rend="inline">mkdir diversionConPowerShell</code>
                        </p>
                        <p>¿Viste cómo utilizo <ref target="https://es.wikipedia.org/wiki/CamelCase">CamelCase</ref> para evitar los espacios?</p>
                        <p>Otra forma común de hacer esto es insertando guión o guión bajo, como en <code rend="inline">diversion_con_power_shell</code>. Sea cual sea el nombre de tu directorio, trata de evitar el uso de espacios. Una vez que has estado trabajando con PowerShell un poco, probablemente te encontrarás nombrando a tu nuevos archivos sin espacios por defecto. Este es un buen hábito ya que simplifica el trabajo en la línea de comandos, así como al trabajar con lenguajes de programación como Python.</p>
                        <p>Sin embargo, es probable que tengas un montón de archivos ya existentes con espacios en sus nombres. Para abrir estos en PowerShell, sólo tienes que utilizar comillas. Intentemos esto. Muevete a tu nuevo directorio utilizando:</p>
                        <p>
                            <code rend="inline">sl diversionConPowerShell</code>
                        </p>
                        <p>(O como hayas nombrado tu directorio). Escribe:</p>
                        <p>
                            <code rend="inline">gci</code>
                        </p>
                        <p>Y verás que no hay nada aquí. ¡Eso es porque no has puesto nada en él! Vamos a poner un nuevo directorio dentro con <code rend="inline">mkdir</code>. Llamaremos a este directorio "Directorio con un nombre largo y muchos espacios". Debido a que el nombre tiene espacios en él, tendremos que usar comillas para crearlo. Tipo</p>
                        <p>
                            <code rend="inline">mkdir "Directorio con un nombre largo y muchos espacios"</code>
                        </p>
                        <p>Presiona Enter. Ahora escribe:</p>
                        <p>
                            <code rend="inline">gci</code>
                        </p>
                        <p>Y verás tu nuevo directorio. Supongamos que queremos movernos a este directorio. Tendríamos que escribir <code rend="inline">sl "Directorio con un nombre largo y muchos espacios"</code>. No solo tomará un tiempo escribirlo sino que, si nos equivocamos, PowerShell no podrá encontrar nuestro directorio. En su lugar, escribe simplemente:</p>
                        <p>
                            <code rend="inline">sl d</code> y entonces oprime la tecla de tabulador.</p>
                        <p>Voilà! ¡PowerShell completa el nombre del directorio por nosotros, incluidas las comillas! El uso del tabulador para completar automáticamente te ahorrará mucho tiempo. Notarás que cuando PowerShell completó el nombre, también puso <code rend="inline">.\</code> al principio del nombre del directorio. El punto es solo una abreviatura de directorio actual. Cuando escribes órdenes, PowerShell siempre asume que hay un <code rend="inline">.\</code>al principio -en otras palabras, que te estás refiriendo a algo en el directorio actual-. Por lo tanto, no es necesario que escribas esta parte, a menos que quieras que PowerShell busque en otro lugar lo que estás pidiendo que haga, en cuyo caso puedes escribir la ruta de ese directorio. Por ejemplo: <code rend="inline">C:\directorio\bla\etc</code>.</p>
                        <p>Practiquemos un poco más con directorios antes de comenzar con archivos.</p>
                    </div>
                    <div type="3">
                        <head>Uso de <code rend="inline">Explorer</code>para ver directorios en la GUI</head>
                        <p>Hasta ahora hemos hecho dos directorios. He mencionado anteriormente que "directorio" es solo otra palabra para "carpeta". Puedes verlo al mirar tus nuevos directorios en la GUI. Windows llama a su GUI "Explorador de archivos" o simplemente "Explorador". Podemos llamar al Explorador desde PowerShell utilizando el comando "Explorer". Vuelve a la carpeta diversionConPowerShell con:</p>
                        <p>
                            <code rend="inline">sl ..</code>
                        </p>
                        <p>Ahora escribe:</p>
                        <p>
                            <code rend="inline">explorer .</code>
                        </p>
                        <p>Recuerda que el punto solamente significa "este directorio", y no tienes que escribir con mayúscula "explorer" porque las mayúsculas no importan en PowerShell. Explorador debería haber abierto una ventana que muestra el contenido del directorio "diversiónConPowerShell". Organiza tus ventanas para que puedas ver tanto la imagen en Explorador como en PowerShell. Ahora podrás ver que lo que haces en PowerShell aparece en Explorador. El comando "Explorer" es extremadamente útil. Básicamente, es como hacer doble clic en la GUI. De tal manera, puedes utilizarlo para abrir archivos y programas.</p>
                    </div>
                    <div type="3">
                        <head>Eliminación con <code rend="inline">Remove-Item</code> (<code rend="inline">rm</code>)</head>
                        <p>Ahora que puedes ver los resultados de lo que haces en PowerShell, aprendamos a borrar cosas, por ejemplo, aquel directorio con el nombre largo. Primero crearemos algunos directorios más. Nómbralos "dir", "dir1", y "dir2". Puedes crear los tres con un solo comando escribiendo:</p>
                        <p>
                            <code rend="inline">mkdir dir, dir1, dir2</code>
                        </p>
                        <p>Genial, ¿no? Deberías ver tus tres nuevos directorios en la ventana abierta de Explorador (en la GUI).</p>
                        <p>Ahora vamos a deshacernos de ese directorio con el nombre largo. Para ello utilizaremos el <emph>cmdlet</emph>
                            <code rend="inline">Remove-Item</code> o <code rend="inline">rm</code>. Tienes que ser <hi rend="bold">muy cuidadoso</hi> con este <emph>cmdlet</emph> pues no transfiere los ítems borrados a la papelera o basurero de reciclaje, sino que <hi rend="bold">los elimina de manera permanente</hi>, así que lo puedes considerar borrado sin posibilidad de recuperarlo. Escribe <code rend="inline">rm</code> seguido de un espacio y el nombre largo de ese directorio del que nos queremos deshacer. Quizá quieras utilizar la tecla de tabulador para completar automáticamente el nombre. Sin embargo ten en cuenta que, como ahora tenemos varios directorios que comienzan con la letra "d", tendrás que escribir algo más que la primera letra para que se complete automáticamente. Escribe:</p>
                        <p>
                            <code rend="inline">rm dire</code> y entonces presiona la tecla de tabulación.</p>
                        <p>De manera alternativa, puedes escribir solamente <code rend="inline">rm</code> y oprimir la tecla de tabulador varias veces para desplazarte por todos tus directorios. Si fuiste más allá del que te interesa, solamente oprime la tecla de mayúscula (<emph>shift</emph>) con tabulador para desplazarte hacia atrás.</p>
                        <p>Antes de presionar la tecla <code rend="inline">Enter</code>, yo observo con atención lo que escribí para asegurarme de que estoy borrando el ítem que quiero eliminar. Solo entonces hago clic en <code rend="inline">Enter</code>.</p>
                        <p>Adelante. Borra los otros tres directorios y observa cómo desaparecen del Explorador. Igual que con <code rend="inline">mkdir</code>, puedes borrar los tres directorios de una sola vez con un comando. Inténtalo.</p>
                        <p>Acabamos de eliminar los directorios <code rend="inline">dir</code>,<code rend="inline"> dir1</code> y <code rend="inline">dir2</code>. Pero resulta que los necesitamos para el siguiente ejemplo. Así que vamos a crearlos de nuevo. Pero ahora, en lugar de escribir la instrucción, vamos a oprimir la flecha hacia arriba del teclado un par de veces (o las que sean necesarias). En algún punto deberás ver el comando que usaste para crear los tres directorios la primera vez. Una vez que encuentres esa línea pulsa Enter y se volverán a crear. De la misma manera que usar el tabulador (<code rend="inline">tab</code>) para completar automáticamente, el uso de las flechas arriba y abajo para desplazarte por los comandos recientes te ahorrará mucho tiempo. <hi rend="bold">Considera que no estamos deshaciendo el borrado que hicimos con anterioridad</hi>. Por el contrario, estamos usando un "acceso directo" para ingresar de nuevo un comando que hemos usado recientemente.</p>
                    </div>
                    <div type="3">
                        <head>Entender la estructura de árbol del sistema de archivos de tu computadora</head>
                        <p>Ahora debes tener tres directorios dentro de tu directorio <code rend="inline">diversionConPowerShell</code>. Desplázate al interior del directorio <code rend="inline">dir</code> (utiliza <code rend="inline">sl dir</code>)</p>
                        <p>Es importante entender la manera en la que tu computadora organiza las cosas. Observa la ruta a tu directorio actual. La ruta es todo lo que escribiste después del <emph>prompt</emph>. En mi caso es:</p>
                        <p>
                            <code rend="inline">C:\Users\Ted\diverionConPowerShell\dir</code>
                        </p>
                        <p>Tu ruta debe verse bastante similiar. Lo que representa esta ruta en realidad es una structura parecida a un árbol que sigue el ordenador para llegar al punto en el que estás. El tronco del árbol es <code rend="inline">C:</code>, que es tu disco duro. En realidad, en la mayoría de las computadoras modernas <code rend="inline">C:</code>es una partición de su disco duro. ¿Por qué se llama <code rend="inline">C</code>? El ordenador asigna una letra a cada una de las unidades. <code rend="inline">A</code>y <code rend="inline">B</code>están reservados para las dos unidades de disquettes que hace mucho tiempo utilizaban con frecuencia los usuarios para interactuar con los discos duros de sus computadoras. Aunque la mayoría de los ordenadores ya no los tienen, los nombres quedaron reservados.</p>
                        <p>Si <code rend="inline">C:</code> es el tronco del árbol, cada sección de la ruta después de <code rend="inline">C:</code> es una rama, de la cual salen otras que están por encima de ella. Así, <code rend="inline">Users</code> es una rama de <code rend="inline">C:</code>, <code rend="inline">Ted</code> es una rama más pequeña que sale de <code rend="inline">Users</code> y así sucesivamente. También se puede usar la metáfora de la herencia en lugar de la de la botánica y llamar a cada rama un <code rend="inline">hijo</code> del directorio por encima de ella. Este es el lenguaje más común para describir las relaciones entre los directorios (de ahí el cmdlet <code rend="inline">Get-ChildItem</code>), pero nos quedaremos con la metáfora del árbol ya que, en la vida real, las relaciones de herencia pueden ser mucho más complejas que la extremadamente jerárquica estructura según la cual está organizada tu computadora.</p>
                        <p>Entender que la ruta funciona como un árbol es importante para poder navegar por los directorios que no están inmediatamente por encima o por debajo de tu directorio actual. Sabemos que hay un directorio llamado "dir1", y que éste directorio también está en el directorio "diverionConPowerShell". Ve lo que sucede si intentas usar <code rend="inline">sl</code> para pasar directamente a él escribiendo:</p>
                        <p>
                            <code rend="inline">sl dir1</code>
                        </p>
                        <p>¡Esto arroja error!</p>
                        <figure>
                            <desc>Error por intentar saltar entre ramas</desc>
                            <graphic url="intro-to-powershell3.png"/>
                        </figure>
                        <p>El problema es que intentamos saltar de una rama a otra, y PowerShell sólo entiende nuestro movimiento si nos desplazamos a lo largo del árbol. Eso significa que primero tenemos que movernos hasta donde se encuentran las ramas de "dir1" y "dir", y luego volver a "dir1". Puedes hacerlo con un comando. Veamos si puedes imaginarlo antes de leer la siguiente línea.</p>
                        <p>El comando es:</p>
                        <p>
                            <code rend="inline">sl ..\dir1</code>
                        </p>
                        <p>Esto le indica a PowerShell subir un directorio a <code rend="inline">diversionConPowerShell</code>, y luego bajar al directorio <code rend="inline">dir1</code>.</p>
                    </div>
                    <div type="3">
                        <head>Moverse rápido con <code rend="inline">Push-Location</code>(<code rend="inline">pushd</code>) y <code rend="inline">Pop-Location</code> (<code rend="inline">popd</code>)</head>
                        <p>Antes de trabajar con archivos vamos a probar los comandos <code rend="inline">push</code>y <code rend="inline">popd</code>. Haz lo siguiente: ve hasta el tronco del árbol.<code rend="inline">C:</code>.deben ser cuatro directorios arriba del directorio en el que estás, por lo cual podrías escribir:</p>
                        <p>
                            <code rend="inline">sl ..\..\..\..</code>
                        </p>
                        <p>Entonces cambia de nuevo a <code rend="inline">dir1</code>. Pero en vez de escribir <code rend="inline">sl</code>antes de la ruta, escribe <code rend="inline">pushd</code>. Como esto:</p>
                        <p>
                            <code rend="inline">pushd users\TUNOMBREDEUSUARIO\diversionConPowerShell\dir1</code>
                        </p>
                        <p>Ahora estarás en el directorio como si hubieras escrito <code rend="inline">sl</code> al principio de la ruta. Pero aquí está la parte divertida. Ahora escribe:</p>
                        <p>
                            <code rend="inline">popd</code>
                        </p>
                        <p>Y pulsa Enter. Genial, ¿no? El comando <code rend="inline">pushd</code> indica a PowerShell que se mueva a un directorio determinado desde tu directorio actual al que puedes ser devuelto con <code rend="inline">popd</code>. En otras palabras, <code rend="inline">popd</code> siempre te regresará al último directorio en el cual estuviste antes de usar <code rend="inline">pushd</code>. Si quieres entender más sobre lo que está pasando, lee sobre la <ref target="https://es.wikipedia.org/wiki/Pila_de_llamadas">pila de llamadas</ref> en Wikipedia. El uso de <code rend="inline">pushd</code> y <code rend="inline">popd</code> es muy útil cuando te mueves con frecuencia entre dos directorios.</p>
                    </div>
                </div>
                <div type="2">
                    <head>Trabajar con archivos</head>
                    <p>Ahora que sabes cómo moverte a través del sistema de archivos de tu computadora desde la línea de comandos, vamos a trabajar manipulando archivos. Comenzaremos por aprender a <hi rend="bold">crear</hi> nuevos archivos, <hi rend="bold">copiarlos</hi> y <hi rend="bold">moverlos</hi>.</p>
                    <div type="3">
                        <head>Crear archivos con <code rend="inline">New-Item</code> (<code rend="inline">ni</code>)</head>
                        <p>Primero, necesitamos algunos archivos para trabajar con ellos. Hagamos un nuevo documento de texto plano llamado "ejemplo.txt". Navega hasta el directorio <code rend="inline">diversionConPowerShell</code> -utiliza el tabulador para cada nombre de directorio que escribas y acelerar el proceso-, y escribe:</p>
                        <p>
                            <code rend="inline">ni ejemplo.txt</code>
                        </p>
                        <p>Presiona Enter. Después ecribe:</p>
                        <p>
                            <code rend="inline">gci</code>
                        </p>
                        <p>para que confirmes, en efecto, que ahora tienes el archivo <code rend="inline">ejemplo.txt</code> además de tus directorios. Necesitaremos varios archivos así que, adelante: crea <code rend="inline">ejemplo1.txt</code> y <code rend="inline">ejemplo2.txt</code>. No te sorprenderá saber que, incluyendo una coma, puedes hacer esto con un solo comando:</p>
                        <p>
                            <code rend="inline">ni ejemplo1.txt, ejemplo2.txt</code>
                        </p>
                    </div>
                    <div type="3">
                        <head>Copiar y mover archivos con <code rend="inline">Copy-Item</code>(<code rend="inline">cp</code>) y <code rend="inline">Move-Item</code> (<code rend="inline">mv</code>)</head>
                        <p>Quizá deberíamos haber puesto estos archivos en un directorio. Movámoslos. Pongamos <code rend="inline">ejemplo.txt</code> en <code rend="inline">dir</code> escribiendo:</p>
                        <p>
                            <code rend="inline">mv ejemplo.txt dir</code>
                        </p>
                        <p>Ahora escribe <code rend="inline">gci</code> y verás que <code rend="inline">ejemplo.txt</code> ha desaparecido. Entra a <code rend="inline">dir</code> (<code rend="inline">sl dir</code>) y escribe <code rend="inline">gci</code> para que compruebes que ¡ahora está ahí! También puedes hacer esto sin cambiar de directorio escribiendo <code rend="inline">gci dir</code> desde el directorio <code rend="inline">diversionConPowerShell</code>. Regresa a <code rend="inline">diversionConPowerShell</code> y mueve <code rend="inline">ejemplo1.txt</code> a <code rend="inline">dir1</code> y <code rend="inline">ejemplo2.txt</code> a <code rend="inline">dir2</code>.</p>
                        <p>También podemos utilizar <code rend="inline">mv</code> para <hi rend="bold">renombrar</hi> ítems. Usa <code rend="inline">sl</code> para moverte a <code rend="inline">dir</code>. Escribe <code rend="inline">gci</code> y deberás ver tu archivo <code rend="inline">ejemplo.txt</code>. Es un nombre aburrido, así que llamémosle <code rend="inline">benjamin.txt</code>. Escribe:</p>
                        <p>
                            <code rend="inline">mv ejemplo.txt benjamin.txt</code>
                        </p>
                        <p>Utiliza <code rend="inline">gci</code> de nuevo para confirmnar que tu documento ahora se llama <code rend="inline">bejamin.txt</code>.</p>
                        <p>Te sorprenderá que el mismo <emph>cmdlet</emph> se utiliza tanto para mover como para renombrar archivos. De hecho, la operación es la misma. En ambos casos le estás diciendo a la computadora que cambie el "nombre" de la ubicación del archivo, es decir, que cambie la <hi rend="bold">ruta</hi> que sigue para encontrar el archivo. En el primer ejemplo, la ruta comenzó como:</p>
                        <p>
                            <code rend="inline">C:\Users\Ted\diversionConPowerShell\ejemplo.txt</code>
                        </p>
                        <p>Y luego cambió a:</p>
                        <p>
                            <code rend="inline">C:\Users\Ted\diversionConPowerShell\dir\ejemplo.txt</code>
                        </p>
                        <p>En el segundo ejemplo, la ruta cambió de:</p>
                        <p>
                            <code rend="inline">C:\Users\Ted\diversionConPowerShell\dir\ejemplo.txt</code>
                        </p>
                        <p>a:</p>
                        <p>
                            <code rend="inline">C:\Users\Ted\diversionConPowerShell\dir\benjamin.txt</code>
                        </p>
                        <p>Dicho de otro modo, en ambos ejemplos <code rend="inline">mv</code> solamente cambia la ruta. No te preocupes si esto no te hace sentido por ahora. Sólo ten cuidado de escribir correctamente las rutas cuando utilices <code rend="inline">mv</code> porque, si no lo haces, puedes cambiar el nombre cuando lo que quieres es mover el archivo, o viceversa.</p>
                        <p>Además de mover archivos, también quisiéramos copiarlos o eliminarlos. Para copiar archivos, utilizamos el <emph>cmdlet</emph>
                            <code rend="inline">Copy-Item</code> o<code rend="inline"> cp</code>. Hagamos dos copias de <code rend="inline">benjamin.txt</code> y llamémoslas <code rend="inline">steven.txt</code> y <code rend="inline">susie.txt</code>.</p>
                        <p>
                            <code rend="inline">cp benjamin.txt steven.txt</code>
                        </p>
                        <p>
                            <code rend="inline">cp benjamin.txt susie.txt</code>
                        </p>
                        <p>También podemos eliminar estos dos nuevos archivos con <code rend="inline">rm</code>, al igual que hicimnos con los directorios. Intenta hacerlo con un solo comando. Como siempre, ten cuidado cuando utilices <code rend="inline">rm</code>.</p>
                        <p>Éste es el comando:</p>
                        <p>
                            <code rend="inline">rm steven.txt, susie.txt</code>
                        </p>
                        <p>¡Adiós Steven y Susie!</p>
                        <figure>
                            <desc>Mover, copiar y borrar</desc>
                            <graphic url="intro-to-powershell4.png"/>
                        </figure>
                    </div>
                </div>
            </div>
            <div type="1">
                <head>Haciendo más</head>
                <p>Bien, ahora ya podemos navegar, crear archivos, moverlos y borrarlos en PowerShell. Nos sentimos muy bien, muy <emph>geeks</emph> porque podemos hacer estas cosas desde la línea de comandos. Pero esto no es realmente útil ya que podíamos hacer estas cosas muy fácilmente con la interfaz gráfica de usuario. Ahora que sabemos estos fundamentos, sin embargo, podemos comenzar a aprender comandos algo más complejos que pueden ser útiles en nuestro trabajo como humanistas digitales.</p>
                <h3>Escribir en archivos con <code rend="inline">Write-Output</code> (<code rend="inline">write</code>, <code rend="inline">echo</code>) y redirección</h3>
                <p>Tenemos un archivo vacío en nuestro directorio <code rend="inline">dir</code>. Eso no es muy interesante, así que vamos a añadir un poco de contenido. Podríamos abrir el archivo en el Bloc de notas y modificarlo de esa manera. Pero también podemos añadirle contenido con órdenes desde la línea de comandos. El <emph>cmdlet</emph> que utilizamos para esto es <code rend="inline">Write-Output</code>, o simplemente <code rend="inline">write</code>.</p>
                <p>Prueba con esto:</p>
                <p>
                    <code rend="inline">write "La técnica de la reproducción separa el objeto reproducido del dominio de la tradición."</code>
                </p>
                <p>PowerShell debe imprimir esta frase directamente en la ventana de la línea de comandos. Eso es todo lo que hace <code rend="inline">write</code>. Le dice a PowerShell "Imprime lo que yo escriba". Eso no es muy útil dado que queremos poner este texto en nuestro documento. Para ello, usaremos algo llamado <hi rend="bold">redirección</hi>.</p>
                <p>Redirección es una forma de decirle a PowerShell que tome los resultados de un comando y los coloque en algún lugar que no sea en la ventana de PowerShell. Para redirigir un comando, ponemos un paréntesis angular derecho (<code rend="inline">&gt;</code>) entre el comando y el lugar donde queremos que vaya su salida. En este caso, queremos que la salida de nuestro comando <code rend="inline">write</code> termine en<code rend="inline"> benjamin.txt</code>. Así que usamos la flecha hacia arriba para recuperar la declaración, y añadimos <code rend="inline">&gt; benjamin.txt</code> al final. Todo el asunto debería ser así:</p>
                <p>
                    <code rend="inline">write "La técnica de la reproducción separa el objeto reproducido del dominio de la tradición." &gt; benjamin.txt</code>
                </p>
                <p>Cuando presiones Enter parecerá que nada sucede. Esto se debe a que la instrucción <code rend="inline">write</code> fue redirigida. Para ver qué es lo que realmente ocurrió, usa <code rend="inline">gci</code> para ver el contenido de tu directorio. Ten en cuenta que la longitud de <code rend="inline">benjamin.txt</code> ya no es 0. ¡Esto es porque acabamos de poner texto en él!</p>
                <h3>Leer archivos con <code rend="inline">Get-Content</code> (<code rend="inline">gc</code>, <code rend="inline">cat</code>)</h3>
                <p>Ya que <code rend="inline">gci</code> nos muestrta que hay algo en el archivo, sería bueno poder ver qué frase pusimos en él. Podríamos hacerlo con el comando: <code rend="inline">notepad benjamin.txt</code>, lo que abriría el documento en el Bloc de notas. Pero también hay un <emph>cmdlet</emph> para imprimir el contenido del archivo en PowerShell que se llama <code rend="inline">Get-Content</code>. Escribe:</p>
                <p>
                    <code rend="inline">gc benjamin.txt</code>
                </p>
                <p>¡Y ahí está tu frase!</p>
                <p>Ustilizar <code rend="inline">gc</code> es útil por sí mismo, pero no resulta tan interesante. Si lo combinamos con la redirección, podemos hacer mucho más. Para empezar, podemos poner el contenido de un archivo en otro, casi igual que copiar un archivo. Ya sabes cómo hacerlo con <code rend="inline">cp</code>. Haz una copia de <code rend="inline">benjamin.txt</code> llamada <code rend="inline">benjamin1.txt</code> usando <code rend="inline">cp</code>. Ese comando se verá así:</p>
                <p>
                    <code rend="inline">cp benjamin.txt benjamin1.txt</code>
                </p>
                <p>Ahora haz un archivo <code rend="inline">benjamin2.txt</code> con el mismo contenido que<code rend="inline"> benjamin.txt</code>, pero usando <code rend="inline">gc</code> y redirección. Intenta averiguar cómo se hace.</p>
                <p>En caso de que no lo logres, aquí está la respuesta:</p>
                <p>
                    <code rend="inline">gc benjamin.txt &gt; benjamin2.txt</code>
                </p>
                <p>Por supuesto que esto es solamente una forma más engorrosa de hacer lo que ya podemos hacer con <code rend="inline">cp</code>. Pero la diferencia en estos métodos es sustancial porque al usar <code rend="inline">gc</code> podemos agregar información a un archivo de texto sin reemplazar lo que ya está allí, y también podemos obtener el contenido de varios archivos de texto y ponerlos en otro.</p>
                <p>En primer lugar vamos a aprender a adjuntar. Necesitamos algo que añadir a texto así que hagamos un nuevo archivo llamado <code rend="inline">siguiente.txt</code> y escribamos la frase "Haciendo muchas reproducciones sustituye una pluralidad de copias para una existencia única." Podríamos hacer nuestro archivo primero con <code rend="inline">ni</code>, pero no es necesario. Si le decimos a PowerShell que escriba en un archivo que no está en tu directorio, lo creará para nosotros. Así podemos simplemente escribir:</p>
                <p>
                    <code rend="inline">write "Haciendo muchas reproducciones sustituye una pluralidad de copias para una existencia única." &gt; siguiente.txt</code>
                </p>
                <p>Utiliza <code rend="inline">gc</code>para comprobar que se creó <code rend="inline">siguiente.txt</code> y que es realmente lo que queremos que sea.</p>
                <p>Ahora vamos a agregar el contenido de <code rend="inline">siguiente.txt</code> a <code rend="inline">benjamin.txt</code> usando <code rend="inline">gc</code>y redirección. Parece simple, ¿verdad? Inténtalo con este comando:</p>
                <p>
                    <code rend="inline">gc siguiente.txt &gt; benjamin.txt</code>
                </p>
                <p>Luego comprueba lo que sucedió con el comando <code rend="inline">gc benjamin.txt</code>. Verás que efectivamente pusiste el contenido de <code rend="inline">siguiente.txt</code> en<code rend="inline"> benjamin.txt</code>, pero has <emph>reemplazado</emph> el contenido que ya estaba allí y ¡esto no es lo que queríamos hacer!</p>
                <p>Al usar <code rend="inline">&gt;</code>, le ordenamos a PowerShell que pusiera el contenido de un texto en otro y sobrescribió lo que ya estaba allí. Podemos arreglar esto usando <code rend="inline">&gt;&gt;</code> para nuestro redireccionamiento en lugar de un solo <code rend="inline">&gt;</code>. Esto le dice a PowerShell que agregue la nueva información. Prueba esto:</p>
                <p>
                    <code rend="inline">gc siguiente.txt &gt;&gt; benjamin1.txt</code>
                </p>
                <p>Utiliza <code rend="inline">gc</code> para comprobar que <code rend="inline">benjamin1.text</code> ahora tiene ambas frases.</p>
                <figure>
                    <desc>La diferencia entre `&gt;` y `&gt;&gt;`</desc>
                    <graphic url="intro-to-powershell5.png"/>
                </figure>
                <p>Ahora veamos cómo obtener el contenido de varios archivos al mismo tiempo.</p>
                <h3>Trabajar con varios archivos a la vez usando caracteres comodín (<code rend="inline">*</code>)</h3>
                <p>Ahora debes tener cuatro archivos en tu directorio, cada uno con una o dos frases del ensayo sobre el arte de Walter Benjamin. Es posible que hayas perdido la pista de lo que está exactamente en ellos. Utilicemos <code rend="inline">gc</code> para comprobar el contenido.</p>
                <p>Podríamos ver cada uno individualmente. Pero como puedes haber adivinado se puede mostrar el contenido de los cuatro archivos con un solo comando. Escribe:</p>
                <p>
                    <code rend="inline">gc benjamin.txt, benjamin1.txt, benjamin2.txt, siguiente.txt</code>
                </p>
                <p>y obtendrás la frase impresa tres veces. Podemos hacerlo aún más rápidamente. Inténtalo:</p>
                <p>
                    <code rend="inline">gc *.txt</code>
                </p>
                <p>El resultado será exactamente el mismo. Lo que hace <code rend="inline">*.txt</code> es decirle a PowerShell que encuentre todo lo que termine con <code rend="inline">.txt</code>. El <code rend="inline">*</code> se llama <hi rend="bold">comodín</hi>, y se puede usar para reemplazar cualquier parte de un nombre de archivo. Escribe <code rend="inline">gc ben*</code> y obtendrás sólo los textos que comiencen con "ben". Dado que los únicos archivos de este directorio son los cuatro que queremos, puedes incluso escribir <code rend="inline">gc *</code> y obtener el contenido que nos interesa haciendo que PowerShell juestre todo lo que está en el directorio.</p>
                <h3>Búsquedas con <code rend="inline">Select-String</code> (<code rend="inline">sls</code>)</h3>
                <p>Por supuesto que no siempre queremos ver todo el contenido sino que querramos encontrar contenido específico. Al utilizar <code rend="inline">*</code>, podemos buscar varios archivos al mismo tiempo. Una de nuestras oraciones tenía algo acerca de "existencia única", ¿no? ¿Donde fue eso? Podemos usar el <emph>cmdlet</emph>
                    <code rend="inline">Select-String</code> para buscar fragmentos específicos de texto. Escribe:</p>
                <p>
                    <code rend="inline">sls "existencia única" *.txt</code>
                </p>
                <p>y PowerShell arrojará todas las líneas que contengan esa cadena de caracteres de cualquier archivo de nuestro directorio que termine en <code rend="inline">.txt</code>.</p>
                <p>El uso de <code rend="inline">sls</code> en archivos tan pequeños como los nuestros no nos ahorrará mucho tiempo comparado con el que ocuparíamos si leyéramos los archivos nosotros mismos. Pero el uso de este <emph>cmdlet</emph> con un mayor número de archivos, más largos, puede ser extraordinariamente útil.</p>
                <h3>Bucles infinitos y abortar procesos con <code rend="inline">control-c</code>
                </h3>
                <p>Veamos una tarea más útil que podemos lograr combinando <code rend="inline">gc</code>, comodines y redirección. Supongamos que tenemos muchos archivos diferentes que queremos combinar en un nuevo archivo, por ejemplo, porque hemos descargado cientos de letras de canciones que necesitamos analizar y  agrupar las de un solo artista en un archivo único. Aunque podríamos hacer esto especificándolos todos, es decir, <code rend="inline">gc texto1, texto2, texto3&gt; nuevotexto</code>, al tener cientos de textos puede resultar una tarea bastante engorrosa. Los comodines sirven para evitar esto.</p>
                <p>Vamos a concatenar nuestros cuatro textos y colocar el resultado en un quinto texto. Quizá usar <code rend="inline">*.txt</code> puede parecer un auxiliar práctico. <hi rend="bold">Estamos a punto de hacer algo tonto, así que por favor, lee el siguiente párrafo antes de escribir este comando!</hi>
                </p>
                <p>Intentemos</p>
                <p>
                    <code rend="inline">gc *.txt &gt; granben.txt</code>
                </p>
                <p>Parecerá que tu computadora no hace nada. Pero, a diferencia de otras veces cuando tu computadora aparenta que no ha hecho nada, esta vez el prompt del símbolo del sistema no vuelve a aparecer. Si intentas escribir otro comando no sucederá nada. Esto es porque PowerShell todavía está trabajando en tu último comando. A medida que haces más y más cosas complicadas con PowerShell, es algo que a veces sucede -¡estás haciendo sudar a tu computadora!-. Pero, en este caso, PowerShell nunca dejará de trabajar con este comando ya que está en un bucle infinito. Afortunadamente, puedes abortar esta tarea con:</p>
                <p>
                    <code rend="inline">control-c</code>
                </p>
                <p>La utilidad de <code rend="inline">control-c</code> es grande, ya que a veces puedes quedar atrapado accidentalmente en un bucle infinito o, simplemente, puedes hartarte de esperar a que tu computadora haga ciertas tareas extremadamente largas.</p>
                <p>¿Cómo nos quedamos atrapados en ese bucle? Le dijimos a PowerShell que pusiera todos los archivos que terminaran en <code rend="inline">.txt</code> en un nuevo archivo que terminara en <code rend="inline">.txt</code>. Dado que ese nuevo archivo caía bajo la rúbrica de archivos que el equipo debía concatenar y agregar a <code rend="inline">granben.txt</code>, lo añadió. Y luego, ya que tenía un archivo <code rend="inline">.txt</code> con nuevo contenido, lo añadió también. Este es un excelente ejemplo de algo que a menudo olvidamos sobre nuestras computadoras: no son inteligentes. Son extremadamente potentes pero carecen absolutamente de sentido común. Los humanos miramos las instrucciones e intentamos interpretarlas. "No puede significar, para mí, agregar el contenido del texto final de nuevo en sí mismo una y otra vez para siempre." Los ordenadores, por otro lado, hacen exactamente lo que les decimos, sin importar lo ilógicos que sean nuestros mandamientos. A medida que adquieras experiencia trabajando con la línea de comandos, te sentirás desconcertado por las interpretaciones excesivamente literales de sus comandos, pero también aprenderán a darle instrucciones que puede seguir. Los bucles infinitos deben evitarse a toda costa, pero se producirán, y cuando lo hagan, recuerda: <code rend="inline">control-c</code>.</p>
                <h3>Especificación de <emph>cmdlets</emph> con parámetros</h3>
                <p>Hemos visto que tu computadora necesita que le digan cosas de manera muy exacta. Afortunadamente, PowerShell proporciona métodos para refinar los <emph>cmdlets</emph> añadiendo parámetros.</p>
                <p>Veamos un ejemplo: utiliza <code rend="inline">gci</code> para comprobar que tienes cinco archivos en tu directorio. Uno de ellos, <code rend="inline">granben.txt</code>, es muy grande. Escribe:</p>
                <p>
                    <code rend="inline">gc granben.txt</code>
                </p>
                <p>PowerShell comenzará a descargar una cantidad excesiva de texto en la pantalla. Es posible que quieras interrumpir el proceso con <code rend="inline">control-c</code>, pero esto no es un bucle infinito, sólo se trasta de un archivo muy grande, por lo que puedes esperar a que todo se imprima, sólo que tardará un tiempo. Al final, puedes usar el <emph>cmdlet</emph>
                    <code rend="inline">clear</code> si te molesta el gran bloque de texto en la pantalla.</p>
                <p>Lo que queremos comprobar es que "granben.txt" está compuesto por las líneas de los otros textos, repetidas una y otra vez. Podemos hacer esto mirando sólo al principio y al final, y para ello, agregamos un <hi rend="bold">parámetro</hi> a nuestro <emph>cmdlet</emph>.</p>
                <p>Introduce esto:</p>
                <p>
                    <code rend="inline">gc granben.txt -totalcount 10</code>
                </p>
                <p>Verás las primeras 10 líneas de tu texto. Asegúrate de incluir el guión, ya que de lo contrario PowerShell no sabrá que <code rend="inline">-TotalCount</code> es un parámetro. Ahora escribe:</p>
                <p>
                    <code rend="inline">gc granben.txt -tail 10</code>
                </p>
                <p>y verás las últimas 10 líneas. Lo que hemos hecho es especificarle a nuestro <emph>cmdlet</emph>
                    <code rend="inline">gc</code> los parámetros <code rend="inline">-totalcount</code> y <code rend="inline">-tail</code>. Casi todos los <emph>cmdlets</emph> pueden ser refinados añadiendo parámetros como este. Pero, ¿cómo sabemos qué parámetros están disponibles?</p>
                <h3>Más información sobre <code rend="inline">Get-Help</code>
                </h3>
                <p>PowerShell no espera que memorices todos los parámetros posibles para todos los <emph>cmdlets</emph>^. En su lugar, proporciona una forma sencilla de enumerarlos utilizando el <emph>cmdlet</emph>
                    <code rend="inline">Get-Help</code>. Escribe</p>
                <p>
                    <code rend="inline">Get-Help gc</code>
                </p>
                <p>y obtendrás una pantalla que se ve así:</p>
                <figure>
                    <desc>Páginas de ayuda de `Get-Content`</desc>
                    <graphic url="intro-to-powershell6.png"/>
                </figure>
                <p>Tu página puede ser ligeramente distinta, pero la parte importante para mirar en este momento es la sección llamada "SYNTAX". Esta nos muestra todos los parámetros que podemos agregar a <code rend="inline">Get-Content</code>. Si estás tratando de recordar el nombre exacto de un parámetro que has utilizado antes, esta ayuda será suficiente. Sin embargo, no nos dice lo que realmente hacen los parámetros.</p>
                <p>Afortunadamente, el mismo <code rend="inline">Get-Help</code> tiene parámetros y, agregando <code rend="inline">-online</code> al <emph>cmdlet</emph>
                    <code rend="inline">Get-Help</code>, le indicas a PowerShell que pida a tu navegador abrir una página en el portal TechNet de Microsoft que explica todos los parámetros (en inglés). Escribe:</p>
                <p>
                    <code rend="inline">Get-Help gc -online</code>
                </p>
                <figure>
                    <desc>La página de ayuda en línea para `Get-Content`</desc>
                    <graphic url="intro-to-powershell7.png"/>
                </figure>
                <p>Ahí podemos ver la descripción completa de los parámetros <code rend="inline">-TotalCount</code> y <code rend="inline">-Tail</code>.</p>
                <h3>Solución del problema de bucle infinito con el parámetro <code rend="inline">-exclude</code>
                </h3>
                <p>Observa de nuevo la ayuda de <code rend="inline">Get-Content</code> y verás que uno de los parámetros es <code rend="inline">-exclude</code>. Esto suena prometedor para tratar con nuestro problema del bucle infinito. La descripción en línea dice: Omite los elementos especificados. El valor de este parámetro califica el parámetro de <hi rend="bold">ruta</hi>. Introduzca un elemento o patrón de ruta, como "*.txt". Los comodines están permitidos." El "parámetro de ruta" es, normalmente, lo que escribes inmediatamente después de tu <emph>cmdlet</emph>. Indica a PowerShell dónde se va a aplicar el <emph>cmdlet</emph>. Cuando escribimos <code rend="inline">gc benjamin.txt</code>, <code rend="inline">benjamin.txt</code> es la ruta. En realidad, es una abreviatura de <code rend="inline">.\Benjamin.txt</code>, que a su vez es una abreviatura de <code rend="inline">C:\Users\TUNOMBREDEUSUARIO\diversionConPowerShell\dir\benjamin.txt</code>. Esa línea le dice a su computadora el camino a seguir a través de la estructura de tu sistema de archivos, similar a la de un árbol, para encontrar el archivo que deseas. Entonces, lo que la ayuda nos está diciendo es que podemos omitir elementos específicos de nuestro <emph>cmdlet</emph>
                    <code rend="inline">gc</code> añadiendo el parámetro <code rend="inline">-exclude</code> y luego ingresando la ruta que queremos que excluya. Podemos utilizar esto para tomar el contenido de todos nuestros archivos <code rend="inline">.txt</code> y ponerlos en un nuevo archivo sin crear un bucle infinito. Trata de averiguar qué escribir, utilizando lo que hicimos con <code rend="inline">-totalcount</code> y<code rend="inline"> -tail</code> como referencia.</p>
                <p>Esto es lo que yo hice. Primero eliminé mi <code rend="inline">granben.txt</code> actual con <code rend="inline">rm</code>. Aunque esto no es realmente necesario, ya que al usar un solo <code rend="inline">&gt;</code> en el rediccionamiento reemplazaría el contenido actual de todos modos, pero es agradable tener un inicio limpio. Entonces escribí:</p>
                <p>
                    <code rend="inline">gc *.txt -exclude granben.txt &gt; granben.txt</code>
                </p>
                <p>Voilà!</p>
                <p>A lo largo de este proceso, hemos estado agregando textos juntos o concatenándolos. Puedes obtener más información sobre <ref target="https://es.wikipedia.org/wiki/Concatenaci%C3%B3n">concatenación en Wikipedia</ref>, y si quieres ver algunos ejemplos más de concatenación usando PowerShell, echa un vistazo a esta <ref target="https://blogs.technet.microsoft.com/heyscriptingguy/2014/07/15/keep-your-hands-clean-use-powershell-to-glue-strings-together">entrada de blog</ref> (en inglés), que te llevará al maravilloso mundo de las variables, algo más allá del alcance de este tutorial, pero acerca de las que vale la pena aprender.</p>
                <h3>Obtener más provecho de los <emph>cmdlets</emph> con Piping</h3>
                <p>Tenemos ahora cinco documentos en nuestro directorio. Con el fin de poder hacer cosas realmente útiles con ellos necesitamos una herramienta más: <hi rend="bold">canalización</hi>. Ésta es una especie de redirección, pero en lugar de decirle a PowerShell que coloque los resultados de un <emph>cmdlet</emph> en otro lugar, le dice que tome la salida de un <emph>cmdlet</emph> y lo use como entrada para otro. Donde usamos <code rend="inline">&gt;</code> para la redirección, para las canalizaciones usamos <code rend="inline">|</code>.</p>
                <p>Vamos a obtener aún mayor rendimiento de <code rend="inline">gc</code>, canalizando los resultados al <emph>cmdlet</emph>
                    <code rend="inline">measure-object</code> (o simplemente <code rend="inline">measure</code>). Este último <emph>cmdlet</emph> tiene varias propiedades. Para nuestro propósito, lo usaremos para obtener el número de líneas, palabras y caracteres en nuestros archivos agregando los parámetros <code rend="inline">-line</code>,<code rend="inline"> -word</code> y <code rend="inline">-character</code>, o simplemente<code rend="inline"> -l</code>, <code rend="inline">-w</code>, <code rend="inline">-c</code>. (Con los parámetros, sólo necesitas escribir el nombre adecuado para identificar el parámetro en cuestión. Utiliza <code rend="inline">Get-Help</code> para averiguar cuál será para un determinado <emph>cmdlet</emph>).</p>
                <p>Escribe esto:</p>
                <p>| <code rend="inline">gc benjamin.txt | measure -l -w -c</code> |</p>
                <p>Lo que debes obtener es un recuento de las líneas, palabras y caracteres del texto. Por supuesto, podrías hacer esto fácilmente con tu procesador de textos. Sin embargo, el poder que te da trabajar en línea de comandos es el de ser capaz de manipular muchas cosas a la vez y especificar lo que quieres hacer con mucha mayor precisión. En este ejemplo significa que podemos contar palabras en varios de nuestros archivos a la vez, y que podemos agregar parámetros adicionales para especificar exactamente cómo queremos contarlos.</p>
                <p>Obtén el recuento de líneas, palabras y caracteres de todos los archivos en el directorio. No debería sorprendernos que el comodín (<code rend="inline">*</code>) pueda ser también de gran ayuda. Por ejemplo, puedes escribir:</p>
                <p>| <code rend="inline">gc *.txt | measure -l -w -c</code> |</p>
                <p>Con nuestros cinco pequeños archivos esto todavía no resulta muy vistoso, pero habrías perdido más tiempo usando el procesador de textos. También podríamos hacerlo con un directorio que contenga miles de archivos largos. También podemos controlar nuestras acciones con mayor precisión con parámetros adicionales. Utiliza <code rend="inline">Get-Help measure</code> para ver los parámetros a tu disposición. Podríamos ir a la ayuda en línea para aprender más sobre ellos, pero por ahora vamos a usar uno que se explica por sí mismo como un ejemplo que consiste en ignorar los espacios en blanco: <code rend="inline">-IgnoreWhiteSpace</code>.</p>
                <p>Utiliza la flecha hacia arriba para recuperar tu último comando y agrega <code rend="inline">-ignorewhitespace</code> al final. También puedes escribir <code rend="inline">-ig</code>. Ten en cuenta que <code rend="inline">-i</code> solo no es suficiente, ya que no diferencia el parámetro <code rend="inline">-IgnoreWhiteSpace</code> del parámetro <code rend="inline">-InputObject</code>, como te lo indicará un útil mensaje de error si lo intentarás. Verás el mismo recuento pero con menos caracteres, porque esta vez PowerShell no contó los espacios. La ventaja de la precisión es clara sobre el uso de un procesador de textos, donde es difícil determinar si se ignora o no el espacio en blanco en primer lugar, dejando de lado las posibilidades de cambiar funciones según tus necesidades.</p>
                <h2>Utilización de herramientas de línea de comandos y ejecución de secuencias de comandos en Python</h2>
                <p>La razón más importante para familiarizarse con el uso de la línea de comandos no es la mayor precisión o capacidad para trabajar con archivos, si bien estas características son útiles. Su importancia radica en que permite el acceso a muchas herramientas adicionales, como se mencionó en la introducción. Cuando se configura PowerShell para trabajar con algunas de estas herramientas, puede tener problemas ya que, a veces, Windows dispone las rutas incorrectamente. La solución a este problema requiere de una configuración correcta de las <ref target="https://es.wikipedia.org/wiki/Variable_de_entorno">variables de entorno</ref>, un tema que va más allá del alcance de este tutorial. Afortunadamente, hay mucha infortmación disponible en línea y con un poco de búsqueda darás con la solución que necesitas. Debido a que muchas lecciones de <emph>The Programming Historian</emph> en español requieren que utilices Python, echaremos un vistazo brevemente a la configuración para Python. Una vez hecho esto, estarás menos intimidado por las instrucciones para establecer variables de entorno para otros programas.</p>
                <p>Si aún no tienes Python, o si te preguntas por qué deberías usarlo, consulta el <ref target="/es/lecciones/introduccion-e-instalacion">tutorial de Python</ref> aquí en <emph>The Historian</emph> en español. En dicho tutorial, aprenderás a configurar Python para ejecutar secuencias de comandos directamente en un editor de texto. Pero, generalmente, será muy útil poder ejecutar <emph>scripts</emph> desde la línea de comandos. Para ello, necesitamos establecer una variable de entorno. Primero, necesitas saber el nombre del directorio donde Python está instalado en tu computadora. Introduce <code rend="inline">sl C:\</code> y luego utiliza <code rend="inline">gci</code>. Deberías ver un directorio llamado "Python" con el número de versión al final. En mi computadora, el directorio es "Python27". Ahora le ordenamos a Windows que cree una variable de ruta (<emph>Path</emph>) que apunte a ese directorio introduciendo esto en PowerShell, reemplazando "Python27" por el nombre del directorio en tu computadora:</p>
                <p>
                    <code rend="inline">[Environment]::SetEnvironmentVariable("Path", "$env:Path;C:\Python27", "User")</code>
                </p>
                <p>Esto le dice a Windows: "Oye, la ruta para Python es: C:\Python27". Si quieres entender exactamente cómo funciona esto, mira <ref target="https://technet.microsoft.com/en-us/library/ff730964.aspx">esta página</ref> (en inglés) en el portal TechNet de Microsoft (el mismo portal que utilizas en línea con <code rend="inline">Get-Help</code>).</p>
                <p>Una vez que hayas corrido el comando anterior, sal de PowerShell y vuelve a iniciarlo. Entonces deberías poder abrir el intérprete de Python escribiendo <code rend="inline">python</code> en PowerShell. Para ejecutar <emph>scripts</emph>, simplemente escribe <code rend="inline">python</code> seguido de la ruta del <emph>script</emph> que quieres. Es más fácil navegar primero al directorio que contiene el <emph>script</emph>, y luego simplemente escribir <code rend="inline">python nombre-de-script.py</code>.</p>
                <p>Ahora ya estás preparado para ejecutar <emph>scripts</emph> de Python desde la línea de comandos.</p>
            </div>
            <div type="1">
                <head>Conclusión</head>
                <p>En este tutorial has aprendido algunos de los conceptos básicos para trabajar con PowerShell, la interfaz de línea de comandos de Windows. Ya sabes lo suficiente para usar PowerShell para muchas de las tareas cotidianas que haces en tu computadora y yo recomendaría usarlo para eso. Al principio puede resultar más difícil copiar un archivo y moverlo a un nuevo directorio desde la línea de comandos, pero cuanto más practiques más natural será. Eventualmente, te encontrarás cómodamente trabajando en PowerShell, y serás capaz de hacer muchas tareas más fácilmente de esta manera.</p>
                <p>Aunque sólo hemos dado un vistazo de lo que puede hacer PowerShell, ahora tienes suficientes conocimientos básicos para aprender a hacer más cosas. Hay muchos recursos útiles en línea y los puedes hacer tuyos con Google. También es útil saber que muchas discusiones sobre el uso de la línea de comandos se basarán en Unix y otros sistemas *nix. En la mayoría de los casos, si simplemente escribes en un buscador los nombres de los comandos que estás utilizando junto con "PowerShell", encontrarás el <emph>cmdlet</emph> correspondiente.</p>
                <p>Cuanto más utilices PowerShell más fácil será descubrir capacidades que ni siquiera sabías que tenía tu computadora. Eventualmente, notarás cómo el uso de la GUI te ha restringido en el uso de la potencialidad de tu máqiuna. No dejarás de usar la GUI, pero te encontrarás iniciando PowerShell cada vez con mayor frecuencia para liberarte de estas limitaciones y utilizar tu computadora de manera más completa. Tu computadora es como una navaja de bolsillo. La GUI sólo te permite abrir algunas cuchillas; ¡pero con la línea de comandos puedes abrirlas todas!</p>
            </div>
            <head>Referencia rápida</head>
            <p>Esta tabla sirve como una referencia rápida a todos los <emph>cmdlets</emph> mencionados en esta lección. La primera columna muestra el nombre real; el segundo muestra la abreviatura que normalmente se escribe. El equivalente de Bash muestra el comando más similar en Bash. A menos que este comando esté entre paréntesis, también se puede utilizar en PowerShell como un alias para el <emph>cmdlet</emph> correspondiente. Para obtener una explicación más completa de cualquiera de los <emph>cmdlets</emph>, utiliza <code rend="inline">Get-Help</code> con el parámetro <code rend="inline">-online</code> (por ejemplo, <code rend="inline">Get-Help Get-ChildItem -online</code>).</p>
            <table>
                <row>
                    <cell role="label">Cmdlet</cell>
                    <cell role="label">Alias</cell>
                    <cell role="label">Bash Equivalent</cell>
                    <cell role="label">Description</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Get-ChildItem</code>
                    </cell>
                    <cell>
                        <code rend="inline">gci</code>
                    </cell>
                    <cell>
                        <code rend="inline">ls</code>
                    </cell>
                    <cell>Enlista los directorios y archivos en la ubicación actual.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Set-Location</code>
                    </cell>
                    <cell>
                        <code rend="inline">sl</code>
                    </cell>
                    <cell>
                        <code rend="inline">cd</code>
                    </cell>
                    <cell>Cambia al directorio en la ruta de acceso dada. Si escribes <code rend="inline">..</code> en lugar de una ruta te moverá hacia arriba un directorio.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Push-Location</code>
                    </cell>
                    <cell>
                        <code rend="inline">pushd</code>
                    </cell>
                    <cell>
                        <code rend="inline">pushd</code>
                    </cell>
                    <cell>Cambiar al directorio.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Pop-Location</code>
                    </cell>
                    <cell>
                        <code rend="inline">popd</code>
                    </cell>
                    <cell>
                        <code rend="inline">popd</code>
                    </cell>
                    <cell>Regresa al directorio previo despues de usar <code rend="inline">pushd</code>
                    </cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">New-Item</code>
                    </cell>
                    <cell>
                        <code rend="inline">ni</code>
                    </cell>
                    <cell>(<code rend="inline">touch</code>)</cell>
                    <cell>Crea un nuevo ítem. De no utilizarse un parámetro, el ítem será un archivo por defecto. El uso de <code rend="inline">mkdir</code> es una abreviatura para incluir el parámetro <code rend="inline">-ItemType dir</code>.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">mkdir</code>
                    </cell>
                    <cell>none</cell>
                    <cell>
                        <code rend="inline">mkdir</code>
                    </cell>
                    <cell>Crea un nuevo directorio. (Ver <code rend="inline">New-Item</code>.)</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Explorer</code>
                    </cell>
                    <cell>none</cell>
                    <cell>(<code rend="inline">open</code>)</cell>
                    <cell>Abre algo utilizando el Explorador de archivos (la GUI)</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Remove-Item</code>
                    </cell>
                    <cell>
                        <code rend="inline">rm</code>
                    </cell>
                    <cell>
                        <code rend="inline">rm</code>
                    </cell>
                    <cell>Borra algo... ¡de manera permanente!</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Move-Item</code>
                    </cell>
                    <cell>
                        <code rend="inline">mv</code>
                    </cell>
                    <cell>
                        <code rend="inline">mv</code>
                    </cell>
                    <cell>Mueve algo. Necesita dos argumentos. Primero un nombre de archivo (i.e. su ruta actual), luego la ruta de nueva nueva locación (incluido el nombre que debe tener ahí). Si no se cambia la ruta, puede usarse para renombrar archivos.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Copy-Item</code>
                    </cell>
                    <cell>
                        <code rend="inline">cp</code>
                    </cell>
                    <cell>
                        <code rend="inline">cp</code>
                    </cell>
                    <cell>Copia un archivo en una nueva ubicación. Requiere los mismos argumentos que mover, pero mantiene el archivo original en su ubicación.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Write-Output</code>
                    </cell>
                    <cell>
                        <code rend="inline">write</code>
                    </cell>
                    <cell>
                        <code rend="inline">echo</code>
                    </cell>
                    <cell>Exporta lo que escribas. Utiliza la redirección para enviarlo a un archivo. La redirección con <code rend="inline">&gt;&gt;</code> añadirá texto al archivo en lugar de sobrescribir el contenido.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Get-Content</code>
                    </cell>
                    <cell>
                        <code rend="inline">gc</code>
                    </cell>
                    <cell>
                        <code rend="inline">cat</code>
                    </cell>
                    <cell>Obtiene el contenido de un archivo y lo imprime en la pantalla. La adición del parámetro <code rend="inline">-TotalCount</code> seguido de un número x sólo imprime las primeras x líneas. Añadiendo el parámetro <code rend="inline">-Tail</code> seguido de un número x sólo imprime las x líneas finales.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Select-String</code>
                    </cell>
                    <cell>
                        <code rend="inline">sls</code>
                    </cell>
                    <cell>(<code rend="inline">grep</code>)</cell>
                    <cell>Busca contenido específico.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Measure-Object</code>
                    </cell>
                    <cell>
                        <code rend="inline">measure</code>
                    </cell>
                    <cell>(<code rend="inline">wc</code>)</cell>
                    <cell>Obtiene información estadística sobre un objeto. Utiliza <code rend="inline">Get-Content</code> y dirige la salida a<code rend="inline"> Measure-Object</code> con los parámetros <code rend="inline">-line</code>, <code rend="inline">-word</code> y <code rend="inline">-character</code> para obtener información sobre el recuento de líneas, palabras o caracteres.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">&gt;</code>
                    </cell>
                    <cell>none</cell>
                    <cell>
                        <code rend="inline">&gt;</code>
                    </cell>
                    <cell>Redirección. Pone la salida del comando a la izquierda de <code rend="inline">&gt;</code> en un archivo a la derecha de <code rend="inline">&gt;</code>.</cell>
                </row>
                <row>
                    <cell>`</cell>
                    <cell>`</cell>
                    <cell>none</cell>
                    <cell>`</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">Get-Help</code>
                    </cell>
                    <cell>none</cell>
                    <cell>
                        <code rend="inline">man</code>
                    </cell>
                    <cell>Obtiene el archivo de ayuda de un <emph>cmdlet</emph>. La adición del parámetro <code rend="inline">-online</code> abre la página de ayuda en TechNet.</cell>
                </row>
                <row>
                    <cell>
                        <code rend="inline">exit</code>
                    </cell>
                    <cell>none</cell>
                    <cell>
                        <code rend="inline">exit</code>
                    </cell>
                    <cell>Salir de PowerShell</cell>
                </row>
            </table>
        </body>
    </text>
</TEI>
