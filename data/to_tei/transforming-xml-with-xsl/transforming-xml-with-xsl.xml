<TEI xmlns="https://tei-c.org/ns/1-0/">
  <metadata>
  <title>Transforming Data for Reuse and Re-publication with XML and XSL</title>
  <layout>lesson</layout>
  <date>2016-07-07</date>
  <authors>M. H. Beals</authors>
  <reviewers>Jonathan Blaney,Tessa C Hauswedell</reviewers>
  <editors>Adam Crymble</editors>
  <difficulty>1</difficulty>
  <review-ticket>https://github.com/programminghistorian/ph-submissions/issues/11</review-ticket>
  <activity>transforming</activity>
  <topics>data-manipulation,data-visualization</topics>
  <abstract>This tutorial will provide you with the ability to convert or transform historical data from an XML database (whether a single file or several linked documents) into a variety of different presentations&#8212;condensed tables, exhaustive lists or paragraphed narratives&#8212;and file formats.</abstract>
  <redirect_from>/lessons/transforming-xml-with-xsl</redirect_from>
  <avatar_alt>A peacock with a woman's head</avatar_alt>
  <doi>10.46430/phen0097</doi>
</metadata>
  <text>
    <body><div class="alert alert-info">
Due to recent changes in security policies of web browser, which can no longer execute XSL code from local sources, the original approach of this lesson has had to be rethought.
This lesson was updated in March 2022 by Nicol&#225;s Vaughan.
</div>
<div n="1"><head>Introduction</head>
<p>The day before your colleague is due to give a seminar on <emph>Slave Rebellions in the New World</emph>, he phones you to say he is ill and needs you to cover his sessions. You decide to compile a selection of primary sources to work through in class. You find some websites and readers with good sources, but scanning or cutting-and-pasting them into a new document is time consuming; the formatting and citations are inconsistent and you begin to wonder if the ones you have chosen work well together. One site allows you to download an <link target="https://en.wikipedia.org/wiki/XML">XML</link> version of all its sources, but there are so many records, and so much <link target="https://en.wikipedia.org/wiki/Metadata">metadata</link>, that you cannot find the material you want quickly.</p>
<p>Or perhaps...</p>
<p>You find an old copy of <emph>Inscriptions of Roman Tripolitania</emph> (1952) and wish that you could run a statistical analysis on the appearance of certain phrases in certain locations. Fortunately, King's College London has produced an extensive <link target="https://irt.kcl.ac.uk/irt2009/">e-version of the text</link> with images, translations and location information. You can search through the material manually using the full-text search on the site, but curating the information you want, in the format you need to run an analysis, will take time.</p>
<p>Then again...</p>
<p>You are starting a new project analysing book auction catalogues from the early seventeenth century. You start recording the publication details and auction listings into a series of Word documents and Excel spreadsheets. A month into the project, you are invited to present your research to the Pro-Vice Chancellor. Your head of department suggests that you create a 'snazzy' set of slides and handouts to help her understand your project.  You have some preliminary conclusions about the material, but the data is scattered in several places and formatting it properly will take more time than you have.</p>
<p>In all three of these situations, a basic understanding of XML, and its sister-language <link target="https://en.wikipedia.org/wiki/XSL">XSL</link>, could have saved you time and aggravation.<ref type="footnotemark" target="#1"/>
This tutorial will provide you with the ability to convert or transform historical data from an <link target="https://en.wikipedia.org/wiki/XML">XML</link> database (whether a single file or several linked documents) into a variety of different presentations---condensed tables, exhaustive lists or paragraphed narratives---and file formats. Whether filtering a large database or adding formatting such as headings and pagination, XSL offers digital researchers the ability to reshape databases to support their changing research or publication needs.</p>
</div><div n="1"><head>What is XML?</head>
<p>The eXtensible Markup Language (XML) is a highly flexible method for encoding or structuring your data.
Unlike <link target="https://en.wikipedia.org/wiki/HTML">Hypertext Markup Language (HTML)</link>, which has a set vocabulary, XML is extensible; it can be expanded to include whatever sections, sub-sections, and sub-sub-sections you need in order to store your data in the way you wish.</p>
<p>A database can be made up of one or more XML files and each file has the same basic structure. Each section, or layer, of the file is surrounded by a set of <link target="https://en.wikipedia.org/wiki/XSLT_elements">elements</link>. An element is, essentially, a category or name for the type of data you are providing. Like <link target="https://en.wikipedia.org/wiki/Matryoshka_doll">Russian Nesting Dolls</link>, each level of elements exists entirely within another one. The <hi rend="bold">top-level element</hi> encloses the entire database. Each element within the top-level element is a <hi rend="bold">child</hi> of that element. Likewise, the element surrounding a child element is called the <hi rend="bold">parent</hi> element. </p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_0" type="block" corresp="code_transforming-xml-with-xsl_0.txt"></code></pre>
<p>Depending on the rules of your database, every element can have a value (textual or numerical) as well as any number of child elements.</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_1" type="block" corresp="code_transforming-xml-with-xsl_1.txt"></code></pre>
<p>They can also have <link target="https://en.wikipedia.org/wiki/Attribute_(computing)">attributes</link>, which can be thought of as metadata for the element. Attributes can, for example, help you distinguish between different types of values without having to create a new type of element.</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_2" type="block" corresp="code_transforming-xml-with-xsl_2.txt"></code></pre>
<p>Once you are given an XML database, or have stored your own data within one, you can use XSL to sort, filter and display this information in (almost) any way you wish. You can even break open OpenXML files, such as Word (.docx) or Excel (.xslx) files, and see or remove any additional information that Microsoft has inserted into your documents, such as tags identifying geographical locations.</p>
<p>A more detailed discussion of XML, its structure, and its use in the humanities, is available from the <link target="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/SG.html">Text Encoding Initative</link>.</p>
</div><div n="1"><head>What is XSL?</head>
<p>eXtensible Stylesheet Language (XSL) is the natural complement to XML. At its most basic level, it provides layout and formatting instructions in much the same way as <link target="https://en.wikipedia.org/wiki/Cascading_Style_Sheets">Cascading Stylesheets (CSS)</link> do for HTML files. This allows you to transform your plain-text data into richly formatted text, as well as dictate its layout on a screen or in print, without altering your original data files. At a more advanced level, it also allows you to sort or filter your records based on particular critera, or create and display compound or derived values based on your original dataset.</p>
<p>By keeping your data (XML) and formatting instructions (XSL) separate, you are able to refine and alter your layout without the risk of compromising the structure of your data. You are also able to create a number of different <emph>styles</emph>, each serving a different purpose, and apply them as necessary to a single data set. In practice, this means only having to update your data in one place, even if you export it to many different documents.</p>
<p>The following tutorial will therefore explain:</p>
<ul>
<li><hi rend="bold">editors</hi>: the tools needed to create XSL transformation files</li>
<li><hi rend="bold">transformers</hi>: the tools needed to apply your XSL transformation instructions to your XML documents</li>
<li><hi rend="bold">choosing and preparing XML data</hi>: how to connect your XML data to your XSL transformation instructions</li>
</ul>
<p>It will walk you through the creation of some of the most common transformations intructions as well, including:</p>
<ul>
<li><hi rend="bold">printing values</hi>: how to print or display your data</li>
<li><hi rend="bold">for-each loops</hi>: how to display particular data for each record</li>
<li><hi rend="bold">sorting results</hi>: how to display your data in a particular order</li>
<li><hi rend="bold">filtering results</hi>: how to select which records you display</li>
</ul>
</div><div n="1"><head>Necessary and Helpful Software Packages</head>
<div n="2"><head>Editors</head>
<p>One of the advantages of storing data in a plain-text format is the ease of obtaining appropriate software for viewing and manipulating it.
For the purposes of this tutorial,
we recommend that you install the open-source editor <link target="https://code.visualstudio.com/">Visual Studio Code</link> ("VSCode", for short),
although any other programming editor can be used for this tutorial (Notepad++, Atom, Emacs, Vim, etc.).
VSCode handles and conserves the plain-text format of your data while providing you with different colour schemes (such as green-on-black or brown-on-beige) as well the ability to collapse (hide) sections or easily comment-out (temporarily disable) sections of your code.</p>
<p>When you become more comfortable with XML and XSL, and are ready to tackle more complicated transformations, you may want to consider using a dedicated XML editor, such as <link target="https://www.oxygenxml.com/">OxygenXML</link>, although it is neither free nor open-source.</p>
</div><div n="2"><head>XSL Processors</head>
<p>Once you have installed VSCode on your system, you will need to install an <hi rend="bold">XSL processor</hi>.
There are several ways to use XSL stylesheets to transform your XML data:</p>
<ul>
<li>via the web browser, using an embedded simple XSL processor</li>
<li>via an XSL processor included in an XML program or editor</li>
<li>via a standalone XSL processor from the command line (or as a binding within another programming language)</li>
</ul>
<p>Until recently, the first option would have been the most comfortable way to learn how to work with XSL.
However, web browsers have introduced security restrictions that make it more difficult to natively transform local XML documents.
In order to avoid this problem, you could install add-ons in Chrome or Firefox, or modify their security policies directly, to allow transformations to run.
However, this has the disadvantage of making the web browser vulnerable to certain kinds of cyber attacks.
For this reason, we will avoid taking this route.</p>
<p>The second option requires the installation of a specialised editor such as Oxygen XML Editor or Altova XMLSpy.
However, since these are neither free nor open source editors, we will not take this route either.</p>
<p>We are left with the third option.
We will use a free and open source XSL processor called <link target="https://www.saxonica.com/download/java.xml">Saxon-HE</link>, developed by Michael Kay, one of the most renowned specialists in the field of XML, XSLT, XPath, XQuery, and related technologies.
The "HE" in "Saxon-HE" stands for "Home Edition".
<link target="https://www.saxonica.com/">Saxonica</link>, Michael Kay's software house, also has much more powerful editions of the Saxon processor for sale, suitable for larger projects and higher technical requirements.
However, for our purposes &#8212;and indeed for most projects requiring XML transformation via XSLT&#8212; the Saxon-HE edition is more than sufficient.</p>
<div n="3"><head>Saxon-HE Installation</head>
<p>Saxon-HE is a Java application (in fact, its full technical name is "SaxonJ-HE").
Accordingly, our system must have a Java Virtual Machine (Java VM) installed in order to run this edition of Saxon.
Saxon-HE version 11, the latest version to date, requires at least Java SE 8 (JDK 1.8).
We must make sure that it is installed on our system.
If it is not, we must install it ourselves.</p>
<p>To check if it is, we will use the command line of our operating system.
In order to do that, let us open our terminal emulator (hereinafter, the "terminal").
If you are on Microsoft Windows, it is advisable to use either <link target="https://docs.microsoft.com/en-us/powershell/">PowerShell</link> or <link target="https://git-scm.com/downloads">Git Bash</link>.
If you are on Mac OS, you can use the application <link target="https://support.apple.com/guide/terminal/welcome/mac">Terminal.app</link> (included by default in the system).
Finally, on Linux you can use any terminal application.</p>
<p>If you are on Windows, type the following command and press enter:</p>
<pre><code class="language-sh" xml:id="code_transforming-xml-with-xsl_3" type="block" corresp="code_transforming-xml-with-xsl_3.txt"></code></pre>
<p>On MacOS and Linux you must type the following:</p>
<pre><code class="language-sh" xml:id="code_transforming-xml-with-xsl_4" type="block" corresp="code_transforming-xml-with-xsl_4.txt"></code></pre>
<p>(note the double hyphen <code type="inline">--</code>).</p>
<p>If Java is not installed, you will get an error message like this one:</p>
<pre><code class="language-sh" xml:id="code_transforming-xml-with-xsl_5" type="block" corresp="code_transforming-xml-with-xsl_5.txt"></code></pre>
<p>But if it is installed, you will get something like this:</p>
<pre><code class="language-sh" xml:id="code_transforming-xml-with-xsl_6" type="block" corresp="code_transforming-xml-with-xsl_6.txt"></code></pre>
<p>Now, if the Java version is less than 1.8, or if it is simply not installed, you must download and install the latest version.
To do this, go to the official Java download page, <link target="https://www.java.com/en/download/">https://www.java.com/en/download/</link>,
and download the appropriate version for your operating system.
After installing it, you must reboot your system so that the global variables, which inform the system where the Java executable is, are applied.
Once this is done, check the Java version again at the command line.<ref type="footnotemark" target="#2"/></p>
<p>Next you will need to download and install Saxon.
Do this from the Saxonica SourceForge repository at this address:
<link target="https://sourceforge.net/projects/saxon/files/Saxon-HE/11/Java/">https://sourceforge.net/projects/saxon/files/Saxon-HE/11/Java/</link>
Look for the most recent version in the list, which as of today is 11.2.
Now download the <code type="inline">SaxonHE11-2J.zip</code> file (or the most recent one) and unzip it inside some folder on your computer.</p>
<p>Next open the terminal <emph>in that exact folder</emph> and run the following command (bear in mind that the executable &#8212;<code type="inline">saxon-he-11.2.jar</code>&#8212; may be named differently in your case):</p>
<pre><code class="language-sh" xml:id="code_transforming-xml-with-xsl_7" type="block" corresp="code_transforming-xml-with-xsl_7.txt"></code></pre>
<p>(the <code type="inline">-t</code> option tells Saxon to display its version, as well as other useful information).</p>
<p>For example, on Windows you will get:</p>
<pre><code class="language-sh" xml:id="code_transforming-xml-with-xsl_8" type="block" corresp="code_transforming-xml-with-xsl_8.txt"></code></pre>
<p>Now, since you have unzipped Saxon into a random folder (in <code type="inline">C:\Users\user\Downloads</code>, in our example), you will only be able to run Saxon from there.
This means that if you are in another location on your system, you won't be able to simply run the <code type="inline">java -jar saxon-he-11.2.jar</code> command to get started, since the <code type="inline">saxon-he-11.2.jar</code> executable won't be available there.
This is not really a problem.
You just need to make sure that the XML and XSL documents you want to use in your transformations are always <hi rend="bold">in the same folder</hi> as your Saxon executable.<ref type="footnotemark" target="#3"/>
The command line code examples we will show here will assume that this is the case.</p>
</div></div></div><div n="1"><head>Choosing and Preparing XML Data</head>
<p>In order to begin transforming XML, you will need to obtain a well-formed dataset. Many online historical databases are built upon XML and provide their data freely. This tutorial will make use of the <link target="http://www.scissorsandpaste.net">Scissors and Paste Database</link>.</p>
<p>The <emph>Scissors and Paste Database</emph> is a collaborative and growing collection of articles from British and imperial newspapers in the 18th and 19th centuries. Its original purpose was to allow for careful comparisons of reprints (copies) that appeared in multiple newspapers as well as to detect similarly themed articles across different English-language publications. Like many XML databases, <emph>Scissors and Paste</emph> contains both data (the article's text), formatting information (such as italics and justification), and metadata. This metadata includes documentation about the particular article, such as its pagination and printing date, information about the newspaper in which it was published, and the themes, individuals or locations mentioned in the text.</p>
<p>As of 2015, the database contained over 350 individual articles, each with attached metadata. Although some researchers may need all of this information, most will only be interested in a subsection of the data---a particular year, theme or publication. By using XSL, these researchers can quickly filter out the information they do not need or re-arrange the material in the way that is most helpful for their project. For example, the module tutor in our introduction or a researcher who wants a simple table of the dates, publications and page numbers of humorous articles within the database. Both can be quickly created using XSL.</p>
<p>To begin work with the Scissors and Paste Database, download the following ZIP archive: <link target="/assets/transforming-xml-with-xsl/master.zip"><code type="inline">master.zip</code></link>.
Open the ZIP file and you will find a folder named <hi rend="bold">scissorsandpaste-master</hi>.  Extract this folder by either using the extract button of your unzipping programme or by dragging and dropping the folder onto your desktop.</p>
<p>This data package has three main items:</p>
<ul>
<li><code type="inline">TEISAP.XML</code>: The central XML database</li>
<li><code type="inline">Transformers</code>: A collection of XSL stylesheets</li>
<li><code type="inline">Outputs</code>: Outputs derived from the database using the XSL stylesheets</li>
</ul>
<p>The package also includes:</p>
<ul>
<li>a <code type="inline">Template</code>, for anyone wishing to contribute to the database</li>
<li>a <code type="inline">README</code> file, providing information about the database</li>
<li>a <code type="inline">Cite</code> file, explaining the preferred way to cite the database</li>
<li>a <code type="inline">License</code> file, explaining the terms of use</li>
</ul>
<p>Once you have completed the tutorial, you can explore the different XSL stylesheets (transformers) included here, and their associated outputs, to discover additional possibilities for your own datasets.</p>
<p>The main <code type="inline">TEISAP.XML</code> database has been encoded to <link target="https://tei-c.org/">Text-Encoding Initiative (TEI)</link> standards and includes a significant amount of metadata. For the purposes of this tutorial, however, we will be using a simplified version of the database that focuses on some of the core historical data.</p>
<p>Open the outputs folder and continue into the XML folder. Here you will find a folder entitled <code type="inline">Simplified</code>. Next, copy the <code type="inline">SimplifiedSAP.xml</code> file to the same folder you previously unzipped the Saxon executable into.</p>
<p>Open the <code type="inline">SimplifiedSAP.xml</code> file in VSCode and examine it now.</p>
<figure><desc>Figure 1: Viewing the XML</desc><graphic url="transforming-xml-with-xsl-1.png"/></figure>
<p>The first line of the XML database is:</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_9" type="block" corresp="code_transforming-xml-with-xsl_9.txt"></code></pre>
<p>which indicates the version of XML used (1.0) and the encoding method of the text (<link target="https://en.wikipedia.org/wiki/UTF-8">UTF-8</link>). The second line is <code type="inline">&lt;root&gt;</code>, which has a matching line, <code type="inline">&lt;/root&gt;</code>, at the end of the file.</p>
<p><code type="inline">&lt;root&gt;</code> is the top-level element of this database and surrounds all the records within it. Each individual record, containing the information for one historical newspaper article, is opened by the element <code type="inline">&lt;record&gt;</code> and closed with the element <code type="inline">&lt;/record&gt;</code>.</p>
<p>Within these records there are a number of different child elements. The Text-Encoding Initiative allows for hundreds of different sub-elements to fit a very wide range of data. Moreover, the beauty of XML is that you can name your elements anything you like (<link target="https://www.w3schools.com/xml/xml_elements.asp">with a few small exceptions</link>).
In the Scissors and Paste Database, each record has the following elements:</p>
<ul>
<li><code type="inline">&lt;id&gt;</code>: The ID number of the record</li>
<li><code type="inline">&lt;title&gt;</code>: The title of the newspaper</li>
<li><code type="inline">&lt;city&gt;</code>: The city of the newspaper</li>
<li><code type="inline">&lt;province&gt;</code>: The province or administrative region of the newspaper</li>
<li><code type="inline">&lt;country&gt;</code>: The country of the newspaper</li>
<li><code type="inline">&lt;date&gt;</code>: The full <link target="https://en.wikipedia.org/wiki/ISO_8601">ISO date</link> of the article</li>
<li><code type="inline">&lt;year&gt;</code>: The year of publication</li>
<li><code type="inline">&lt;month&gt;</code>: The month of publication</li>
<li><code type="inline">&lt;day&gt;</code>: The day of publication</li>
<li><code type="inline">&lt;keywords&gt;</code>: The section containing keywords describing the article</li>
<li><code type="inline">&lt;keyword&gt;</code>: An individual keyword describing the article</li>
<li><code type="inline">&lt;headline&gt;</code>: The headline of the article. This may be blank.</li>
<li><code type="inline">&lt;text&gt;</code>: The section containing the text of the article</li>
<li><code type="inline">&lt;p&gt;</code>: An individual paragraph within the text.</li>
</ul>
<p>These are the different types of data that you will be able to use in creating your outputs.</p>
</div><div n="1"><head>Creating and Testing Your XSL File</head>
<p>It is now time to create your XSL file.
To do this, open VSCode, create a new blank file and save it as <code type="inline">mystyle.xsl</code>.
Once again, make sure the file is saved in the same directory that contains both the <code type="inline">SimplifiedSAP.xml</code> file and the Saxon executable.</p>
<p>The first three lines of your XSL file should be the following:</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_10" type="block" corresp="code_transforming-xml-with-xsl_10.txt"></code></pre>
<p>The first line documents that this is an XML document encoded as UTF-8.
The second line states that the document is an XSL document version 1.0 and the standards (or <link target="https://en.wikipedia.org/wiki/Namespace">namespace</link>) established by the <link target="http://www.w3.org/">World Wide Web Consortium</link>, whose web address you have listed.
(Note that an XSL document is ultimately an XML document!)
Finally, the third line tells your transformer what sort of output you would like to create. In this case, you are indicating that you will be creating a plain-text file.
(You could also have written <code type="inline">xml</code> or <code type="inline">html</code>, instead of <code type="inline">text</code>, in order to produce an XML or and HTML document, respectively.)</p>
<p>Every time you open an element <code type="inline">&lt;element&gt;</code> you will need to close it <code type="inline">&lt;/element&gt;</code> (or however the element is named); otherwise you will receive an syntax error as the document is not well-formed.
Close your stylesheet by adding the following as the final line of your file:</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_11" type="block" corresp="code_transforming-xml-with-xsl_11.txt"></code></pre>
<p>The next part of your XSL stylesheet will be the main template, or formatting instructions, for your output.
On a new line, directly underneath <code type="inline">&lt;xsl:output method="text"/&gt;</code> type</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_12" type="block" corresp="code_transforming-xml-with-xsl_12.txt"></code></pre>
<p>It is between these two elements that you will put all your layout instructions.</p>
<p>You have written <code type="inline">/</code> in your <code type="inline">match</code> attribute to indicate that you will be referring to everything within the XML file.
You could have also used <code type="inline">root</code>, which would have indicated that you were only using data within the <code type="inline">&lt;root&gt;</code> element.
However, using <code type="inline">root</code> may cause unexpected later on, so it is best practice to use <code type="inline">/</code> for your main template.</p>
<p>Your file should now look like this:</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_13" type="block" corresp="code_transforming-xml-with-xsl_13.txt"></code></pre>
<p>Save your file.  For the remainder of the tutorial, remember to save your file after each change you make. </p>
<p>In between your template elements, type <code type="inline">&lt;xsl:value-of select="root"/&gt;</code> You do not need to do so on a new line, nor to indent it to the right, but doing so will make your stylesheet more readable. You'll notice that I didn't include a closing  <code type="inline">&lt;/xsl:value-of&gt;</code> tag. This is because <code type="inline">&lt;xsl:value-of select="root"/&gt;</code> is self-closing; the <code type="inline">/</code> at the end of the element closes it immediately.</p>
<p>Your <code type="inline">mystyle.xsl</code> file should look like this:</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_14" type="block" corresp="code_transforming-xml-with-xsl_14.txt"></code></pre>
<p>Next, you will transform the contents of the <code type="inline">SimplifiedSAP.xml</code> document into plain text, by means of the XSL stylesheet you have just created.
To do this, go to the command line and run the following:</p>
<pre><code class="language-sh" xml:id="code_transforming-xml-with-xsl_15" type="block" corresp="code_transforming-xml-with-xsl_15.txt"></code></pre>
<p>When you run this command, you will see a huge amount of text displayed in the terminal, so much so that it is not easy to read it right there.
The <code type="inline">-xsl:</code> option provides the name of the XSL stylesheet that Saxon will use to transform the XML document, while the <code type="inline">-s:</code> option (from <emph>source</emph>) provides the name of that very document.
If you want to save the text given by Saxon as its output, you must use the <code type="inline">-o:</code> option (from <emph>output</emph>), followed by a filename, for example like so:</p>
<pre><code class="language-sh" xml:id="code_transforming-xml-with-xsl_16" type="block" corresp="code_transforming-xml-with-xsl_16.txt"></code></pre>
<p>(This will always be the command you must run in the terminal to transform an XML document via an XSLT stylesheet.
You must run it <emph>every time</emph> you want to perform a transformation.
In other words, you can't just make changes to your stylesheet to make the transformation happen; you must always run Saxon to do it.)</p>
<p>Now you can open the <emph>output.txt</emph> file in VSCode to inspect it.
The result should be the text with the existing line breaks, but <emph>without</emph> the XML elements, as seen in the following image:</p>
<figure><desc>Figure 2: Initial text output</desc><graphic url="transforming-xml-with-xsl-2.png"/></figure>
</div><div n="1"><head>Populating Your Outputs</head>
<p>Your single line of code <code type="inline">&lt;xsl:value-of select="root"/&gt;</code> selected (and printed) the entire database in plain-text format.<br/>
If you look at the components of this line, you can see why:</p>
<ul>
<li>
<p><code type="inline">xsl:value-of</code>: an instruction for selecting the value of an element; that is, the text between the opening and closing tag of an element within the XML file.</p>
</li>
<li>
<p><code type="inline">select="root"</code>: an instruction that explains which element it should select the value of.
Unless you instruct it otherwise, pointing to a parent (outside) element will also tell the transformer to select the values of any child (inside) elements as well.
Thus, pointing to element <code type="inline">&lt;root&gt;</code>  also selects elements <code type="inline">&lt;id&gt;</code>, <code type="inline">&lt;title&gt;</code> and so on, which are contained in it.
(Technically speaking <code type="inline">select</code> is an <emph>attribute</emph> of the <code type="inline">&lt;xsl:value-of&gt;</code> element, and  the <emph>value</emph> of that attribute is <code type="inline">root</code> here.)</p>
</li>
</ul>
</div><div n="1"><head>Selecting and Printing Values</head>
<p>In order to select and print the value of a particular element, you simply need to replace <code type="inline">root</code> with its name. Let's try it.
In your XSL stylesheet, replace <code type="inline">root</code> with <code type="inline">title</code> in the proper line:</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_17" type="block" corresp="code_transforming-xml-with-xsl_17.txt"></code></pre>
<p>Save your file, run the transformation command in the terminal once again, and examine the result in VSCode.
(VSCode with automatically refresh the window whenever it detects the output file has changed.)</p>
<p>It didn't work? That is because the XSL processor didn't know where to find the <code type="inline">&lt;title&gt;</code> elements. Let's see why.</p>
<div n="2"><head>Parents and Children</head>
<p><code type="inline">&lt;title&gt;</code> is not the top-level element, so we must explain to the XSL processor how to get to the element we mean.
This more specific direction is known as the <link target="https://en.wikipedia.org/wiki/XPath"><emph>XPATH</emph></link> of the element, and works in a similar way to the file paths on your computer. Replace <code type="inline">title</code> with <code type="inline">root/record/title</code>, like so;</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_18" type="block" corresp="code_transforming-xml-with-xsl_18.txt"></code></pre>
<p>Save the file, execute Saxon to run the transformation again, and examine the result in VSCode.</p>
<p>The editor should now display <code type="inline">Caledonian Mercury</code>, the title of the first register in our database. Where are the rest? Although, we have over 300 <emph>title</emph> values in the database, we did not specify which we wanted the XSL processor to select and print, so it assumed we meant the first one, and only the first one. When the XSL processor selects and prints it, it stops.<ref type="footnotemark" target="#4"/></p>
</div><div n="2"><head><code type="inline">For</code> Loops</head>
<p>To a human being, it may seem natural that we wanted <emph>all</emph> the titles, but the XSL processor does not know this by default.
Instead, we must create a <emph><code type="inline">for</code> loop</emph>, which, besides selecting and printing them, affords us a great deal of control on the way it does so.</p>
<p>In XSL, a <code type="inline">for</code> loop tells the transformer that <emph>for</emph> a certain condition, it should <emph>loop</emph> through the entire database and follow the instructions each time the data meets certain criteria.</p>
<p>Create a new line after <code type="inline">&lt;xsl:template match="/"&gt;</code> and insert <code type="inline">&lt;xsl:for-each select="root/record"&gt;</code>.  This tells the transformer that for each <emph>record</emph> within the <emph>root</emph> element, it should take some action.</p>
<p>Remove <code type="inline">root/record</code> from your <code type="inline">&lt;xsl:value-of&gt;</code> element.
It should now simply say <code type="inline">title</code>, because we are now already within a <code type="inline">root/record</code> context.
After your <code type="inline">&lt;xsl:value-of&gt;</code>, add a new line that closes the <code type="inline">&lt;xsl:for-each&gt;</code> element, <code type="inline">&lt;/xsl:for-each&gt;</code></p>
<p>Your file should look like this now:</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_19" type="block" corresp="code_transforming-xml-with-xsl_19.txt"></code></pre>
<p>Here you can see that your <code type="inline">&lt;xsl:template&gt;</code> contains three lines of code:</p>
<ol>
<li>an opening tag for your loop</li>
<li>an instruction for selecting one <code type="inline">&lt;title&gt;</code> and printing its contents</li>
<li>a closing tag for your loop</li>
</ol>
<p>Save your file, run the transformation, and examine the output in VSCode again.
You should now have a very messy line of text, listing the value of every title element in the database. </p>
<p>You can organise this data by instructing the transformer to add a new line after each entry.
Just below the <code type="inline">&lt;xsl:value-of select="title"/&gt;</code> line, type <code type="inline">&lt;xsl:text&gt;&amp;#xA;&lt;/xsl:text&gt;</code> to add a line break.
<code type="inline">&amp;#xA;</code> is the <link target="https://en.wikipedia.org/wiki/Newline">ISO 10646 hex code</link> for a new line.<ref type="footnotemark" target="#5"/>
The <code type="inline">&lt;xsl:text&gt;</code> element tells the transformer to print the value as plain text.
Depending on the type of outputs you are using (with the <code type="inline">&lt;xsl:output&gt;</code> element), some special characters, particularly multiple spaces or line breaks, may not render correctly if entered on their own.
Using <code type="inline">&lt;xsl:text&gt;</code> elements ensures that your text renders exactly the way you intend it to.</p>
<p>The complete code of your XSL file is therefore the following:</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_20" type="block" corresp="code_transforming-xml-with-xsl_20.txt"></code></pre>
<p>Save the file, execute Saxon to run the transformation again, and examine the result in VSCode.
Using this information, you should now be able to print the value of any element for each record in the database.</p>
<div n="3"><head>Exercise A:</head>
<blockquote>
<p>Note: Possible solutions for the following exercises are located at the end of the tutorial.</p>
</blockquote>
<p>Print an inventory of the records in database, displaying the <emph>id</emph>, <emph>title</emph> and <emph>date</emph> of each record. A solution to this and the following exercises is available at the end of the tutorial.</p>
</div><div n="3"><head>Exercise B:</head>
<p>Print the text of all the articles in the database, displaying the <emph>id</emph> in square brackets (<code type="inline">[]</code>) at the start of each article.</p>
</div></div><div n="2"><head>Attributes</head>
<p>In an element, not all data is stored as its <emph>content</emph> (i.e., what is found between its opening and closing tags).
Some data can be stored as the value of an <emph>attribute</emph> of that element.
For example the <code type="inline">&lt;date&gt;</code> element has an attribute called <code type="inline">when</code> with the value of the date of the article:</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_21" type="block" corresp="code_transforming-xml-with-xsl_21.txt"></code></pre>
<p>To print the value of <code type="inline">when</code> you will need to reference the attribute using <code type="inline">@when</code> (note the <code type="inline">@</code> before it):</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_22" type="block" corresp="code_transforming-xml-with-xsl_22.txt"></code></pre>
<p>which means: select and print the value <code type="inline">when</code> of element <code type="inline">&lt;date&gt;</code>.</p>
<div n="3"><head>Exercise C</head>
<p>Create an inventory of records in the database, listing the title of the newspaper followed by the date of publication.</p>
</div></div></div><div n="1"><head>Sorting Results</head>
<p>This XML database was compiled as data was collected, rather than by date or title.<br/>
To re-sort it, you can add a <code type="inline">&lt;xsl:sort&gt;</code> element to the top of any <code type="inline">for</code> loop, immediately following the <code type="inline">&lt;xsl:for-each&gt;</code> element.<br/>
This instruction has several optional attributes that will dictate how your data is sorted:</p>
<ul>
<li><code type="inline">select</code>: contains the name of the element to sort the data by</li>
<li><code type="inline">order</code>: informs the XSL processor if the data should be sorted in an <code type="inline">ascending</code> or <code type="inline">descending</code> order</li>
<li><code type="inline">data-type</code>: informs the transformer if the data is <code type="inline">text</code> or a <code type="inline">number</code></li>
</ul>
<p>It must be attributed in this order.
For example, to sort the element <code type="inline">&lt;id&gt;</code>, whose content is numerical, in reverse order, use:</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_23" type="block" corresp="code_transforming-xml-with-xsl_23.txt"></code></pre>
<p>You can sort by an element even if you do not print that element in your output.</p>
<div n="2"><head>Exercise D</head>
<p>Print the text of all the articles in the database, sorting from earliest to latest. For the purposes of the <code type="inline">&lt;xsl:sort&gt;</code> element, treat dates as <code type="inline">text</code>.</p>
</div></div><div n="1"><head>Filtering Results</head>
<p>So far, you have selected and printed all the records contained in the database.
If you only want a selection of records, you will need to filter the results using an <hi rend="bold"><code type="inline">if</code> statement</hi>.
An <code type="inline">&lt;xsl:if&gt;</code> element has one attribute, which is a test condition.
If the condition is true, the XSL processor will follow the instructions within the <code type="inline">&lt;xsl:if&gt;</code> element.
If not, it will ignore these statements and move onto the next part of the template.</p>
<p>For example, to print the <emph>id</emph> numbers of all the records from 1789, you would type:</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_24" type="block" corresp="code_transforming-xml-with-xsl_24.txt"></code></pre>
<p>If you want to exclude year 1789, use <code type="inline">date/year!='1789'</code> instead. (<code type="inline">!=</code> means <emph>not equal to</emph>.)</p>
<div n="2"><head>Exercise E</head>
<p>Using all you have learned so far, create a list of records from 1789, starting with the most recent, listing the id, title, and date of each record.
Separate the data elements with commas and place each record on its own line.</p>
<p>If you wish, you can specify the output file to be a <link target="https://en.wikipedia.org/wiki/Comma-separated_values">Comma Separated Values (CSV)</link> file, which can be opened and manipulated as a spreadsheet with Microsoft Excel or LibreOffice Calc.
To do this, simply specify it on the command line when you perform the transformation:</p>
<pre><code class="language-sh" xml:id="code_transforming-xml-with-xsl_25" type="block" corresp="code_transforming-xml-with-xsl_25.txt"></code></pre>
</div></div><div n="1"><head>Conclusion</head>
<p>You now know the basics of XSL stylesheet creation.
With this information you can create a range of outputs including plain text, comma-separated, tab-separated and markdown files.
You can also create web pages by changing your <code type="inline">&lt;xsl:output&gt;</code> method to <emph>html</emph> and  wrapping your <code type="inline">&lt;xsl:value-of&gt;</code> commands in the appropriate HTML tags.</p>
<p>There are many more transformation commands that you can use to further customise your outputs.
Some of these require the use of a 2.0 or 3.0 XSL processor, but the above should cover most of your day-to-day transformation needs.</p>
<p>Once you are comfortable using the commands listed here, explore the <code type="inline">Transformers</code> folder of the Scissors and Paste Database to see further examples of how to transform XML structured data.</p>
</div><div n="1"><head>Possible Solutions to the Exercises</head>
<div n="2"><head>Introduction (Primary Source Reader)</head>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_26" type="block" corresp="code_transforming-xml-with-xsl_26.txt"></code></pre>
<p>The dot (<code type="inline">.</code>) in the XSL element <code type="inline">&lt;xsl:value-of select="."/&gt;</code> is a shorthand for the name of the current element in context.
In this case it is the element selected with the <code type="inline">&lt;xsl:for-each select="text/p"&gt;</code> statement, i.e. the <code type="inline">&lt;p&gt;</code> child of <code type="inline">&lt;text&gt;</code>.
If we had used <code type="inline">p</code> instead, we would not select anything, as there is no <code type="inline">text/p/p</code>.</p>
</div><div n="2"><head>Exercise A</head>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_27" type="block" corresp="code_transforming-xml-with-xsl_27.txt"></code></pre>
</div><div n="2"><head>Exercise B</head>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_28" type="block" corresp="code_transforming-xml-with-xsl_28.txt"></code></pre>
<p>To remove the indentation preceding the ID number between brackets, you will need to take more direct control of your whitespace by using line-breaks before each ID number and paragraph, as seen below:</p>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_29" type="block" corresp="code_transforming-xml-with-xsl_29.txt"></code></pre>
</div><div n="2"><head>Exercise C</head>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_30" type="block" corresp="code_transforming-xml-with-xsl_30.txt"></code></pre>
<p>You'll notice I used <code type="inline">&amp;#32;</code> in between my two values. This is the HEX code for a space. You could have also used a literal space, but this is may not render correctly in all cases. You could have also used a comma or any other divider.</p>
</div><div n="2"><head>Exercise D</head>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_31" type="block" corresp="code_transforming-xml-with-xsl_31.txt"></code></pre>
</div><div n="2"><head>Exercise E</head>
<pre><code class="language-xml" xml:id="code_transforming-xml-with-xsl_32" type="block" corresp="code_transforming-xml-with-xsl_32.txt"></code></pre>
</div></div><div n="1"><head>Further Reading</head>
<ul>
<li>Hunter, David <emph>et al</emph>. <emph>Beginning XML</emph>, 4th ed. Indianapolis, IN: Wiley, 2007.</li>
<li>Kay, Michael, <emph>XSLT 2.0 and XPATH 2.0: Programmer's Reference</emph>. Indianapolis, IN: Wiley, 2011.</li>
<li>Kelly, David J. <emph>XSLT Jumpstarter: Level the Learning Curve and Put Your XML to Work</emph>. Raleigh, NC: Peloria Press, May 2015.</li>
<li>Mangano, Sal. <emph>XSLT Cookbook</emph>, 2nd ed. Sebstopol, CA: O'Reilly, 2006.</li>
<li>Riley, Jenn. <link target="https://www.niso.org/node/12366"><emph>Understanding Metadata: What is Metadata, and What is For?</emph></link> NISO, 2017.</li>
<li>Tennison, Jeni. <emph>Beginning XSLT 2.0. From Novice to Professional</emph>. New York: Apress, 2005.</li>
<li>Tidwell, Doug. <emph>XSLT</emph>, 2nd ed. Sebstopol, CA: O'Reilly, 2008.</li>
</ul>
</div><div n="1"><head>Notes</head>
<p><note id="1"> The XSL language has two branches: (1) <emph>XSL Formatting Objects</emph> (XSL:FO), which contains formatting instructions for producing a PDF document from an XML document; and (2) <emph>Extensible Stylesheet Language Transformations</emph> (XSLT), which contains instructions for transforming an XML document into other documents (XML, HTML, XHTML and plain text). In this tutorial only the second one is discussed.</note></p>
<p><note id="2"> If you have already installed the latest version and still get an error message that it is not installed, you will have to manually adjust the <code type="inline">PATH</code> variable on your system. </note>
See <link target="https://stackoverflow.com/questions/16811332/cannot-run-java-from-the-windows-powershell-command-prompt">this explanation</link> for more details.</p>
<p><note id="3"> An alternative solution is to place the Saxon executable in a folder that is already included in the <code type="inline">PATH</code> global system variable (or to change that variable to include the folder we have chosen for Saxon).</note>
However, such technical details are beyond the scope of this tutorial.
(For those interested, see these pages on how to do this on <link target="https://www.computerhope.com/issues/ch000549.htm">Windows</link>,
<link target="https://stackoverflow.com/questions/22465332/setting-path-environment-variable-in-osx-permanently">MacOS</link> and
<link target="https://opensource.com/article/17/6/set-path-linux">Linux</link>.)</p>
<p><note id="4"> As of XSLT version 2.0, the <code type="inline">&lt;xsl:value-of&gt;</code> statement selects <emph>all</emph> occurrences of the expression in the XML document. </note>
(On this, see <link target="https://www.w3.org/TR/2021/REC-xslt20-20210330/#changes">here</link>.)
If the reader wishes to try this, they should change the value of the <code type="inline">@version</code> attribute from <code type="inline">1.0</code> to <code type="inline">2.0</code> (or <code type="inline">3.0</code>) in the <code type="inline">&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;</code> line of the XSL stylesheet.</p>
<p><note id="5"> Alternatively, you can replace that line with this code:</note></p>
<pre><code xml:id="code_transforming-xml-with-xsl_33" type="block" corresp="code_transforming-xml-with-xsl_33.txt"></code></pre>
</div></body>
  </text>
</TEI>
