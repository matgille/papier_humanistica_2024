<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:id="introducao-dados-abertos-conectados">
    <teiHeader>
        <fileDesc>
            <titleStmt>
                <title>Introdução aos Dados Abertos Conectados</title>
                <author role="original_author">Jonathan Blaney</author>
                <editor role="reviewers">
                    <persName>Terhi Nurmikko-Fuller</persName>
                    <persName>Matthew Lincoln</persName>
                </editor>
                <author role="translators">Francisco Nabais</author>
                <editor role="translation-reviewers">
                    <persName>Bruno Almeida</persName>
                    <persName>Daniel Bonatto Seco</persName>
                </editor>
                <editor role="editors">Adam Crymble</editor>
            </titleStmt>
            <publicationStmt>
                <distributor>Programming Historian</distributor>
                <date type="translated">11/21/2022</date>
                <idno type="doi">10.46430/phpt0033</idno>
                <date type="published">08/05/2013</date>
            </publicationStmt>
            <sourceDesc>
                <p>Born digital, in a markdown format. Original file: <ref type="original_file" target="#intro-to-linked-data"/>.</p>
                <p>There are other translations: <ref target="#introduccion-datos-abiertos-enlazados"/>
                </p>
                <p>There are other translations: <ref target="#introduccion-datos-abiertos-enlazados"/>
                </p>
            </sourceDesc>
        </fileDesc>
        <profileDesc>
            <abstract>
                <p>Este tutorial apresenta os principais conceitos de dados abertos conectados (*Linked Open Data*), incluindo URIs, ontologias, formatos RDF e uma breve introdução à linguagem de consulta de gráficos SPARQL.</p>
            </abstract>
            <textClass>
                <keywords>
                    <term xml:lang="en">lod</term>
                </keywords>
            </textClass>
        </profileDesc>
    </teiHeader>
    <text xml:lang="pt">
        <body>
            <p>Nota de Tradução: Alguns termos, por aparecerem constantemente e facilitarem a interpretação das imagens, apenas foram propositadamente traduzidos uma vez e serão colocados entre parênteses. Alertamos também para a existência de alguns exemplos que não foram propositadamente traduzidos para facilitar a sua introdução nos programas apresentados.</p>
            <div type="2">
                <head>Introdução e Âmbito da lição</head>
                <p>Esta lição oferece uma breve e concisa introdução aos <ref target="https://pt.wikipedia.org/wiki/Linked_data#The_Linking_Open_Data_Project">dados abertos conectados</ref> (<emph>Linked Open Data</emph> ou LOD). Não é necessário conhecimento prévio para realizar este tutorial. Os leitores deverão obter uma compreensão clara dos conceitos por detrás dos dados abertos conectados, como são utilizados e como são criados. O tutorial está dividido em cinco partes, além de leituras adicionais:</p>
                <list type="ordered">
                    <item>Dados abertos conectados: o que são?</item>
                    <item>O papel do <ref target="https://pt.wikipedia.org/wiki/URI">Identificador Uniforme de Recurso</ref> (<emph>Uniform Resource Identifier</emph> ou URI)</item>
                    <item>Como o LOD organiza o conhecimento: <ref target="https://pt.wikipedia.org/wiki/Ontologia_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)">ontologias</ref>
                    </item>
                    <item>A <ref target="https://pt.wikipedia.org/wiki/Resource_Description_Framework">Estrutura de Descrição de Recursos</ref> (<emph>Resource Description Framework</emph> ou RDF) e formatos de dados</item>
                    <item>Consulta de dados abertos conectados com <ref target="https://pt.wikipedia.org/wiki/SPARQL">SPARQL</ref>
                    </item>
                    <item>Outras leituras e recursos</item>
                </list>
                <p>A conclusão deste tutorial poderá levar algumas horas e poderá ser útil reler algumas secções para solidificar a sua compreensão. Os termos técnicos foram ligados à sua página correspondente na Wikipedia e encoraja-se a que faça uma pausa e leia sobre termos que considere desafiadores. Depois de ter aprendido alguns dos princípios-chave do LOD, a melhor maneira de melhorar e solidificar esse conhecimento é praticar. Este tutorial fornece oportunidades para fazê-lo. No final da lição, deverá compreender os princípios básicos de LOD, incluindo termos e conceitos-chave.</p>
                <p>Se precisar aprender a como explorar LOD usando a linguagem de consulta <ref target="https://pt.wikipedia.org/wiki/SPARQL">SPARQL</ref>, recomenda-se a lição de Matthew Lincoln <ref target="/en/lessons/retired/graph-databases-and-SPARQL">'<emph>Using SPARQL to access Linked Open Data</emph>'</ref> (em inglês) (Nota: a lição deste link encontra-se desatualizada e já não é mantida pelo <emph>Programming Historian</emph>. Por favor veja a nota inicial dessa página sobre a razão dessa lição ter sido retirada), que segue praticamente a visão geral fornecida nesta lição.</p>
                <p>Para proporcionar aos leitores uma base sólida dos princípios básicos de LOD, este tutorial não oferecerá uma cobertura abrangente de todos os seus conceitos. Estes <hi rend="bold">não</hi> serão o foco desta lição:</p>
                <list type="ordered">
                    <item>
                        <ref target="https://pt.wikipedia.org/wiki/Web_sem%C3%A2ntica">Web Semântica</ref> e <ref target="https://en.wikipedia.org/wiki/Semantic_reasoner">raciocínio semântico</ref> (em inglês) de <ref target="https://pt.wikipedia.org/wiki/Conjunto_de_dados">datasets</ref>. Um raciocinador semântico deduziria que Jorge VI é o irmão ou meio-irmão de Eduardo VIII, dado que: a) Eduardo VIII é o filho de Jorge V e b) Jorge VI é o filho de Jorge V. Este tutorial não se foca neste tipo de tarefa.</item>
                    <item>Criação e <emph>upload</emph> de conjuntos de dados abertos conectados ligados à <ref target="http://linkeddatacatalog.dws.informatik.uni-mannheim.de/state/">Nuvem de dados conectados</ref> (em inglês). Partilhar LOD é um princípio importante, que é encorajado abaixo. Contudo, os aspetos práticos de contribuir com LOD para a nuvem de dados conectados estão além do âmbito desta lição. Alguns recursos que podem ajudar a começar esta tarefa estão disponíveis no final deste tutorial.</item>
                </list>
            </div>
            <table>
                <row>
                    <cell role="label">o sujeito</cell>
                    <cell role="label">o predicado</cell>
                    <cell role="label">o objeto</cell>
                </row>
                <row>
                    <cell>pessoa 64183282</cell>
                    <cell>representadaNoParlamentoBritânico</cell>
                    <cell>"blackburn1955-presente"</cell>
                </row>
            </table>
            <div type="2">
                <head>O papel do <emph>Uniform Resource Identifier</emph> (URI)</head>
                <p>Uma parte essencial de LOD é o <ref target="https://pt.wikipedia.org/wiki/URI">Identificador Uniforme de Recurso</ref>(<emph>Uniform Resource Identifier</emph> ou URI). O URI é uma forma única e fiável de representar uma entidade (uma pessoa, um objeto, uma relação, etc.), de uma forma que é utilizável por todos no mundo.</p>
                <p>Na secção anterior, utilizamos dois números diferentes para identificar os diferentes Jack Straws.</p>
                <ab>
                    <code xml:id="code_introducao-dados-abertos-conectados_6" corresp="code_introducao-dados-abertos-conectados_6.txt" rend="block"/>
                </ab>
                <p>O problema é que em todo o mundo existem muitas bases de dados que contêm pessoas com estes números e são, provavelmente, todas pessoas diferentes. Fora do nosso contexto imediato, estes números não identificam indivíduos únicos. Vamos tentar resolver isso. Aqui estão estes mesmos identificadores, mas como URIs:</p>
                <ab>
                    <code xml:id="code_introducao-dados-abertos-conectados_7" corresp="code_introducao-dados-abertos-conectados_7.txt" rend="block"/>
                </ab>
                <p>Tal como o número único desambiguou os nossos dois Jack Straws, o URI completo acima ajuda-nos a desambiguar entre todos os diferentes ficheiros de autoridade lá fora. Neste caso, é evidente que estamos a utilizar o VIAF como o nosso ficheiro de autoridade. Com certeza, já viu esta forma de desambiguação muitas vezes na web. Existem muitos websites em todo o mundo com páginas chamadas <code rend="inline">/home</code> ou <code rend="inline">/faq</code>. Mas não há confusão porque o <ref target="https://pt.wikipedia.org/wiki/Nome_de_dom%C3%ADnio">domínio</ref> (a primeira parte do <ref target="https://pt.wikipedia.org/wiki/URL">Localizador Uniforme de Recursos</ref> (<emph>Uniform Resource Locator</emph> ou URL) - ex. <code rend="inline">bbc.co.uk</code>) é único, portanto, todas as páginas que fazem parte desse domínio são únicas em outras páginas <code rend="inline">/faq</code> de outros websites. No endereço <code rend="inline">http://www.bbc.co.uk/faqs</code> é a parte <code rend="inline">bbc.co.uk</code> que torna as páginas subsequentes únicas. Isto é tão óbvio para as pessoas que utilizam a web a toda a hora que não pensam sobre isso. Provavelmente, também sabe que se quiser criar um website chamado <code rend="inline">bbc.co.uk</code> não conseguirá, porque esse nome já foi registado com a autoridade apropriada, que é o <ref target="https://pt.wikipedia.org/wiki/Sistema_de_Nomes_de_Dom%C3%ADnio">Sistema de Nomes de Domínio</ref> (<emph>Domain Name System</emph>). O registo garante a singularidade. Os URIs também têm de ser únicos.</p>
                <p>Embora os exemplos acima se pareçam com URLs, também é possível construir um URI que não se pareça nada com um URL. Temos muitas formas de identificar pessoas e coisas de forma única e raramente pensamos ou nos preocupamos com isso. Os códigos de barras, números de passaporte, até mesmo os códigos postais são concebidos para serem únicos. Os números de telefone são frequentemente colocados como placas de loja precisamente porque são únicos. Todos eles podem ser utilizados como URIs.</p>
                <p>Quando criamos URIs para as entidades descritas pelo projeto '<ref target="https://gtr.ukri.org/projects?ref=AH%2FN003446%2F1#/tabOverview">Tobias</ref>' (em inglês), escolhemos uma estrutura do tipo URL e escolhemos utilizar o nosso espaço web institucional, pondo de lado <code rend="inline">data.history.ac.uk/tobias-project/</code> como um lugar dedicado à hospedagem destes URIs. Ao colocá-lo em <code rend="inline">data.history.ac.uk</code> em vez de <code rend="inline">history.ac.uk</code>, houve uma separação clara entre URIs e as páginas do website. Por exemplo, um dos URIs do projeto Tobias era 'http://data.history.ac.uk/tobias-project/person/15601'. Embora o formato dos URIs acima mencionados seja o mesmo que um URL, eles não se ligam a websites (tente colá-lo num navegador web). Muitas pessoas novas no LOD acham isto confuso. Todos os URLs são URIs, mas nem todos os URIs são URLs. (nota de tradução: tendo em conta que o site original do projeto Tobias já não se encontra disponível, o leitor da lição deve entender os exemplos aqui indicados como meramente ilustrativos daquilo que o autor pretende demonstrar) Um URI pode descrever qualquer coisa, enquanto o URL descreve a localização de algo na web. Assim, um URL diz-lhe a localização de uma página web, de um ficheiro ou algo semelhante. Um URI faz apenas o trabalho de identificar algo. Tal como o Número internacional Normalizado do Livro (International Standard Book Number ou <ref target="https://www.iso.org/standard/36563.html">ISBN</ref> (em inglês) <code rend="inline">978-0-1-873354-6</code> identifica exclusivamente uma edição de capa dura de <emph>Baptism, Brotherhood and Belief in Reformation Germany</emph>, de Kat Hill, mas não diz onde obter uma cópia. Para isso precisaria de algo como um <ref target="https://pt.wikipedia.org/wiki/N%C3%BAmero_de_acesso_(biblioteconomia)">número de acesso</ref>, que lhe dá uma localização exata de um livro numa prateleira de uma biblioteca específica.</p>
                <p>Há um pouco de jargão em torno de URIs. As pessoas falam sobre se são ou não <ref target="https://pt.wikipedia.org/wiki/Refer%C3%AAncia_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)">desreferenciáveis</ref>. Isso apenas significa que <emph>podemos transformar uma referência abstrata em algo diferente?</emph> Por exemplo, se colarmos um URI na barra de endereços de um browser, será que ele encontra algo? O VIAF URI para o historiador Simon Schama é:</p>
                <ab>
                    <code xml:id="code_introducao-dados-abertos-conectados_8" corresp="code_introducao-dados-abertos-conectados_8.txt" rend="block"/>
                </ab>
                <p>Se o colocarmos no browser, receberemos de volta uma página web sobre Simon Schama que contém dados estruturados sobre ele e a sua história editorial. Isto é muito útil por um motivo. A partir do URI não é óbvio quem ou mesmo o que é que está a ser referido. Da mesma forma, se tratarmos um número de telefone (com código internacional) como o URI de uma pessoa, então deve ser desreferenciável. Alguém pode atender o telefone e pode até ser Schama.</p>
                <p>Mas isto não é essencial. Muitos URIs não são desreferenciáveis, como no exemplo acima do projeto Tobias. Não se pode encontrá-lo em lado nenhum; é uma convenção.</p>
                <p>O exemplo do VIAF leva-nos a outra coisa importante sobre os URIs: não os invente a não ser que tenha de o fazer. As pessoas e organizações têm feito esforços para construir boas listas de URI e o LOD não vai funcionar eficazmente se as pessoas duplicarem esse trabalho criando novos URIs desnecessariamente. Por exemplo, o VIAF tem o apoio de muitas bibliotecas internacionais. Se quiser construir URIs para pessoas, o VIAF é uma escolha muito boa. Se não conseguir encontrar algumas pessoas no VIAF, ou noutras listas de autoridade, só então poderá precisar fazer a sua própria.</p>
            </div>
            <table>
                <row>
                    <cell role="label">IDaluno</cell>
                    <cell role="label">IDprofessor</cell>
                </row>
                <row>
                    <cell>72</cell>
                    <cell>40</cell>
                </row>
                <row>
                    <cell>56</cell>
                    <cell>28</cell>
                </row>
                <row>
                    <cell>49</cell>
                    <cell>28</cell>
                </row>
                <row>
                    <cell>35</cell>
                    <cell>17</cell>
                </row>
                <row>
                    <cell>31</cell>
                    <cell>17</cell>
                </row>
            </table>
            <div type="2">
                <head>RDF e formatos de dados</head>
                <p>LOD utiliza uma norma, definida pelo <ref target="https://www.w3.org/">Consórcio World Wide Web</ref> (em inglês) (<emph>World Wide Web Consortium</emph> ou W3C), chamada <emph>
                        <ref target="https://pt.wikipedia.org/wiki/Resource_Description_Framework">Resource Description Framework</ref>
                    </emph> ou apenas RDF. As normas são úteis desde que sejam amplamente adotadas - pense no metro ou nos tamanhos de parafuso padrão - mesmo que sejam essencialmente arbitrárias. O RDF tem sido amplamente adotado como a norma LOD.</p>
                <p>Ouvirá frequentemente o LOD referido simplesmente como RDF. Atrasamos a conversa sobre o RDF até agora porque é bastante abstrato. RDF é um <ref target="https://pt.wikipedia.org/wiki/Modelagem_de_dados">modelo de dados</ref> que descreve como é que os dados são estruturados num nível teórico. Assim, a insistência na utilização de triplas semânticas (em vez de quatro partes, ou duas ou nove, por exemplo) é uma regra no RDF. Mas quando se trata de questões mais práticas, há algumas escolhas quanto à implementação. Assim, o RDF diz-lhe o que tem de fazer, mas não exatamente como o tem de fazer. Estas escolhas dividem-se em duas áreas: como se escrevem as coisas (serialização) e as relações que as suas triplas semânticas descrevem.</p>
                <div type="3">
                    <head>Serialização</head>
                    <p>A <ref target="https://pt.wikipedia.org/wiki/Serializa%C3%A7%C3%A3o">Serialização</ref> é o termo técnico para "como se escrevem as coisas". O chinês padrão (mandarim) pode ser escrito em caracteres tradicionais, caracteres simplificados ou romanização Pinyin e a língua em si não muda. Tal como o mandarim, o RDF pode ser escrito de várias formas. Aqui vamos olhar para duas (há outras, mas por uma questão de simplicidade, vamos concentrar-nos nestas):</p>
                    <list type="ordered">
                        <item>
                            <ref target="https://en.wikipedia.org/wiki/Turtle_(syntax)">Turtle</ref> (em inglês)</item>
                        <item>
                            <ref target="https://pt.wikipedia.org/wiki/RDF/XML">RDF/XML</ref>
                        </item>
                    </list>
                    <p>Reconhecer a serialização que está a ser utilizada significa que podemos então escolher ferramentas apropriadas concebidas para esse formato. Por exemplo, o RDF pode vir serializado no formato <ref target="https://pt.wikipedia.org/wiki/XML">XML</ref>. Podemos então utilizar uma ferramenta ou biblioteca de códigos concebida para analisar esse formato em particular, o que é útil se já souber como trabalhar com ele. O reconhecimento do formato também lhe dá as palavras-chave certas para procurar ajuda online. Muitos recursos permitem descarregar as suas bases de dados LOD, podendo escolher qual a serialização que deseja fazer o <emph>Download</emph>.</p>
                    <div type="4">
                        <head>Turtle</head>
                        <p>'Turtle' é um jogo de palavras. 'Tur' é a abreviatura de 'terse' e 'tle' - é a abreviatura de '<emph>triple language</emph>' (linguagem de triplos). Turtle é uma forma agradavelmente simples de escrever triplas semânticas.</p>
                        <p>O Turtle usa apelidos ou atalhos, conhecidos como <ref target="https://www.w3.org/TeamSubmission/turtle/#sec-tutorial">prefixos</ref> (em inglês), o que nos poupa ter de escrever URIs completos todas as vezes. Voltemos ao URI que criamos na secção anterior:</p>
                        <ab>
                            <code xml:id="code_introducao-dados-abertos-conectados_12" corresp="code_introducao-dados-abertos-conectados_12.txt" rend="block"/>
                        </ab>
                        <p>Não queremos escrever isto cada vez que nos referimos a esta pessoa (lembrar-se-á de Jack Straw). Por isso, só temos de enunciar o nosso atalho:</p>
                        <ab>
                            <code xml:id="code_introducao-dados-abertos-conectados_13" corresp="code_introducao-dados-abertos-conectados_13.txt" rend="block"/>
                        </ab>
                        <p>Então Jack é <code rend="inline">toby:15601</code>, que substitui o longo URI e é mais fácil à vista. Eu escolhi 'toby', mas poderia igualmente escolher qualquer sequência de letras.</p>
                        <p>Vamos agora passar de Jack Straw para William Shakespeare e utilizar Turtle para descrever algumas coisas sobre as suas obras. Vamos ter de decidir sobre os ficheiros de autoridade a utilizar, um processo que, como mencionado acima, é melhor ser selecionado ao olhar para outros conjuntos de LOD. Aqui usaremos como um dos nossos prefixos <ref target="https://pt.wikipedia.org/wiki/Dublin_Core">
                                <emph>Dublin Core</emph>
                            </ref>, uma norma de <ref target="https://pt.wikipedia.org/wiki/Metadados">metadados</ref> de bibliotecas <ref target="https://en.wikipedia.org/wiki/Library_of_Congress_Control_Number">(Número de controle da Biblioteca do Congresso</ref> (<emph>Library of Congress Control Number</emph>) como outro e, o último (VIAF) deverá ser-lhe familiar. Juntos, estes três ficheiros de autoridade fornecem identificadores únicos para todas as entidades que tenciono utilizar neste exemplo:</p>
                        <ab>
                            <code xml:id="code_introducao-dados-abertos-conectados_14" corresp="code_introducao-dados-abertos-conectados_14.txt" rend="block"/>
                        </ab>
                        <p>Note o espaçamento do ponto final após a última linha. Esta é a forma de Turtle indicar o fim. Tecnicamente não é necessário ter o espaço, mas facilita a leitura após uma longa sequência de caracteres.</p>
                        <p>No exemplo acima, lccn:n82011242 representa Macbeth; dc:creator liga Macbeth ao seu autor; viaf:96994048 representa William Shakespeare.</p>
                        <p>O Turtle também permite listar triplas semânticas sem se preocupar em repetir cada URI quando acabou de o usar. Acrescentemos a data em que os estudiosos pensam que Macbeth foi escrito, utilizando o par atributo-valor Dublin Core: <code rend="inline">dc:create 'YYYY'</code>:</p>
                        <ab>
                            <code xml:id="code_introducao-dados-abertos-conectados_15" corresp="code_introducao-dados-abertos-conectados_15.txt" rend="block"/>
                        </ab>
                        <p>Lembra-se da estrutura da tripla semântica discutida na secção 1? Aí demos este exemplo:</p>
                        <ab>
                            <code xml:id="code_introducao-dados-abertos-conectados_16" corresp="code_introducao-dados-abertos-conectados_16.txt" rend="block"/>
                        </ab>
                        <p>O essencial é que o predicado liga o sujeito e o objeto. Ele descreve a relação entre eles. O sujeito vem primeiro na tripla semântica, mas isso é uma questão de escolha, como discutimos com o exemplo de pessoas que foram ensinadas a tocar piano por Liszt.</p>
                        <p>Pode-se usar um ponto e vírgula se o sujeito for o mesmo mas o predicado e o objeto forem diferentes, ou uma vírgula se o sujeito e o predicado forem o mesmo e apenas o objeto for diferente.</p>
                        <ab>
                            <code xml:id="code_introducao-dados-abertos-conectados_17" corresp="code_introducao-dados-abertos-conectados_17.txt" rend="block"/>
                        </ab>
                        <p>Aqui estamos a dizer que Shakespeare (96994048) e John Fletcher (12323361) foram ambos os criadores da obra <emph>The Two Noble Kinsmen</emph>.</p>
                        <p>Quando analisamos as ontologias anteriormente sugeri que visse a <ref target="http://web.archive.org/web/20170718143925/http://musicontology.com/docs/getting-started.html">
                                <emph>Music Ontology</emph>
                            </ref> (em inglês). Dê agora uma olhada novamente. Isto ainda é complicado, mas será que agora fazem mais sentido?</p>
                        <p>Uma das ontologias mais acessíveis é a '<emph>Friend of a Friend</emph>' (amigo de um amigo) ou <ref target="https://en.wikipedia.org/wiki/FOAF_(ontology)">FOAF</ref> (em inglês). Esta é concebida para descrever pessoas e, talvez por essa razão, é bastante intuitiva. Se, por exemplo, quiser escrever-me para me dizer que este curso é a melhor coisa que já leu, aqui está o meu email expresso como triplas semânticas em FOAF:</p>
                        <ab>
                            <code xml:id="code_introducao-dados-abertos-conectados_18" corresp="code_introducao-dados-abertos-conectados_18.txt" rend="block"/>
                        </ab>
                    </div>
                    <div type="4">
                        <head>RDF/XML</head>
                        <p>Em contraste com o Turtle, o RDF/XML pode parecer um pouco pesado. Para começar, vamos apenas converter uma tripla semântica da Turtle acima, aquela que refere que Shakespeare foi o criador de <emph>The Two Noble Kinsmen</emph>:</p>
                        <ab>
                            <code xml:id="code_introducao-dados-abertos-conectados_19" corresp="code_introducao-dados-abertos-conectados_19.txt" rend="block"/>
                        </ab>
                        <p>Em RDF/XML, com os prefixos declarados dentro do trecho de código de XML, fica:</p>
                        <ab>
                            <code xml:id="code_introducao-dados-abertos-conectados_20" corresp="code_introducao-dados-abertos-conectados_20.txt" lang="language-xml" rend="block"/>
                        </ab>
                        <p>O formato RDF/XML tem a mesma informação básica que o formato Turtle, mas é escrito de forma muito diferente, baseando-se nos princípios das etiquetas XML encaixadas.</p>
                        <p>Passemos a um exemplo diferente para mostrar como o RDF/XML combina triplas semânticas e, ao mesmo tempo, introduz o <ref target="https://pt.wikipedia.org/wiki/Simple_Knowledge_Organization_System">
                                <emph>Simple Knowledge Organization System</emph>
                            </ref> (SKOS) (Sistema Simples de Organização do Conhecimento), que foi concebido para codificar tesauros ou taxonomias.</p>
                        <ab>
                            <code xml:id="code_introducao-dados-abertos-conectados_21" corresp="code_introducao-dados-abertos-conectados_21.txt" rend="block"/>
                        </ab>
                        <p>Aqui estamos a dizer que o conceito SKOS <code rend="inline">21250</code>, <emph>markdown abdication</emph>, tem um rótulo preferido de "<emph>abdication</emph>". A forma como funciona é que o elemento sujeito (incluindo a parte da '<emph>abdication</emph>', que é um valor de atributo em termos de XML) tem o predicado e o objeto encaixados no seu interior. O elemento encaixado é o predicado e <ref target="https://pt.wikipedia.org/wiki/%C3%81rvore_(estrutura_de_dados)#Terminologia">o nó folha</ref> (em inglês), é o objeto. Este exemplo é retirado de um projeto para publicar um <ref target="https://www.history.ac.uk/research/digital-history">
                                <emph>Tesauro de História Britânica e Irlandesa</emph>
                            </ref> (em inglês).</p>
                        <p>Tal como com o Turtle, podemos acrescentar mais triplas semânticas. Portanto, vamos declarar que o termo mais restrito na nossa hierarquia de sujeitos, um abaixo de <emph>Abdication</emph>, vai ser <emph>Abdication crisis (1936)</emph>.</p>
                        <ab>
                            <code xml:id="code_introducao-dados-abertos-conectados_22" corresp="code_introducao-dados-abertos-conectados_22.txt" rend="block"/>
                        </ab>
                        <p>Lembra-se de como os predicados e os objetos são encaixados dentro do sujeito? Aqui já o fizemos duas vezes com o mesmo sujeito, para que possamos tornar isto menos prolixo, aninhando ambos os conjuntos de predicados como objetos dentro do mesmo sujeito:</p>
                        <ab>
                            <code xml:id="code_introducao-dados-abertos-conectados_23" corresp="code_introducao-dados-abertos-conectados_23.txt" rend="block"/>
                        </ab>
                        <p>Se estiver familiarizado com XML isto será fácil. Se não estiver, talvez prefira um formato como o Turtle. Mas a vantagem aqui é que ao criar o seu RDF/XML pode usar as ferramentas habituais disponíveis com XML, como editores e analisadores dedicados ao XML, para verificar se o seu RDF/XML está corretamente formatado. Se não for uma pessoa que use o XML recomendo o Turtle, podendo usar uma <ref target="http://www.easyrdf.org/converter">ferramenta online</ref> (em inglês) para verificar se a sua sintaxe está correta.</p>
                    </div>
                </div>
            </div>
            <div type="2">
                <head>Consulta de RDF com SPARQL</head>
                <p>Para esta secção final iremos interrogar algum LOD e ver o que poderá ser feito com ele.</p>
                <p>A linguagem de consulta que usamos para LOD é chamada <ref target="https://pt.wikipedia.org/wiki/SPARQL">SPARQL</ref>. É um daqueles acrónimos recursivos amados pelos técnicos: <emph>
                        <hi rend="bold">S</hi>PARQL <hi rend="bold">P</hi>rotocol <hi rend="bold">a</hi>nd <hi rend="bold">R</hi>DF <hi rend="bold">Q</hi>uery <hi rend="bold">L</hi>anguage</emph> (Protocolo SPARQL e Linguagem de Consulta).</p>
                <p>Como mencionado no início, o <emph>Programming Historian</emph> tem <ref target="/en/lessons/retired/graph-databases-and-SPARQL">uma lição completa</ref> (em inglês), de Matthew Lincoln, sobre a utilização do SPARQL (embora não seja já mantida (ver nota no início desta tradução). A secção final aqui presente é apenas uma visão geral dos conceitos básicos. Se o SPARQL despertar o seu interesse, pode obter uma fundamentação completa no tutorial de Lincoln.</p>
                <p>Vamos realizar as nossas consultas SPARQL na <ref target="https://www.dbpedia.org/">DBpedia</ref>, que é um enorme conjunto de LOD derivado da Wikipedia. Além de estar cheio de informação que é muito difícil de encontrar através da habitual interface da Wikipédia, tem vários "pontos de extremidade" (end points) SPARQL - interfaces onde se podem digitar as consultas SPARQL e obter resultados a partir das triplas semânticas da DBpedia.</p>
                <p>O end point de consulta SPARQL que é utilizado chama-se <ref target="http://dbpedia.org/snorql/">snorql</ref> (em inglês). Estes end points ocasionalmente ficam offline. Se for o seu caso, tente procurar por <emph>dbpedia sparql</emph> e deverá encontrar um substituto semelhante.</p>
                <p>Se for ao URL snorql acima verá, no início, um número de prefixos que já nos foram declarados, o que é útil. Agora também irá reconhecer alguns dos prefixos.</p>
                <figure>
                    <desc>Caixa de consulta padrão do snorql, com alguns prefixos declarados para si</desc>
                    <graphic url="intro-to-linked-data-fig1.png"/>
                </figure>
                <p>Na caixa de consulta abaixo das declarações de prefixo, deverá ver o seguinte:</p>
                <ab>
                    <code xml:id="code_introducao-dados-abertos-conectados_24" corresp="code_introducao-dados-abertos-conectados_24.txt" rend="block"/>
                </ab>
                <p>Se alguma vez escreveu uma consulta de bases de dados em <emph>Structured Query Language</emph>, <ref target="https://pt.wikipedia.org/wiki/SQL">mais conhecida como SQL</ref>, isto vai parecer-lhe bastante familiar e vai ajudá-lo a aprender SPARQL. Se não, não se preocupe. As palavras-chave aqui utilizadas, <code rend="inline">SELECT</code> (SELECIONAR) e <code rend="inline">WHERE</code> (ONDE) não são sensíveis a maiúsculas e minúsculas, mas algumas partes de uma consulta SPARQL podem ser (ver abaixo), por isso recomendo que se cinja ao caso dado ao longo das consultas neste curso.</p>
                <p>Aqui <code rend="inline">SELECT</code> significa "encontrar alguma coisa" e <code rend="inline">*</code> significa "dá-me tudo". <code rend="inline">WHERE</code> introduz uma condição, que é onde vamos colocar os detalhes de que tipo de coisas queremos que a consulta encontre.</p>
                <p>Vamos começar com algo simples para ver como é que isto funciona. Cole (ou, melhor, escreva) isto na caixa de consulta:</p>
                <ab>
                    <code xml:id="code_introducao-dados-abertos-conectados_25" corresp="code_introducao-dados-abertos-conectados_25.txt" rend="block"/>
                </ab>
                <p>Clique em '<emph>go</emph>' (ir). Se deixar o menu <emph>drop-down</emph> como '<emph>browse</emph>' (navegar) deverá obter duas colunas com os rótulos "b" e "c". (Note que aqui, ao procurar uma cadeia de caracteres, as maiúsculas/minúsculas importam: lyndal_roper não lhe dará resultados).</p>
                <figure>
                    <desc>Topo das listas de resultados de uma consulta com todas as triplas semânticas com 'Lyndal_Roper' como sujeito</desc>
                    <graphic url="intro-to-linked-data-fig2.png"/>
                </figure>
                <p>Então o que é que acabou de acontecer? E como é que soubemos o que escrever?</p>
                <p>Na verdade, não sabíamos. Esse é um dos problemas com end points do SPARQL. Quando se conhece um dataset, é preciso experimentar coisas e descobrir que termos são utilizados. Porque isto vem da <emph>Wikipedia</emph> e nós estávamos interessados sobre que informação sobre historiadores podíamos encontrar. Então vamos à página da <emph>Wikipedia</emph> da historiadora <ref target="https://en.wikipedia.org/wiki/Lyndal_Roper">Lyndal Roper</ref> (em inglês).</p>
                <p>A parte final do URL é <code rend="inline">Lyndal_Roper</code> e concluímos então que é provável que esta cadeia de caracteres seja a forma como Roper é referida na DBpedia. Porque não sabemos o que mais poderia estar em triplas semânticas que mencionam Roper, nós utilizamos <code rend="inline">?a</code> e <code rend="inline">?b</code>: estes são apenas marcadores de posição. Poderia igualmente ter digitado <code rend="inline">?whatever</code> e <code rend="inline">?you_like</code> e as colunas teriam esses rótulos. Quando quiser ser mais preciso sobre o que se está a pesquisar, será importante etiquetar as colunas de forma significativa.</p>
                <p>Experimente agora a sua própria consulta SPARQL: escolha uma página <emph>Wikipedia</emph> e copie a parte final do URL, após a barra final, e coloque-a no lugar de Lyndal_Roper. Depois clique em 'go'.</p>
                <p>A partir da informação que se obtém destes resultados é possível gerar <emph>queries</emph> mais precisas. Isto pode ser pouco fiável, por isso não se preocupe se algumas não funcionarem.</p>
                <p>Vamos voltar aos resultados para a consulta que fizemos há momentos:</p>
                <ab>
                    <code xml:id="code_introducao-dados-abertos-conectados_26" corresp="code_introducao-dados-abertos-conectados_26.txt" rend="block"/>
                </ab>
                <p>Podemos ver uma longa lista na coluna etiquetada <emph>c</emph>. Estes são todos os atributos que Roper tem na <emph>DBpedia</emph> e que nos ajudarão a encontrar outras pessoas com estes atributos. Por exemplo, podemos ver <code rend="inline">http://dbpedia.org/class/yago/Historian110177150</code>. Poderemos utilizar isto para obter uma lista de historiadores? Vamos colocá-lo na nossa pergunta, mas em terceiro lugar, porque era onde estava quando a encontrei nos resultados da Lyndal Roper. A minha consulta tem este aspecto:</p>
                <ab>
                    <code xml:id="code_introducao-dados-abertos-conectados_27" corresp="code_introducao-dados-abertos-conectados_27.txt" rend="block"/>
                </ab>
                <p>Fizemos uma pequena mudança aqui. Se esta consulta funcionar de todo, então esperemos que os nossos historiadores estejam na primeira coluna, porque 'historiador' não parece poder ser um predicado: não funciona como um verbo numa frase; por isso vamos chamar à nossa primeira coluna de resultados 'historian_name' e à minha segunda (sobre a qual não sabemos nada) 'predicate' (predicado).</p>
                <p>Execute a <emph>querie</emph>. Deverá encontrar uma grande lista de historiadores.</p>
                <figure>
                    <desc>Historiadores de acordo com a DBpedia</desc>
                    <graphic url="intro-to-linked-data-fig3.png"/>
                </figure>
                <p>Assim, esta ferramenta funciona para criar listas, o que é útil, mas seria muito mais poderoso combinar listas para obter intersecções de conjuntos. Encontrei mais algumas coisas que podem ser interessantes consultar nos atributos DBpedia de Lyndal Roper: <ref target="http://dbpedia.org/class/yago/WikicatBritishHistorians">http://dbpedia.org/class/yago/WikicatBritishHistorians</ref> e <ref target="http://dbpedia.org/class/yago/WikicatWomenHistorians">http://dbpedia.org/class/yago/WikicatWomenHistorians</ref>. É muito fácil combiná-los pedindo uma variável a ser devolvida (no nosso caso isto é <code rend="inline">?name</code> (nome)) e depois utilizando-a em múltiplas linhas de uma <emph>querie</emph>. Note também o espaço e o ponto completo no final da primeira linha que começa com <code rend="inline">?name</code>:</p>
                <ab>
                    <code xml:id="code_introducao-dados-abertos-conectados_28" corresp="code_introducao-dados-abertos-conectados_28.txt" rend="block"/>
                </ab>
                <p>Funciona! Devemos obter cinco resultados. Na altura em que escrevo, há cinco historiadoras britânicas na <emph>DBpedia</emph>...</p>
                <figure>
                    <desc>Historiadoras britânicas segundo a DBpedia</desc>
                    <graphic url="intro-to-linked-data-fig4.png"/>
                </figure>
                <p>Apenas cinco historiadoras britânicas? Claro que há, na realidade, muitas mais do que isso, como poderíamos facilmente mostrá-lo substituindo o nome de, digamos, Alison Weir na nossa primeira consulta sobre Lyndal Roper. Isto leva-nos ao problema com a <emph>Dbpedia</emph> que mencionamos anteriormente: não é muito consistentemente marcado com informação estrutural do tipo que a <emph>DBpedia</emph> que utiliza. A nossa consulta pode listar algumas historiadoras britânicas mas acontece que não podemos utilizá-la para gerar uma lista significativa de pessoas nesta categoria. Tudo o que encontrámos foram as pessoas nas entradas da <emph>Wikipedia</emph> que alguém decidiu classificar como "historiadora britânica" e "historiadora".</p>
                <p>Com SPARQL na <emph>DBpedia</emph>, é preciso ter cuidado com as inconsistências do material de origem coletiva. Poderá usar o SPARQL exatamente da mesma forma num dataset mais confiável, por exemplo, os dados do governo britânico: <ref target="https://data-gov.tw.rpi.edu//sparql">https://data-gov.tw.rpi.edu//sparql</ref> (em inglês) e esperar obter resultados mais robustos (há aqui um breve tutorial para este dataset: <ref target="https://data-gov.tw.rpi.edu/wiki/A_crash_course_in_SPARQL">https://data-gov.tw.rpi.edu/wiki/A_crash_course_in_SPARQL</ref> (em inglês).</p>
                <p>No entanto, apesar das suas inconsistências, a <emph>DBpedia</emph> é um ótimo local para aprender SPARQL. Esta foi apenas uma breve introdução, mas há muito mais em <ref target="/en/lessons/retired/graph-databases-and-SPARQL">Usando SPARQL para aceder ao Linked Open Data</ref> (em inglês).</p>
            </div>
            <div type="2">
                <head>Leituras e recursos adicionais</head>
                <list type="unordered">
                    <item>Dean Allemang e James Hendler, <emph>Semantic Web for the Working Ontologist</emph>, 2nd edn, Elsevier, 2011</item>
                    <item>Tim Berners-Lee <ref target="https://www.w3.org/DesignIssues/LinkedData.html">
                            <emph>Linked Data</emph>
                        </ref> (em inglês)</item>
                    <item>Bob DuCharme, <emph>Learning SPARQL</emph>, O'Reilly, 2011</item>
                    <item>
                        <ref target="http://www.snee.com/bobdc.blog/">Blog de Bob DuCharme</ref> (em inglês) também vale a pena ler</item>
                    <item>Richard Gartner, <emph>Metadata: Shaping Knowledge from Antiquity to the Semantic Web</emph>, Springer, 2016</item>
                    <item>Seth van Hooland and Ruben Verborgh, <emph>Linked Data for Libraries, Archives and Museums</emph>, 2015</item>
                    <item>Ver também <ref target="http://freeyourmetadata.org/">
                            <emph>companion website</emph>
                        </ref> (em inglês)</item>
                    <item>Matthew Lincoln <ref target="/en/lessons/retired/graph-databases-and-SPARQL">'<emph>Using SPARQL to access Linked Open Data</emph>'</ref> (em inglês)</item>
                    <item>
                        <ref target="http://linkeddata.org/guides-and-tutorials">
                            <emph>Linked Data guides and tutorials</emph>
                        </ref> (em inglês)</item>
                    <item>Dominic Oldman, Martin Doerr e Stefan Gradmann, '<emph>Zen and the Art of Linked Data: New Strategies for a Semantic Web of Humanist Knowledge</emph>', em <emph>A New Companion to Digital Humanities</emph>, editado por Susan Schreibman et al.</item>
                    <item>Max Schmachtenberg, Christian Bizer e Heiko Paulheim, <ref target="http://linkeddatacatalog.dws.informatik.uni-mannheim.de/state/">
                            <emph>State of the LOD Cloud 2017</emph>
                        </ref> (em inglês)</item>
                    <item>David Wood, Marsha Zaidman e Luke Ruth, <emph>Linked Data: Structured data on the Web</emph>, Manning, 2014</item>
                </list>
            </div>
            <div type="2">
                <head>Agradecimentos</head>
                <p>Gostaria de agradecer aos meus dois colegas revisores, Matthew Lincoln e Terhi Nurmikko-Fuller e ao meu editor, Adam Crymble, por me ajudarem generosamente a melhorar esta lição com numerosas sugestões, esclarecimentos e correções. Este tutorial baseia-se num outro escrito como parte do '<emph>Thesaurus of British and Irish History as SKOS</emph>' <ref target="https://gtr.ukri.org/projects?ref=AH%2FN003446%2F1#/tabOverview">
                        <emph>(Tobias) project</emph>
                    </ref> (em inglês), financiado pelo <ref target="http://www.ahrc.ac.uk/">AHRC</ref> (em inglês). A lição foi revista para o projeto <emph>Programming Historian</emph>.</p>
            </div>
        </body>
    </text>
</TEI>
