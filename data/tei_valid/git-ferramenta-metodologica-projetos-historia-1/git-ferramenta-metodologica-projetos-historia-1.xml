<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:id="git-ferramenta-metodologica-projetos-historia-1">
    <teiHeader>
        <fileDesc>
            <titleStmt>
                <title>Git como ferramenta metodológica em projetos de História (parte 1)</title>
                <author role="original_author">Eric Brasil</author>
                <editor role="reviewers">
                    <persName>Felipe Lamarca</persName>
                    <persName>Ian Vaz Araujo</persName>
                </editor>
                <editor role="editors">Jimmy Medeiros</editor>
            </titleStmt>
            <publicationStmt>
                <distributor>Programming Historian</distributor>
                <idno type="doi">10.46430/phpt0045</idno>
                <date type="published">10/14/2023</date>
            </publicationStmt>
            <sourceDesc>
                <p>Born digital, in a markdown format. This lesson is original.</p>
            </sourceDesc>
        </fileDesc>
        <profileDesc>
            <abstract>
                <p>A lição procura caracterizar sistemas de controlo de versões, tendo o Git como exemplo, e analisar as possibilidades do seu uso para a pesquisa em História. Para tanto, pretende-se apresentar detalhadamente as principais funções e recursos do Git para o controlo de versões localmente, desde a configuração inicial do programa até à sua aplicação em um exemplo prático.</p>
            </abstract>
            <textClass>
                <keywords>
                    <term xml:lang="en">data-management</term>
                </keywords>
            </textClass>
        </profileDesc>
    </teiHeader>
    <text xml:lang="pt">
        <body>
            <div type="2">
                <head>Objetivos de aprendizagem</head>
                <p>No final deste tutorial os participantes deverão estar aptos a:</p>
                <list type="unordered">
                    <item>Compreender os sistemas de controlo de versões e as suas implicações metodológicas para a pesquisa</item>
                    <item>Aplicar as funcionalidades básicas do fluxo de trabalho do Git a ficheiros variados</item>
                    <item>Desenvolver metodologia consistente de registo e documentação das etapas da pesquisa através do Git</item>
                </list>
            </div>
            <div type="2">
                <head>Pré-requisitos</head>
                <p>Computador ligado à internet. Terminal (Linux e Mac) ou Git Bash (Windows).</p>
            </div>
            <div type="2">
                <head>O Sistema de Controlo de Versões (SCV) como ferramenta metodológica</head>
                <p>Quem nunca passou por isto?</p>
                <figure>
                    <desc>Figura 1. Cham, Jorge. ['PHD Comics: notFinal.doc'](https://perma.cc/4JUK-J9UL). Acessado a 26 de setembro de 2022.</desc>
                    <graphic url="or-pt-git-ferramenta-metodologica-projetos-historia-1-01.png"/>
                </figure>
                <p>No nosso processo de escrita, é bastante comum alterarmos ficheiros constantemente. Inclusões, exclusões e revisões acompanham o nosso trabalho académico, não apenas ao escrevermos um manuscrito, mas também durante a elaboração e execução de projetos de pesquisa: incluímos fontes digitalizadas, imagens, criamos documentos com ideias e fragmentos de análises, geramos dados tabulares e bancos de dados, etc.</p>
                <p>Todos estes procedimentos são modificados ao longo do tempo a partir de escolhas e decisões construídas no decorrer da pesquisa. É fundamental que estas alterações sejam registadas, organizadas e preservadas para o futuro: seja para a sua própria pesquisa e processo de escrita, seja para a avaliação de pares ou para desdobramentos em novas pesquisas.</p>
                <p>Portanto, é importante termos algum método explícito para controlar as diferentes versões de nosso trabalho. E, de certa forma, cada um de nós tende a desenvolver caminhos para manter esses registos. Contudo, estes métodos costumam ser pouco formalizados e sem uma documentação precisa que possibilite que outros pesquisadores possam compreender o processo de desenvolvimento da pesquisa<ref type="footnotemark" target="#note_ram"/>. Existem várias formas de realizar um controlo e registo eficiente dos caminhos de uma pesquisa. Na lição <ref target="/pt/licoes/preservar-os-seus-dados-de-investigacao">Preservar os seus dados de investigação</ref>, James Baker apresenta maneiras de documentar e estruturar dados de pesquisa que também servirão de inspiração aqui.</p>
                <div type="3">
                    <head>O que é um sistema de controlo de versões?</head>
                    <p>Ao invés de criarmos um método do zero, proponho a utilização de uma categoria de programas criados especificamente para o registo de alterações em ficheiros: os Sistemas de Controlo de Versão (SCV). Um SCV consiste em um sistema que regista as mudanças de um ficheiro ou conjunto de ficheiros ao longo do tempo. Cada uma destas mudanças é acompanhada de um conjunto de metadados (ou seja, informações sobre os dados), e permite recuperar tanto esses dados quanto o estado em que se encontrava o seu projeto há época.</p>
                    <p>É como se possuísse uma máquina do tempo capaz de o levar de volta a qualquer ponto da história de mudanças da sua pesquisa.</p>
                    <p>O uso de SCV é mais comum entre desenvolvedores de código e programas de computador. Entretanto, as suas características o tornam em uma importante ferramenta para as Ciências Humanas e Sociais: ao utilizar um SCV é capaz de acompanhar, documentar, recuperar e corrigir as etapas do projeto de pesquisa. Também é possível acompanhar trabalhos de alunos ou equipes que compõem um projeto<ref type="footnotemark" target="#note_guerrero"/>.</p>
                    <div type="4">
                        <head>Centralizado X Distribuído</head>
                        <p>Os primeiros SCV possuíam um modelo centralizado. Ou seja, o repositório principal era hospedado em um único servidor que armazenava todos os ficheiros versionados. Quem trabalhava no projeto enviava e recuperava todas as informações diretamente no servidor central. Este sistema possui algumas vantagens, como a capacidade dos administradores controlarem e filtrarem os acessos e atribuições de cada membro da equipe, conseguindo ainda saber quais são eles<ref type="footnotemark" target="#note_chacon"/> (tradução minha). </p>
                        <p>Porém, as desvantagens principais consistem, justamente, no seu caráter centralizado: caso o servidor tenha algum problema, todos os dados podem ser perdidos, visto que toda a história do projeto está preservada em um único local.</p>
                        <figure>
                            <desc>Figura 2. Controlo de versão centralizado. A partir de ['Chacon e Straub, Pro Git, 2014'](https://perma.cc/6TX9-HLX6). Acessado a 10 de janeiro de 2023.</desc>
                            <graphic url="or-pt-git-ferramenta-metodologica-projetos-historia-1-02.png"/>
                        </figure>
                        <p>Os SCV distribuídos têm outra abordagem. Nas palavras de Chacon e Straub, "cada clone [de um repositório de SCV distribuído] é realmente um <emph>backup</emph> completo de todos os dados"<ref type="footnotemark" target="#note_chacon"/>.</p>
                        <figure>
                            <desc>Figura 3. Controlo de versão distribuído. A partir de ['Chacon e Straub, Pro Git, 2014'](https://perma.cc/6TX9-HLX6). Acessado a 10 de janeiro de 2023.</desc>
                            <graphic url="or-pt-git-ferramenta-metodologica-projetos-historia-1-03.png"/>
                        </figure>
                    </div>
                </div>
                <div type="3">
                    <head>O que é o Git?</head>
                    <p>O Git é um SCV de arquitetura distribuída. Foi criado em 2005, por Linus Torvalds<ref type="footnotemark" target="#note_torvald"/>, e é, atualmente, <ref target="https://perma.cc/P74X-UH6M">o mais popular do mundo</ref> (em inglês). É um software livre e gratuito, com uma grande comunidade de usuários, que oferece documentação extensa e detalhada. O Git "gerencia a evolução de um conjunto de ficheiros - chamado repositório ou repo - de uma forma consciente e altamente estruturada"<ref type="footnotemark" target="#note_bryan"/> (tradução minha). Todas as mudanças são registadas (em inglês, <emph>commited</emph>), assim como um conjunto de metadados para cada <emph>commit</emph> (em português, submissões): identificação única, autoria, mensagem, e data. Estes mecanismos e informações permitem a compreensão geral da história do desenvolvimento de um projeto<ref type="footnotemark" target="#note_kim"/>.</p>
                    <p>O Git compreende os seus dados como "uma série de <emph>snapshots</emph> de um sistema de ficheiros em miniatura", ou seja, sempre que submete uma alteração ao repositório, o "Git basicamente tira uma fotografia de como todos os seus ficheiros são naquele momento e armazena uma referência para aquele <emph>snapshot</emph>" (Chacon e Straub, 2014, p. 15). Se um ficheiro não foi modificado, o Git não o armazenará novamente, apenas cria um link atualizado para ele, o que o torna mais leve e rápido. Estas características garantem a integridade do Git, visto que é impossível alterar o conteúdo de qualquer ficheiro ou diretório sem o Git saber<ref type="footnotemark" target="#note_chacon"/>. Praticamente todas estas operações acontecem localmente, minimizando problemas relativos à conexão com servidores, violação de dados e segurança.</p>
                    <p>O Git também favorece o trabalho em equipe, pois cada membro de um projeto, ao mesmo tempo que tem acesso a todo o histórico de mudanças, também pode empreender alterações específicas em seu repositório local e, posteriormente, submetê-lo a repositórios remotos, hospedados em servidores ou plataformas on-line como o GitHub.<ref type="footnotemark" target="#note_github"/>
                    </p>
                    <p>Apesar destas vantagens, é importante refletir sobre as limitações do Git. A primeira questão é a elevada curva de aprendizagem, em comparação com outros programas. Apesar de possuir uma série de IDEs e programas que trazem interfaces gráficas para sua utilização, o Git é um programa de linha de comandos e compreender os seus principais recursos e aplicá-los de forma correta e eficiente requer a dedicação de horas de estudo e prática.</p>
                    <p>O Git também apresenta dificuldades em lidar com ficheiros compactados (como ficheiros em formato pdf, docx, ipynb, etc.), pois não é capaz de diferenciar as mudanças internas desses documentos. Ou seja, o Git será capaz de perceber que o ficheiro foi alterado, mas não poderá listar as diferenças, como faria em ficheiros de texto simples, como txt, tex, md, csv, json, etc. Esta característica é coerente com os objetivos dos seus desenvolvedores: o Git foi criado, principalmente, para lidar com ficheiros com códigos de programação e estes são, comumente, leves e de texto simples. Ainda assim, o Git apresenta mais vantagens para acompanhar as mudanças em ficheiros em formatos gerados pelo <emph>Microsoft Word</emph> do que a utilização do recurso de rastrear mudanças (em inglês, <emph>track changes</emph>), do próprio <emph>Microsoft Word</emph>: neste último, enquanto os registos das alterações desaparecem após serem resolvidos pelo usuário, no Git permanecerão integralmente, registados em outros ficheiros no histórico, podendo ser recuperados e reestabelecidos a qualquer momento.</p>
                    <p>Também é necessário atentar no armazenamento de ficheiros muito grandes e que mudam constantemente. Estes podem gerar históricos muito pesados e, nesse caso, é recomendada a exclusão desses ficheiros do histórico, mantendo apenas o registo de mudanças nos metadados<ref type="footnotemark" target="#note_ram"/>. É possível informar o Git quais diretórios, ficheiros ou tipos de extensão de ficheiros devem ser ignorados do registo no histórico. Isto é feito através da criação de um ficheiro de texto simples nomeado <code rend="inline">.gitignore</code>, que deve ser salvo na pasta raiz do repositório local. Nele podemos inserir uma lista de padrões de nomes de ficheiros que o Git deve ignorar, ou seja, não rastrear. Isto é útil para evitar a inclusão de ficheiros muito pesados no seu histórico, ou ainda de ficheiros de texto que não correspondem à pesquisa ou ficheiros que não têm licença para serem publicados. Veremos com mais detalhe esse recurso na parte dois da lição. Para saber mais, veja a <ref target="https://perma.cc/4FF9-7KU6">documentação do Git</ref> (em inglês).</p>
                </div>
                <div type="3">
                    <head>Usando o Git</head>
                    <p>Se ainda está aqui, acredito que esteja interessado em ver a aplicação prática do Git, mesmo após esta longa introdução. Vamos utilizar o Git e refletir sobre as possibilidades para o seu uso em pesquisas e projetos de história.</p>
                    <div type="4">
                        <head>Fluxo de trabalho</head>
                        <p>Podemos resumir o fluxo de trabalho básico do Git da seguinte forma, a partir de Chacon e Straub (2014):</p>
                        <list type="ordered">
                            <item>Modifica algum ficheiro no seu diretório de trabalho (em inglês, <emph>working tree</emph>)</item>
                            <item>Seleciona as mudanças que pretende submeter/registar no histórico do Git (ou <emph>repositório local</emph>)</item>
                            <item>Envia as mudanças para a área de preparação (em inglês, <emph>staging area</emph>)</item>
                            <item>Realiza a submissão (em inglês, <emph>commit</emph>), incluindo uma mensagem explicativa associada às mudanças realizadas</item>
                            <item>O Git, então, pega nos ficheiros exatamente como estão na área de preparação (em inglês, <emph>staging area</emph>) e armazena esse <emph>snapshot</emph> permanentemente no seu repositório local do Git, juntamente com o conjunto de metadados associado ao <emph>commit</emph>
                            </item>
                        </list>
                        <figure>
                            <desc>Figura 4. Estrutura básica do fluxo de trabalho no Git. Criado pelo autor no [Canva](https://www.canva.com/).</desc>
                            <graphic url="or-pt-git-ferramenta-metodologica-projetos-historia-1-04.png"/>
                        </figure>
                        <p>Com isto, é possível recuperar e analisar todos os passos realizados desde a criação do repositório local até ao presente.</p>
                    </div>
                    <div type="4">
                        <head>Instalação</head>
                        <div type="5">
                            <head>Windows</head>
                            <p>Para instalar o Git no Windows, acesse este <ref target="https://git-scm.com/download/win">link</ref> (em inglês) e faça o download da versão mais recente do ficheiro executável correspondente à arquitetura do seu computador (provavelmente 64-bits). Após a conclusão do download, clique com o botão direito do mouse no ficheiro executável e selecione a opção "Executar como Administrador".</p>
                            <p>É preciso aceitar os termos de uso e definir a pasta de instalação. Em seguida, é possível definir os componentes que serão instalados e se serão adicionados ícones no menu iniciar. </p>
                            <figure>
                                <desc>Figura 5. Instalação no Windows: componentes a serem instalados.</desc>
                                <graphic url="or-pt-git-ferramenta-metodologica-projetos-historia-1-05.png"/>
                            </figure>
                            <p>Na sequência, o Git pergunta qual será o seu editor de texto padrão (manterei o <emph>Vim</emph>,<ref type="footnotemark" target="#note_vim"/> mas pode escolher o de sua preferência).</p>
                            <figure>
                                <desc>Figura 6. Instalação no Windows: selecione o editor de texto.</desc>
                                <graphic url="or-pt-git-ferramenta-metodologica-projetos-historia-1-06.png"/>
                            </figure>
                            <p>A próxima opção é sobre o padrão de nomeação dos <emph>branches</emph> (em português, ramos) em novos repositórios.<ref type="footnotemark" target="#note_branches"/> Escolheremos a opção <emph>Override the default branch name for new repositories</emph> (em português, substituir o nome do ramo padrão para novos repositórios) e definiremos o nome do <emph>branch</emph> (em português, ramo) principal como <emph>main</emph> (em português, principal).<ref type="footnotemark" target="#note_main"/>
                            </p>
                            <figure>
                                <desc>Figura 7. Instalação no Windows: nome do branch principal.</desc>
                                <graphic url="or-pt-git-ferramenta-metodologica-projetos-historia-1-07.png"/>
                            </figure>
                            <p>Por fim, é importante definir que o Git será incluído no PATH do sistema, para que possa ser executado a partir de qualquer diretório. Para isso vamos escolher a segunda opção, <emph>Git from the command line and also from 3rd-party software</emph> (em português, git da linha de comandos e, também, de software terceiro).</p>
                            <figure>
                                <desc>Figura 8. Instalação no Windows: incluir no PATH.</desc>
                                <graphic url="or-pt-git-ferramenta-metodologica-projetos-historia-1-08.png"/>
                            </figure>
                            <p>Nas opções seguintes, manteremos as definições padrão, e clicaremos "Next" (em português, seguinte) até aparecer na tela a opção "Install" (em português, instalar).</p>
                        </div>
                        <div type="5">
                            <head>Linux/MacOS</head>
                            <p>A instalação do Git em sistemas Linux e MacOs é muito simples, mas ao mesmo tempo oferece menos opções de configuração e é feita diretamente pelo terminal,<ref type="footnotemark" target="#note_terminal"/> sem o auxílio de uma interface gráfica.</p>
                            <p>Muitas distribuições Linux já têm o Git instalado. Ainda assim, é muito fácil instalá-lo a partir do seu gerenciador de pacotes. Por exemplo, em distribuições baseadas no Ubuntu, a última versão estável pode ser instalada executando o seguinte comando no terminal:</p>
                            <ab>
                                <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_0" corresp="code_git-ferramenta-metodologica-projetos-historia-1_0.txt" lang="language-bash" rend="block"/>
                            </ab>
                            <p>Para uma lista completa de comandos para variadas distribuições Linux, <ref target="https://git-scm.com/download/linux">clique aqui</ref> (em inglês).</p>
                            <p>Assim como no Linux, a instalação do Git no MacOs pode ser realizada de maneira simples com o seu gerenciador de pacotes. Para instalar utilizando o <ref target="https://brew.sh/">homebrew</ref> (em inglês), basta executar o seguinte comando no terminal:</p>
                            <ab>
                                <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_1" corresp="code_git-ferramenta-metodologica-projetos-historia-1_1.txt" lang="language-bash" rend="block"/>
                            </ab>
                            <p>Para instalar utilizando o <ref target="https://www.macports.org/">MacPorts</ref> (em inglês), o comando é o seguinte:</p>
                            <ab>
                                <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_2" corresp="code_git-ferramenta-metodologica-projetos-historia-1_2.txt" lang="language-bash" rend="block"/>
                            </ab>
                            <p>Para informações gerais e mais opções de instalação no MacOs, <ref target="https://git-scm.com/download/mac">clique aqui</ref> (em inglês).</p>
                            <p>Após concluída a instalação, podemos perguntar ao nosso sistema qual a versão do Git que temos instalada. Para Linux e MacOs, abra o Terminal e, para Windows, abra o Git Bash. Em seguida, digite o seguinte comando:</p>
                            <ab>
                                <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_3" corresp="code_git-ferramenta-metodologica-projetos-historia-1_3.txt" lang="language-bash" rend="block"/>
                            </ab>
                            <p>No meu computador, aparece a seguinte informação:</p>
                            <ab>
                                <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_4" corresp="code_git-ferramenta-metodologica-projetos-historia-1_4.txt" lang="language-bash" rend="block"/>
                            </ab>
                            <p>Todas as ações desta lição serão realizadas a partir de comandos diretamente no terminal de um sistema operacional Linux, pois o objetivo é apresentar o Git a partir da sua base, sem a necessidade de outros programas. Isto é importante para que a lógica do programa, o seu fluxo de trabalho e possibilidades de uso sejam compreendidas de forma completa.</p>
                            <p>Então, abra o seu terminal, no Linux ou no MacOs, ou o Git Bash no Windows, e vamos começar!</p>
                        </div>
                    </div>
                    <div type="4">
                        <head>Configuração global</head>
                        <p>É importante configurar o Git com os dados de autoria e email. Com essas informações, o Git é capaz de registar quem realizou as alterações em dado momento. Neste tutorial, aprenderemos como definir essas informações globalmente para o computador utilizado. O Git possui um ficheiro de configuração intitulado <code rend="inline">.gitconfig</code>. Este armazena uma série de informações importantes, como a autoria, o email, os padrões de nomeação, e o editor de texto a ser utilizado.<ref type="footnotemark" target="#note_gitedit"/> Para definir o nome do autor e o email, é necessário executar os seguintes comandos:</p>
                        <list type="unordered">
                            <item>Autor</item>
                        </list>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_5" corresp="code_git-ferramenta-metodologica-projetos-historia-1_5.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <list type="unordered">
                            <item>Email</item>
                        </list>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_6" corresp="code_git-ferramenta-metodologica-projetos-historia-1_6.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>Em <code rend="inline">user.name</code> e <code rend="inline">user.email</code> use os seus dados pessoais, em vez do historiador inglês, obviamente!</p>
                        <p>Estes comandos solicitam que o Git acesse o ficheiro de configuração global (<code rend="inline">git config</code>). Em seguida, passamos à opção <code rend="inline">--global</code>, definindo que as configurações valem para todos os que utilizarem esse computador; por fim, indicamos o parâmetro que queremos alterar, neste caso, o nome e o email do autor: <code rend="inline">user.name</code> e <code rend="inline">user.email</code>.</p>
                        <list type="unordered">
                            <item>Configurar o editor de texto</item>
                        </list>
                        <p>O Git permite definir o editor a ser utilizado para a escrita das mensagens de <emph>commit</emph>. Normalmente, o Git utilizará o editor padrão do seu sistema operacional. No meu exemplo, definirei o <emph>Vim</emph> como editor padrão.</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_7" corresp="code_git-ferramenta-metodologica-projetos-historia-1_7.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>Também é possível definir o nome do <emph>branch</emph> principal para novos repositórios. Aqui, seguindo o padrão adotado com maior frequência atualmente, vamos defini-lo como <emph>main</emph>.</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_8" corresp="code_git-ferramenta-metodologica-projetos-historia-1_8.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>Lembrando que, no Windows, o processo de instalação do Git já nos permitiu configurar o editor de texto e o nome do <emph>branch</emph> principal. Caso queira alterar essas configurações, basta executar os comandos acima no Git Bash.</p>
                        <p>Pode listar todas as configurações globais do seu computador com o comando <code rend="inline">git config --global --list</code>.</p>
                        <p>Uma saída parecida com esta deve ser exibida em sua tela:</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_9" corresp="code_git-ferramenta-metodologica-projetos-historia-1_9.txt" lang="language-bash" rend="block"/>
                        </ab>
                    </div>
                    <div type="4">
                        <head>Iniciar um repositório local Git</head>
                        <p>Nesta lição, vamos criar um diretório vazio em nossa máquina chamado <code rend="inline">projeto-de-pesquisa</code>. É nele que irá testar os comandos do Git e acompanhar o seu fluxo de trabalho. Para isso, deve abrir o seu Terminal, no Linux e MacOS, ou Git Bash no Windows, e criar o diretório no caminho que escolher. Por exemplo, se pretende criar o diretório <code rend="inline">projeto-de-pesquisa</code> no interior do diretório <code rend="inline">Documentos</code>, deve utilizar o comando <code rend="inline">cd</code> (em inglês, <emph>change directory</emph>; em português, mudar diretório) e especificar esse caminho. Sobre os comandos básicos que serão utilizados aqui, como <code rend="inline">cd</code>, <code rend="inline">mkdir</code>, etc., veja a <ref target="/en/lessons/intro-to-bash">lição do Programming Historian sobre Bash</ref> (em inglês).</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_10" corresp="code_git-ferramenta-metodologica-projetos-historia-1_10.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>Em seguida, pode executar o comando para criar um diretório: <code rend="inline">mkdir</code> (em inglês, <emph>make directory</emph>; em português, criar diretório).</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_11" corresp="code_git-ferramenta-metodologica-projetos-historia-1_11.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>Lembrando que é possível criar o diretório normalmente através do seu explorador de ficheiros.</p>
                        <p>Agora, pode entrar no diretório recém-criado e verificar se está vazio, utilizando o comando <code rend="inline">ls</code> (em inglês, <emph>list</emph>; em português, lista).</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_12" corresp="code_git-ferramenta-metodologica-projetos-historia-1_12.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>Não deve aparecer nada na sua tela, pois o diretório ainda está vazio.</p>
                        <p>Para iniciar este diretório como um repositório local Git, deve executar o comando para inicialização: <code rend="inline">git init</code>.</p>
                        <p style="alert alert-warning">
Lembrando que todos os comandos devem ser executados no interior do diretório `projeto-de-pesquisa`.
</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_13" corresp="code_git-ferramenta-metodologica-projetos-historia-1_13.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>A partir de agora, o seu diretório <code rend="inline">projeto-de-pesquisa</code> será um repositório submetido ao controlo de versões do Git. Para o verificar, pode executar o comando <code rend="inline">ls -a</code> (em inglês, <emph>list all</emph>; em português, lista total), que lista todos os ficheiros e diretórios, inclusive os ocultos.</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_14" corresp="code_git-ferramenta-metodologica-projetos-historia-1_14.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>O resultado deve ser o seguinte:</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_15" corresp="code_git-ferramenta-metodologica-projetos-historia-1_15.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>O comando <code rend="inline">git init</code> solicitou ao Git que o diretório <code rend="inline">projeto-de-pesquisa</code> recebesse uma série de ficheiros e diretórios específicos para o registo e controlo de alterações. Esses ficheiros são ocultos, alocados no interior do diretório <code rend="inline">.git</code> e têm a função de garantir que todas as modificações ocorridas no interior do diretório de trabalho sejam percebidas, registadas, e apresentadas. O Git reúne uma série de recursos para que possa não apenas registar esse histórico de alterações, mas também analisá-lo, recuperá-lo, e trabalhar de forma mais coesa e segura.</p>
                        <p>A estrutura de diretórios criada pelo Git é complexa e não será abordada a fundo nesta lição. Se listarmos os ficheiros presentes na recém-criada pasta <code rend="inline">.git</code>, com o comando <code rend="inline">ls -a .git</code>, obteremos o seguinte resultado:</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_16" corresp="code_git-ferramenta-metodologica-projetos-historia-1_16.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>Neste conjunto de diretórios e ficheiros, o Git armazena as informações sobre o repositório: desde as alterações realizadas até aos dados de configuração e fluxo de trabalho.</p>
                    </div>
                    <div type="4">
                        <head>Comandos básicos</head>
                        <p>Após iniciar o seu repositório com o comando <code rend="inline">git init</code>, podemos criar um novo ficheiro e iniciar o registo das alterações. Assim, poderemos compreender com mais clareza o funcionamento do programa.</p>
                        <p>Vamos criar um ficheiro <ref target="/pt/licoes/introducao-ao-markdown">markdown</ref> chamado <code rend="inline">README.md</code>, com o conteúdo <code rend="inline"># Exemplo para a lição</code>, no interior de nosso diretório de trabalho (em inglês, <emph>working directory</emph>) <code rend="inline">projeto-de-pesquisa</code>. Pode fazer isto de várias formas - com editores de texto, por exemplo. Aqui utilizarei o terminal e o comando <code rend="inline">echo</code>.<ref type="footnotemark" target="#note_echo"/> Pode fazer o mesmo no Git Bash.</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_17" corresp="code_git-ferramenta-metodologica-projetos-historia-1_17.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>Solicitei que o programa <code rend="inline">echo</code> incluísse a frase <emph># Exemplo para a lição</emph> no ficheiro <code rend="inline">README.md</code>. Como o ficheiro ainda não existia, foi criado. Se executar o comando <code rend="inline">ls</code>, verá que o ficheiro foi criado com sucesso.</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_18" corresp="code_git-ferramenta-metodologica-projetos-historia-1_18.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <div type="5">
                            <head>
                                <emph>Git status</emph>
                            </head>
                            <p>Portanto, realizámos uma alteração em nosso repositório. Vamos verificar se o Git percebeu a mudança? Para isso, executamos o comando <code rend="inline">git status</code>.</p>
                            <ab>
                                <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_19" corresp="code_git-ferramenta-metodologica-projetos-historia-1_19.txt" lang="language-bash" rend="block"/>
                            </ab>
                            <p>A mensagem retornada pelo Git é a seguinte:</p>
                            <ab>
                                <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_20" corresp="code_git-ferramenta-metodologica-projetos-historia-1_20.txt" lang="language-bash" rend="block"/>
                            </ab>
                            <p>Vamos entender o que o Git está nos dizendo. Ao passarmos o comando <code rend="inline">status</code> para o Git, somos informados da situação atual do repositório. Neste momento, o Git informa que estamos no ramo (em inglês, <emph>branch</emph>) <code rend="inline">main</code>: <code rend="inline">No ramo main</code>. Em seguida, informa que ainda não existem submissões (em inglês, <emph>commits</emph>): <code rend="inline">No commits yet</code>.<ref type="footnotemark" target="#note_traducao"/> Mais abaixo veremos o que são <emph>commits</emph> e sua importância metodológica para as nossas pesquisas.</p>
                            <p>Em seguida temos a mensagem: </p>
                            <ab>
                                <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_21" corresp="code_git-ferramenta-metodologica-projetos-historia-1_21.txt" lang="language-bash" rend="block"/>
                            </ab>
                            <p>O Git informa que existe um ficheiro chamado <code rend="inline">README.md</code> dentro do nosso diretório de trabalho que ainda não está a ser monitorado pelo sistema de controlo de versões. Ou seja, o ficheiro ainda precisa de ser adicionado ao repositório Git para que as alterações nele efetuadas sejam registadas.</p>
                        </div>
                        <div type="5">
                            <head>
                                <emph>Git add</emph>
                            </head>
                            <p>O próprio Git informa qual o comando que devemos utilizar para registar o ficheiro: <code rend="inline">git add &lt;arquivo&gt;</code>. No nosso caso, devemos executar o seguinte:</p>
                            <ab>
                                <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_22" corresp="code_git-ferramenta-metodologica-projetos-historia-1_22.txt" lang="language-bash" rend="block"/>
                            </ab>
                            <p>Agora, ao solicitarmos o status do repositório, receberemos uma mensagem diferente:</p>
                            <ab>
                                <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_23" corresp="code_git-ferramenta-metodologica-projetos-historia-1_23.txt" lang="language-bash" rend="block"/>
                            </ab>
                            <p>Mais uma vez, percebemos que estamos no ramo <code rend="inline">main</code> e ainda não realizámos nenhuma submissão (em inglês, <emph>commit</emph>) neste ramo. Entretanto, não existem mais ficheiros no estado <emph>não monitorados</emph> (em inglês, <emph>untracked files</emph>). O nosso ficheiro <code rend="inline">README.md</code> mudou de status: agora está como um novo ficheiro (em inglês, <emph>new file</emph>) no estado <code rend="inline">Mudanças a serem submetidas</code> (em inglês, <emph>Changes to be commited</emph>).</p>
                        </div>
                        <div type="5">
                            <head>
                                <emph>Git commit</emph>
                            </head>
                            <quote>
                                <p>Commits servem como pontos de verificação, onde ficheiros individuais ou um projeto inteiro podem ser revertidos com segurança quando necessário<ref type="footnotemark" target="#note_ram"/> (tradução minha).</p>
                            </quote>
                            <p>Agora, as alterações que realizámos estão preparadas para serem submetidas (em inglês, <emph>commited</emph>) no repositório. Para isso, usámos o comando <code rend="inline">git commit</code>. É importante destacar a necessidade de incluir uma mensagem para cada <emph>commit</emph>. São essas mensagens que servirão de base para a documentação de cada etapa do seu projeto de pesquisa. Ou seja, todas as alterações realizadas e selecionadas para serem registadas na linha do tempo gerenciada pelo Git deverão receber uma mensagem explicativa sobre tais alterações. Este procedimento permite tanto a criação de um histórico detalhado das mudanças e decisões, suas razões e sentidos, como fomenta uma metodologia organizada e controlada, visto que cada passo tomado deve receber uma reflexão por parte do pesquisador.</p>
                            <p>Existem duas formas de incluir uma mensagem no <emph>commit</emph>. A primeira é mais simples e realizada diretamente com o comando <code rend="inline">commit</code>:</p>
                            <ab>
                                <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_24" corresp="code_git-ferramenta-metodologica-projetos-historia-1_24.txt" lang="language-bash" rend="block"/>
                            </ab>
                            <p>Neste caso, adicionámos a opção <code rend="inline">-m</code> (de mensagem) ao comando <code rend="inline">commit</code> e, em seguida, escrevemos o conteúdo da mensagem entre aspas duplas (<code rend="inline">"</code>). Essa opção é mais prática, mas possui limitações: a impossibilidade de criar mensagens mais detalhadas, com mais de 50 caracteres e com quebras de linha.</p>
                            <p>Se desejarmos uma mensagem mais elaborada - o que para os objetivos desta lição é mais coerente -, utilizamos o comando <code rend="inline">git commit</code>, sem a inclusão da opção <code rend="inline">-m</code>. Neste caso, o Git abrirá o editor de texto definido nas configurações para que possamos escrever a mensagem. </p>
                            <p>Como já havíamos realizado o <emph>commit</emph> das alterações antes e não realizámos nenhuma nova mudança, se executarmos o comando <code rend="inline">git commit</code>, o Git informa que não há nada a ser submetido:</p>
                            <ab>
                                <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_25" corresp="code_git-ferramenta-metodologica-projetos-historia-1_25.txt" lang="language-bash" rend="block"/>
                            </ab>
                            <p>Mas, se ainda assim quisermos corrigir a mensagem do último <emph>commit</emph>, podemos utilizar a opção <code rend="inline">--amend</code>:</p>
                            <ab>
                                <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_26" corresp="code_git-ferramenta-metodologica-projetos-historia-1_26.txt" lang="language-bash" rend="block"/>
                            </ab>
                            <p>O Git abrirá o editor de texto para que possamos <hi rend="bold">editar a mensagem do último</hi>
                                <emph>commit</emph>. Após a edição, basta salvar e fechar o editor. No meu caso, o editor é o <code rend="inline">vim</code>. Para sair do editor, basta digitar <code rend="inline">ESC + :wq</code> e pressionar a tecla <code rend="inline">Enter</code>.<ref type="footnotemark" target="#note_vim"/> É importante destacar que, ao configurar a mensagem de <emph>commit</emph> com o editor de texto, é possível definir o título e o corpo da mensagem. </p>
                            <p>O Git considera a primeira linha da mensagem como título, o qual deve ter no máximo 50 caracteres. A restante mensagem é considerada o corpo e deve ser separada do título por uma linha vazia, como no exemplo abaixo:</p>
                            <ab>
                                <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_27" corresp="code_git-ferramenta-metodologica-projetos-historia-1_27.txt" lang="language-bash" rend="block"/>
                            </ab>
                            <p>Após salvar e fechar o editor, o Git informa que o <emph>commit</emph> foi realizado com sucesso:</p>
                            <ab>
                                <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_28" corresp="code_git-ferramenta-metodologica-projetos-historia-1_28.txt" lang="language-bash" rend="block"/>
                            </ab>
                            <p>Pronto! Criámos o nosso ficheiro <code rend="inline">README.md</code> e adicionámos ao repositório Git com sucesso. Para isso, utilizámos o comando <code rend="inline">git add</code> para adicionar o ficheiro ao <emph>index</emph> do Git <ref type="footnotemark" target="#note_git-index"/>, e o comando <code rend="inline">git commit</code> para submeter as alterações ao repositório. Vimos também como incluir a mensagem de <emph>commit</emph> diretamente na linha de comandos (<code rend="inline">git commit -m "mensagem"</code>) e como editar a mensagem do último <emph>commit</emph> realizado (<code rend="inline">git commit --amend</code>).</p>
                            <p>Se executarmos <code rend="inline">git status</code> novamente, veremos que não há mais nada a ser submetido:</p>
                            <ab>
                                <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_29" corresp="code_git-ferramenta-metodologica-projetos-historia-1_29.txt" lang="language-bash" rend="block"/>
                            </ab>
                            <figure>
                                <desc>Figura 9. Função dos comandos `git add` e `git commit` no fluxo de trabalho no Git. Criado pelo autor no [Canva](https://www.canva.com/).</desc>
                                <graphic url="or-pt-git-ferramenta-metodologica-projetos-historia-1-09.png"/>
                            </figure>
                        </div>
                    </div>
                    <div type="4">
                        <head>Status de um ficheiro</head>
                        <p>Agora que já sabemos como adicionar um ficheiro ao repositório Git e como submeter alterações acompanhadas de mensagens, vamos detalhar e analisar os diferentes status de um ficheiro no Git. Para isso vamos criar um ficheiro novo chamado <code rend="inline">resumo.txt</code> e salvá-lo no diretório <code rend="inline">projeto-de-pesquisa</code>. Repetiremos o mesmo método utilizado para criar o ficheiro <code rend="inline">README.md</code>, com o comando <code rend="inline">echo</code> (veja o tópico <ref target="#comandos-basicos">Comandos Básicos</ref>). No entanto, pode criar este ficheiro utilizando qualquer outro método.</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_30" corresp="code_git-ferramenta-metodologica-projetos-historia-1_30.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>Se listarmos o conteúdo do diretório <code rend="inline">projeto-de-pesquisa</code> veremos que agora existem dois ficheiros:</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_31" corresp="code_git-ferramenta-metodologica-projetos-historia-1_31.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>Como vimos anteriormente, um ficheiro recém criado no nosso diretório de trabalho tem o status <hi rend="bold">não monitorado</hi> (em inglês, <emph>untracked</emph>) e precisa de ser <hi rend="bold">preparado</hi> (em inglês, <emph>staged</emph>) para ser <hi rend="bold">submetido</hi> (em inglês, <emph>commited</emph>). Podemos ver a sua situação com um <code rend="inline">git status</code>.</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_32" corresp="code_git-ferramenta-metodologica-projetos-historia-1_32.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>Ou seja, o ficheiro <code rend="inline">resumo.txt</code> tem o status <hi rend="bold">não monitorado</hi> (em inglês, <emph>untracked</emph>) e precisa de ser <hi rend="bold">preparado</hi> (em inglês, <emph>staged</emph>). Para preparar o ficheiro, utilizamos <code rend="inline">git add &lt;nome do arquivo&gt;</code>. Ou seja, solicitamos ao Git que inclua o ficheiro no seu <emph>index</emph>.</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_33" corresp="code_git-ferramenta-metodologica-projetos-historia-1_33.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>A partir do momento em que o ficheiro foi preparado (em inglês, <emph>staged</emph>) no Git, muda de status e está pronto para ser submetido (em inglês, <emph>commit</emph>), como podemos ver executando um <code rend="inline">git status</code>.</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_34" corresp="code_git-ferramenta-metodologica-projetos-historia-1_34.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>Ou seja, <code rend="inline">resumo.txt</code> é um novo ficheiro que está pronto para ser submetido ao Git através do commando <code rend="inline">git commit</code>. </p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_35" corresp="code_git-ferramenta-metodologica-projetos-historia-1_35.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>O editor de texto será aberto e poderá inserir, por exemplo, a mensagem "Criação do ficheiro para o resumo do tutorial". Após salvar e fechar o editor, o Git informa que o <emph>commit</emph> foi realizado com sucesso:</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_36" corresp="code_git-ferramenta-metodologica-projetos-historia-1_36.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>A mensagem retornada informa que um ficheiro foi alterado, e uma inserção realizada em seu conteúdo.</p>
                        <p>A partir de agora, o ficheiro <code rend="inline">resumo.txt</code>, assim como o <code rend="inline">README.md</code>, está inserido no repositório Git que realiza o controlo de versões, ou seja, regista e avalia todas as mudanças que são realizadas. </p>
                        <p>Vamos alterar o conteúdo dos dois ficheiros para entendermos este processo.</p>
                        <p>Primeiro, vamos inserir uma frase no ficheiro <code rend="inline">resumo.txt</code>. Para isso pode abri-lo em qualquer editor de texto, escrever a frase "Este tutorial procura apresentar as funções básicas do Git." e salvá-lo. Depois, abra o ficheiro <code rend="inline">README.md</code> e inclua a frase "Lição para o Programming Historian.", salvando em seguida. </p>
                        <p>Realizámos alterações em dois ficheiros do nosso diretório de trabalho, ambos registados e monitorados pelo Git. Vejamos as informações que o comando <emph>status</emph> apresenta agora:</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_37" corresp="code_git-ferramenta-metodologica-projetos-historia-1_37.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>A mensagem informa que dois ficheiros foram modificados e ainda não foram preparados para submissão (em inglês, <emph>changes not staged for commit</emph>). Para inserir estas mudanças e prepará-las para o <emph>commit</emph>, devemos utilizar o comando <code rend="inline">git add &lt;nome do arquivo&gt;</code>. É possível incluir mais de um ficheiro no mesmo comando, por exemplo:</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_38" corresp="code_git-ferramenta-metodologica-projetos-historia-1_38.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>Podemos ainda especificar que queremos que todos os ficheiros presentes no diretório de trabalho sejam preparados ao mesmo tempo, utilizando <code rend="inline">git add .</code>.</p>
                        <p>Agora que preparámos as mudanças para submissão, os ficheiros aparecem com o status <hi rend="bold">Mudanças a serem submetidas</hi> (em inglês, <emph>Changes to be commited</emph>):</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_39" corresp="code_git-ferramenta-metodologica-projetos-historia-1_39.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>Para submeter estas mudanças é preciso utilizar o comando <emph>commit</emph>. Podemos fazer um único <emph>commit</emph> para as mudanças em todos os ficheiros e escrever uma mensagem detalhada. Por exemplo:</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_40" corresp="code_git-ferramenta-metodologica-projetos-historia-1_40.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>O editor de texto padrão do sistema operacional será aberto e poderá escrever a seguinte mensagem:</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_41" corresp="code_git-ferramenta-metodologica-projetos-historia-1_41.txt" lang="language-vim" rend="block"/>
                        </ab>
                        <p>Após salvar e fechar o editor, o Git informa que o <emph>commit</emph> foi realizado com sucesso:</p>
                        <ab>
                            <code xml:id="code_git-ferramenta-metodologica-projetos-historia-1_42" corresp="code_git-ferramenta-metodologica-projetos-historia-1_42.txt" lang="language-bash" rend="block"/>
                        </ab>
                        <p>Resumindo: sempre que um novo ficheiro for criado, precisa de ser preparado (<code rend="inline">git add</code>) e submetido (<code rend="inline">git commit</code>). As submissões devem ser acompanhadas de uma mensagem explicativa sobre o que foi feito. Cada alteração realizada em qualquer ficheiro presente no diretório de trabalho que já esteja sendo monitorado pelo Git deve ser também preparada e submetida com uma mensagem clara e explicativa. É possível consultar a situação do diretório de trabalho com o <code rend="inline">git status</code>, o que nos possibilita perceber com clareza quais os ficheiros novos, quais foram modificados, e quais foram preparados ou não para submissão.</p>
                        <figure>
                            <desc>Figura 10. Status de um ficheiro no fluxo de trabalho no Git. Criado pelo autor no [Canva](https://www.canva.com/).</desc>
                            <graphic url="or-pt-git-ferramenta-metodologica-projetos-historia-1-10.png"/>
                        </figure>
                    </div>
                </div>
                <div type="3">
                    <head>Como escrever uma mensagem de <emph>commit</emph> eficiente?</head>
                    <p>Atualmente, uma parte significativa do nosso trabalho de pesquisa, escrita e ensino é mediada por ferramentas digitais, ao mesmo tempo que dados digitais se tornam cada vez mais centrais para as Ciências Sociais e Humanas. Sejam pesquisas on-line em repositórios, trocas de mensagens através de aplicativos, leitura de informações com editores de texto e de dados tabulares, seja a aplicação de linguagem de programação para análise textual, visualização de dados, entre tantas outras possibilidades. A seleção, coleta, organização e tratamento dos dados que pretendemos utilizar em pesquisas, artigos ou aulas exigem cuidados diferentes e adicionais daqueles para os quais fomos treinados na nossa formação anterior à virada digital. Nas palavras de Fridlunnd, Oiva e Paju:</p>
                    <quote>
                        <p>"Os métodos de pesquisa digital criam exigências novas e às vezes mais rigorosas de precisão, pensamento metodológico, auto-organização e colaboração do que a pesquisa histórica tradicional" (Fridlund; Oiva; Paju, 2020, pos. 543, tradução minha).</p>
                    </quote>
                    <p>Um caminho importante para colmatar estas exigências é a transparência metodológica. Nas palavras de Gibbs e Owens:</p>
                    <quote>
                        <p>"novos métodos usados para explorar e interpretar dados históricos exigem um novo nível de transparência metodológica na escrita histórica. Exemplos incluem discussões de consultas de dados, fluxos de trabalho com ferramentas específicas e a produção e interpretação de visualizações de dados. No mínimo, as publicações de pesquisa dos historiadores precisam de refletir novas prioridades que explicam o processo de interfacear, explorar e, em seguida, compreender as fontes históricas de uma forma fundamentalmente digital - ou seja, a hermenêutica dos dados"<ref type="footnotemark" target="#note_gibbs"/> (tradução minha).</p>
                    </quote>
                    <p>É fundamental criar um plano para organizar, documentar, preservar e compartilhar os dados, métodos e resultados da pequisa (ver a <ref target="/pt/licoes/preservar-os-seus-dados-de-investigacao">lição de James Baker</ref>). É necessário não apenas ficarmos atentos, mas também dedicar tempo no nosso cronograma de trabalho para uma reflexão em torno de:</p>
                    <list type="unordered">
                        <item>Metadados (como descrever os seus dados, tanto internamente quanto externamente)</item>
                        <item>Documentação (uma descrição narrativa do projeto)</item>
                        <item>Preservação (como os dados podem ser mantidos para uso no futuro)</item>
                    </list>
                    <p>Segundo Baker, é preciso produzir uma documentação "que capture de maneira precisa e consistente o conhecimento tácito em torno do processo de pesquisa", que esse processo seja simplificado em "formatos de ficheiro e práticas de notação independentes da plataforma e legíveis por máquina." Ao mesmo tempo é fundamental que isso seja inserido no fluxo de trabalho, para que não se torne uma tarefa exterior à pesquisa. Entendo que podemos enfrentar boa parte destes desafios utilizando programas de controlo de versões, como o Git. </p>
                    <p>Com o Git assumimos o controlo na produção de documentação precisa e consciente, produzida de forma integrada no desenvolvimento da pesquisa, gerando tanto metadados bem definidos quanto mensagens capazes de descrever a história do projeto.</p>
                    <p>Portanto, ao escrever uma mensagem de <emph>commit</emph> lembre-se que esta servirá como documentação do seu processo de pesquisa/escrita. Cada alteração ou conjunto de alterações realizada(s) nos ficheiros de seu diretório deve(m) ser acompanhada(s) de uma mensagem que registe as mudanças efetuadas. Essas informações são registadas pelo Git com um conjunto de metadados importantes para o acompanhamento metodológico de seu trabalho: nome do autor da mudança, data e hora, mensagem, e uma identificação única - um <emph>hash</emph> de 40 caracteres - que permite verificar a versão do ficheiro.</p>
                    <p>Como visto anteriormente, a melhor forma de escrever a mensagem de <emph>commit</emph> é utilizar o <code rend="inline">git commit</code> sem a opção <code rend="inline">-m</code>, pois permite escrever mensagens mais longas do que 50 caracteres (limite da opção <code rend="inline">-m</code>) e incluir quebras de linha e um título na nossa mensagem. O <code rend="inline">git commit</code> abre o editor de texto padrão do seu sistema operacional - ou o editor que configurou no Git - para que possa escrever a mensagem de <emph>commit</emph>.</p>
                    <div type="4">
                        <head>Commits atómicos e boas práticas</head>
                        <p>Nesta lição, como estamos a entender os <emph>commits</emph> e os seus metadados como parte central no processo de documentação e transparência metodológica na pesquisa, devemos adotar medidas concientes de boas práticas. É importante que seja definido com clareza que padrão de mensagens será adotado e qual a frenquência dos <emph>commits</emph>. Assim, a sua pesquisa terá um conjunto coerente e estável de metadados e documentação padronizada, facilanto a sua recuperação, visualização, e possíveis correções necessárias.</p>
                        <p>Pode optar por padronizar as suas mensagens de <emph>commit</emph> contendo sempre um título e uma linha explicativa, padronizar se a mensagem será escrita em tópicos, se vai explicar os motivos das alterações ou apenas listá-los, etc. </p>
                        <p>Uma prática interessante que pode ajudar a definir o nosso método de trabalho são os <emph>commits atómicos</emph>. Estes consistem em um <emph>commit</emph> para cada mudança, a menor mudança possível, acompanhado de uma mensagem de apenas uma linha. Segundo Samuel-Zacharie Faure, esta prática favorece: a solução de problemas e a correção de erros inesperados com mais precisão, permitindo a reversão de <emph>commits</emph> no ponto exato; que o seu histórico do Git seja mais limpo e conciso; e que o seu fluxo de trabalho fique mais eficiente, pois permite trabalhar de forma atomizada, avançando passo-a-passo<ref type="footnotemark" target="#note_faure"/>.</p>
                        <p>Adotando ou não a prática de <emph>commits atómicos</emph>, o mais relevante é ter clareza e consciência de qual método e padrões de <emph>commit</emph> serão adotados em toda a pesquisa. Pessoalmente, sugiro que cada alteração ou, pelo menos, cada conjunto de alterações em um mesmo ficheiro seja submetida separadamente, com uma mensagem concisa, que evidencia à primeira leitura as mudanças efetuadas.</p>
                        <p>Manter um histórico do Git padronizado, seja ele atomizado ou mais prolixo, é muito importante tanto para a recuperação de informações (e sua visualização e compreensão) quanto para o trabalho colaborativo, revisões, e desdobramentos futuros da pesquisa.</p>
                    </div>
                </div>
                <div type="3">
                    <head>Recuperar informações</head>
                    <p>Agora que aprendemos a criar um repositório local controlado pelo Git, a preparar e a submeter alterações em seu histórico, e a registar mensagens de documentação em cada uma das alterações, precisamos de aprender a recuperar esses dados.</p>
                    <p>Este processo é tão importante quanto o registo das mudanças. O Git permite visualizar todas as mudanças realizadas, com todos os dados associados a elas, e também possibilita retornar a um determinado ponto no passado dessa linha do tempo.</p>
                    <p>Isto é muito importante em, pelo menos, dois aspectos:</p>
                    <list type="ordered">
                        <item>É possível, com rapidez e transparência, ter acesso às informações do processo da pesquisa. Podemos visualizar toda a linha do tempo de mudanças, ler cada mensagem de <emph>commit</emph>, e saber quem realizou cada mudança e quando</item>
                        <item>Podemos reverter mudanças e recuperar o projeto num ponto específico da sua história. Por exemplo, caso algum ficheiro tenha sido eliminado por engano ou alguma correção tenha sido perdida, é possível solicitar ao Git para retornar o seu repositório para um <emph>snapshot</emph> anterior específico</item>
                    </list>
                    <table>
                        <row>
                            <cell role="label">
                                <emph>hash</emph> abreviada do <emph>commit</emph>
                            </cell>
                            <cell role="label">nome do autor</cell>
                            <cell role="label">data do <emph>commit</emph>
                            </cell>
                            <cell role="label">título do <emph>commit</emph>
                            </cell>
                            <cell role="label">conteúdo da mensagem do <emph>commit</emph>
                            </cell>
                        </row>
                        <row>
                            <cell>d3fc906</cell>
                            <cell>Edward Palmer Thompson</cell>
                            <cell>Thu Jan 26 11:49:25 2023 +0000</cell>
                            <cell>'Criação de README.md'</cell>
                            <cell>'Este commit cria o ficheiro README.md com o objetivo de explicar o funcionamento do Git.</cell>
                        </row>
                        <row>
                            <cell>29ffe51</cell>
                            <cell>Edward Palmer Thompson</cell>
                            <cell>Thu Jan 26 11:52:50 2023 +0000</cell>
                            <cell>'Criação do ficheiro para o resumo do tutorial'</cell>
                            <cell/>
                        </row>
                        <row>
                            <cell>5904720</cell>
                            <cell>Edward Palmer Thompson</cell>
                            <cell>Thu Jan 26 11:55:21 2023 +0000</cell>
                            <cell>'Atualização dos dados da lição'</cell>
                            <cell>'- Inclusão do nome do <emph>Programming Historian</emph> no README.md - Atualização do texto em resumos.txt</cell>
                        </row>
                    </table>
                    <table>
                        <row>
                            <cell role="label">Formato</cell>
                            <cell role="label">Descrição</cell>
                        </row>
                        <row>
                            <cell>%b</cell>
                            <cell>corpo</cell>
                        </row>
                        <row>
                            <cell>%f</cell>
                            <cell>linha do assunto higienizado, adequado para um nome de ficheiro</cell>
                        </row>
                        <row>
                            <cell>%s</cell>
                            <cell>assunto</cell>
                        </row>
                        <row>
                            <cell>%as</cell>
                            <cell>data do autor, formato curto (AAAA-MM-DD)</cell>
                        </row>
                        <row>
                            <cell>%aD</cell>
                            <cell>data do autor, no padrão RFC2822</cell>
                        </row>
                        <row>
                            <cell>%ad</cell>
                            <cell>data do autor (o formato respeita a opção --date=)</cell>
                        </row>
                        <row>
                            <cell>%al</cell>
                            <cell>parte local do email do autor (a parte antes do sinal @)</cell>
                        </row>
                        <row>
                            <cell>%ae</cell>
                            <cell>email do autor</cell>
                        </row>
                        <row>
                            <cell>%an</cell>
                            <cell>nome do autor</cell>
                        </row>
                        <row>
                            <cell>%h</cell>
                            <cell>abreviação do <emph>hash</emph> do <emph>commit</emph>
                            </cell>
                        </row>
                        <row>
                            <cell>%H</cell>
                            <cell>
                                <emph>hash</emph> do <emph>commit</emph>
                            </cell>
                        </row>
                    </table>
                </div>
            </div>
            <div type="2">
                <head>Considerações finais</head>
                <quote>
                    <p>Com o uso disciplinado do Git, cientistas e laboratórios podem garantir que toda a linha do tempo dos eventos que ocorrem durante o desenvolvimento de um projeto de pesquisa é registada de forma segura em um sistema que oferece segurança contra a perda de dados e incentiva a exploração sem riscos de novas ideias e abordagens<ref type="footnotemark" target="#note_ram"/> (tradução minha).</p>
                </quote>
                <p>O uso consciente e sistemático do Git, apesar de sua curva de aprendizagem mais acentuada, permite que pesquisadores e equipes possam trabalhar de forma segura e controlada, integrando no processo de pesquisa/escrita os procedimentos metodológicos de documentação e registo de metadados e decisões tomadas. Ao mesmo tempo, garante a criação de uma linha do tempo de todo o processo, permitindo a recuperação das informações e o restauro de ficheiros. </p>
                <p>Entendo que, com o Git, no dia a dia de uma pesquisa, ganhamos tempo e tranquilidade para documentar, preservar e recuperar informações, assim como para apresentar, em qualquer momento e de forma transparente, todas as nossas decisões e escolhas.</p>
                <p>Na segunda parte dessa lição, procuro apresentar o fluxo de trabalho em múltiplos ramos, as possibilidades de reverter as mudanças de um repositório, a configuração do <code rend="inline">.gitignore</code>, e o trabalho com repositórios remotos, hospedados em plataformas como o GitHub. Estas outras características do Git são muito úteis para o trabalho com equipes variadas, para a difusão das pesquisa e colaboração entre diferentes pesquisadores.</p>
            </div>
            <div type="2">
                <head>Agradecimentos</head>
                <p>Essa lição não seria possível sem os workshops, webinars, pesquisas e debates realizados no LABHD-UFBA, no Lab_HD da Universidade Nova de Lisboa (IHC, NOVA FCSH/IN2PAST), e no Laboratório de Humanidades Digitais da FGV-CPDOC. E, portanto, agradeço pelo espaço e parceria.</p>
            </div>
            <div type="2">
                <head>Leituras adicionais</head>
                <p>Baker, James, "Preservar os seus dados de investigação", traduzido por Márcia T. Cavalcanti, <emph>Programming Historian em português</emph>, 2021, <ref target="https://doi.org/10.46430/phpt0001">https://doi.org/10.46430/phpt0001</ref>.</p>
                <p>Brasil, Eric. "Criação, manutenção e divulgação de projetos de História em meios digitais: git, GitHub e o <emph>Programming Historian</emph>". <emph>Apresentação</emph>. Zenodo, 2022. <ref target="https://doi.org/10.5281/zenodo.6566754">https://doi.org/10.5281/zenodo.6566754</ref>.</p>
                <p>Loeliger, Jon, e Matthew McCullough. <emph>Version Control with Git</emph>: Powerful tools and techniques for collaborative software development. 2º edição. Sebastopol, CA: O’Reilly Media, 2012.</p>
                <p>
                    <note xml:id="note_traducao"> Uma vez que a tradução do Git é feita pela comunidade, a versão portuguesa remete para o português do Brasil (pt_BR) não existindo, até ao momento, uma versão em português de Portugal (pt_PT). Esta ainda apresenta trechos em inglês, o que pode gerar problemas de compreensão. Nesta lição utilizámos o padrão do Git existente para pt_BR.</note>
                    <note xml:id="note_terminal"> Para abrir o seu emulador de terminal padrão em distribuições Linux, basta clicar em <code rend="inline">Super</code> + <code rend="inline">t</code> e, no MacOs, basta clicar no Launchpad e procurar o "Terminal".</note>
                    <note xml:id="note_branches"> Falaremos mais detalhadamente sobre <emph>branches</emph> (em português, ramos) e respetivo fluxo de trabalho na parte dois desta lição.</note>
                    <note xml:id="note_main"> Seguindo debates públicos recentes, em 2020, o <ref target="https://perma.cc/Z8LL-CGGC">GitHub alterou o padrão de nomeação do ramo principal</ref> de <code rend="inline">master</code> para <code rend="inline">main</code>. A questão também está a ser discutida no projeto Git, como pode ser visto <ref target="https://perma.cc/43UB-HSBR">aqui</ref> (em inglês).</note>
                    <note xml:id="note_gitedit"> Pode ter acesso através do comando <code rend="inline">git config --global --edit</code>.</note>
                    <note xml:id="note_echo"> É uma ferramente Unix que permite imprimir texto numa determinada saída. Aqui, utilizamos para inserir texto dentro de um ficheiro. Para mais informações <ref target="https://perma.cc/DA4C-FCQD">ver a documentação</ref> (em inglês).</note>
                    <note xml:id="note_vim"> Editor de texto altamente configurável, comumente pré-instalado em sistemas Unix e MacOs. Veja a <ref target="https://perma.cc/RJ78-9R75">documentação aqui</ref> (em inglês).</note>
                    <note xml:id="note_gitdate"> É possível configurar o modelo de apresentação da data e hora no Git. Para saber mais veja esta <ref target="https://perma.cc/7QAK-2MZ9">documentação</ref> (em inglês) ou esta <ref target="https://perma.cc/92VB-54TV">explicação no StackOverflow</ref> (em inglês).</note>
                    <note xml:id="note_torvald">
                        <ref target="https://perma.cc/V5YW-3BMW">Linus Torvald</ref> é o criador e desenvolvedor do Kernel Linux, bem como o criador do Git.</note>
                    <note xml:id="note_github"> O GitHub é uma plataforma de hospedagem de repositórios Git, que permite a colaboração entre pesquisadores e a publicação de projetos de pesquisa, entre diversas outras funcionalidades que serão abordadas na parte dois desta lição. Para saber mais, veja a <ref target="https://perma.cc/94LG-T33C">documentação</ref>.</note>
                    <note xml:id="note_ram"> Ram, Karthik. “Git can facilitate greater reproducibility and increased transparency in science”. Source Code for Biology and Medicine, 8, nº 1, 2013: 7. <ref target="https://doi.org/10.1186/1751-0473-8-7">https://doi.org/10.1186/1751-0473-8-7</ref>.</note>
                    <note xml:id="note_guerrero"> Guerrero-Higueras, Ángel Manuel, Camino Fernández Llamas, Lidia Sánchez González, Alexis Gutierrez Fernández, Gonzalo Esteban Costales, e Miguel Ángel Conde González. “Academic Success Assessment through Version Control Systems”. Applied Sciences 10, nº 4 (janeiro de 2020): 1492. <ref target="https://doi.org/10.3390/app10041492">https://doi.org/10.3390/app10041492</ref>.</note>
                    <note xml:id="note_chacon"> Chacon, Scott, e Ben Straub. Pro Git. 2º edição. New York: Apress, 2014.</note>
                    <note xml:id="note_bryan"> Bryan, Jennifer. “Excuse Me, Do You Have a Moment to Talk About Version Control?” The American Statistician 72, nº 1, 2018: 20–27. <ref target="https://doi.org/10.1080/00031305.2017.1399928">https://doi.org/10.1080/00031305.2017.1399928</ref>.</note>
                    <note xml:id="note_kim"> Kim, Youngtaek, Jaeyoung Kim, Hyeon Jeon, Young-Ho Kim, Hyunjoo Song, Bohyoung Kim, e Jinwook Seo. “Githru: Visual Analytics for Understanding Software Development History Through Git Metadata Analysis”. IEEE Transactions on Visualization and Computer Graphics 27, nº 2 (fevereiro de 2021): 656–66. <ref target="https://doi.org/10.1109/TVCG.2020.3030414">https://doi.org/10.1109/TVCG.2020.3030414</ref>.</note>
                    <note xml:id="note_gibbs"> Gibbs, Fred, e Trevor Owens. “The Hermeneutics of Data and Historical Writing”. Em Writing History in the Digital Age, 159–70. Ann Arbor, MI: University of Michigan Press, 2013.</note>
                    <note xml:id="note_faure"> Faure, Samuel-Zacharie. “How Atomic Git Commits Dramatically Increased My Productivity - and Will Increase Yours Too”. DEV Community, 7 de março de 2023. <ref target="https://dev.to/samuelfaure/how-atomic-git-commits-dramatically-increased-my-productivity-and-will-increase-yours-too-4a84">https://dev.to/samuelfaure/how-atomic-git-commits-dramatically-increased-my-productivity-and-will-increase-yours-too-4a84</ref>. Acesso em: 9 ago. 2023.</note>
                </p>
            </div>
        </body>
    </text>
</TEI>
