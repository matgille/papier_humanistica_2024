<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:id="descarga-multiples-registros-usando-cadenas-de-consulta">
    <teiHeader>
        <fileDesc>
            <titleStmt>
                <title>Descargar múltiples registros mediante cadenas de consulta</title>
                <author role="original_author">Adam Crymble</author>
                <editor role="reviewers">
                    <persName>Luke Bergmann</persName>
                    <persName>Sharon Howard</persName>
                </editor>
                <author role="translators">Víctor Gayol</author>
                <editor role="translation-reviewers">
                    <persName>José Antonio Motilla</persName>
                    <persName>Nicolás Vaughan</persName>
                </editor>
                <editor role="editors">Fred Gibbs</editor>
            </titleStmt>
            <publicationStmt>
                <distributor>Programming Historian</distributor>
                <date type="translated">07/30/2022</date>
                <idno type="doi">10.46430/phes0059</idno>
                <date type="published">11/11/2012</date>
            </publicationStmt>
            <sourceDesc>
                <p>Born digital, in a markdown format. Original file: <ref type="original_file" target="#downloading-multiple-records-using-query-strings"/>.</p>
                <p>There are other translations: <ref target="#download-multiplos-registros-query-strings"/>
                </p>
                <p>There are other translations: <ref target="#download-multiplos-registros-query-strings"/>
                </p>
            </sourceDesc>
        </fileDesc>
        <profileDesc>
            <abstract>
                <p>Descargar un solo registro de un sitio web es fácil, aunque la descarga de muchos registros a la vez –una necesidad cada vez más frecuente– es mucho más eficiente utilizando un lenguaje de programación como Python. En esta lección escribiremos un programa que descargará una serie de registros del Old Bailey Online usando criterios de búsqueda personalizada y los guardará en un directorio de nuestro equipo.</p>
            </abstract>
            <textClass>
                <keywords>
                    <term xml:lang="en">web-scraping</term>
                    <term xml:lang="en">python</term>
                </keywords>
            </textClass>
        </profileDesc>
    </teiHeader>
    <text xml:lang="es">
        <body>
            <div type="2">
                <head>Objetivos del módulo</head>
                <p>Descargar un solo registro de un sitio web es fácil, aunque la descarga de muchos registros a la vez —una necesidad cada vez más frecuente para personas de humanidades— es mucho más eficiente si se utiliza un lenguaje de programación como Python.
En esta lección escribiremos un programa para descargar una serie de registros del <ref target="https://www.oldbaileyonline.org/">Old Bailey Online</ref> (<emph>OBO</emph>) utilizando criterios de búsqueda personalizados y luego guardarlos en un directorio de nuestro computador.<ref type="footnotemark" target="#note_1"/>
Este proceso conlleva la interpretación y manipulación de <emph>cadenas de consulta</emph> (<emph>query strings</emph>, en inglés) en la URL.
En este caso, el programa tratará de descargar fuentes que contengan referencias a personas de ascendencia africana, publicadas en el <emph>Old Bailey Proceedings</emph> entre 1700 y 1750.</p>
            </div>
            <div type="2">
                <head>¿Para quién es útil esto?</head>
                <p>Automatizar el proceso de descarga de registros de una base de datos en línea será útil para cualquier persona que trabaje con fuentes históricas almacenadas en línea de manera ordenada y accesible, y que desea guardar copias de esas fuentes en su propio computador.
Es particularmente útil para quien quiera descargar muchos registros específicos, en lugar de solo unos cuantos.
Si deseas descargar <emph>todos</emph> o <emph>la mayoría</emph> de los registros de una base de datos determinada, el tutorial de Ian Milligan sobre <ref target="/es/lecciones/descarga-automatizada-con-wget">Descarga automatizada con Wget</ref> puede ser más adecuado.</p>
                <p>El presente tutorial te permitirá descargar registros específicos de manera selectiva, aislando aquellos que satisfagan tus necesidades.
La descarga automática de varias fuentes ahorra un tiempo considerable.
Lo que hagas con las fuentes descargadas depende de tus objetivos de investigación.
Es posible que quieras crear visualizaciones, aplicar diversos métodos de análisis de datos o simplemente reformatearlos para facilitar la navegación.
O quizá solo desees guardar una copia de seguridad para acceder a ellos cuando no tengas acceso a Internet.</p>
                <p>Esta lección está dirigida a usuarios intermedios de Python.
Si aún no has revisado las lecciones de <ref target="/es/lecciones/introduccion-e-instalacion">Programación básica en Python</ref>, puedes encontrar en ellas un punto de partida útil.</p>
            </div>
            <div type="2">
                <head>Cómo aplicar nuestro conocimiento histórico</head>
                <p>En esta lección crearemos nuestro propio corpus de casos relacionados con personas de ascendencia africana.
A partir del <ref target="https://www.oldbaileyonline.org/browse.jsp?id=t17800628-33&amp;div=t17800628-33">caso de Benjamin Bowsey</ref> en el <emph>OBO</emph> en 1780, notamos que la voz "<emph>black</emph>"<ref type="footnotemark" target="#note_2"/> es una palabra clave útil para localizar otros casos que involucren a acusados de ascendencia africana.
Sin embargo, cuando buscamos "<emph>black</emph>" en el sitio web del <emph>OBO</emph>, encontramos que a menudo se refiere a otros usos de la palabra: caballos negros, tela negra, etc.
La tarea de desambiguar este uso del lenguaje tendrá que esperar a otra lección.
Por ahora vayamos a los casos más fáciles.
Como historiadores e historiadoras, probablemente podamos pensar en palabras clave relacionadas con los descendientes de africanos que valdría la pena explorar.
La infame <emph>n-word</emph>
                    <ref type="footnotemark" target="#note_3"/> no es útil, por supuesto, ya que ese término no entró en uso regular sino hasta mediados del siglo XIX.
Pero <emph>negro</emph> y <emph>mulatto</emph> eran voces muy utilizadas a principios del siglo XVIII.
Estas palabras clave son menos ambiguas que "<emph>black</emph>" y es mucho más probable que sean referencias inmediatas a personas de nuestro grupo demográfico objetivo.
Si intentamos buscar por separado estos dos términos en el sitio web del <emph>OBO</emph>, obtenemos resultados como en estas capturas de pantalla:</p>
                <figure>
                    <desc>Resultados de búsqueda para 'negro' en el OBO</desc>
                    <graphic url="SearchResultsNegro.png"/>
                </figure>
                <figure>
                    <desc>Resultados de búsqueda para 'mulatto' en el OBO</desc>
                    <graphic url="SearchResultsMulatto.png"/>
                </figure>
                <p>Después de analizar estos resultados, resulta evidente que se trata de referencias a personas y no a caballos, ropa u otras cosas que pueden ser de color negro.
Queremos tener todos estos registros en nuestro computador para usarlos en nuestro análisis así que podríamos descargarlos manualmente uno por uno.
Pero encontremos una manera programática de automatizar esta tarea.</p>
            </div>
            <div type="2">
                <head>La búsqueda avanzada en el <emph>OBO</emph>
                </head>
                <p>Las características de búsqueda de cada sitio web funcionan de manera diferente.
Si bien las búsquedas funcionan de manera similar, la complejidad en la que están estructuradas las búsquedas en bases de datos pueden no ser del todo obvias.
Por lo tanto, es importante pensar críticamente sobre las opciones de búsqueda en la base de datos y leer la documentación proporcionada en el sitio web, cuando esta esté disponible.
El historiador o historiadora prudente siempre critica sus fuentes, por lo que los procedimientos que hay detrás de las casillas de búsqueda deben recibir la misma atención de nuestra parte.
El <ref target="https://www.oldbaileyonline.org/forms/formMain.jsp">formulario de búsqueda avanzada</ref> del <emph>OBO</emph> te permite refinar tus búsquedas en diez campos diferentes, incluyendo palabras clave simples, un rango de fechas y un tipo de delito.
Como la función de búsqueda de cada sitio web es diferente, siempre vale la pena tomarse un tiempo para experimentar con ella y leer acerca de las opciones disponibles.
Como ya hemos hecho una búsqueda simple de los términos "<emph>negro</emph>" y "<emph>mulatto</emph>", sabemos que obtendremos resultados.
Usaremos la búsqueda avanzada para limitar nuestros resultados a los registros de procesos judiciales publicados en los <emph>Old Bailey Proceedings</emph> entre 1700 y 1750 solamente.
Desde luego, puedes ajustar la búsqueda como quieras; pero si sigues el ejemplo aquí presentado, será más fácil comprender la lección.
Ejecuta la búsqueda que se muestra en la imagen de abajo.
Asegúrate de marcar el botón de opción <emph>Advanced</emph> ("Avanzado") y usa los comodines <code rend="inline">*</code> para incluir entradas en plural o aquellas con una “e” adicional al final.</p>
                <figure>
                    <desc>Ejemplo de búsqueda avanzada en el OBO</desc>
                    <graphic url="AdvancedSearchExample.png"/>
                </figure>
                <p>Realiza la búsqueda y luego haz clic en el enlace <emph>Calculate total</emph> ("Calcular el total") para ver cuántas entradas hay.
Debe haber 13 resultados (si tienes un número diferente, vuelve atrás y asegúrate de haber copiado exactamente el ejemplo anterior).
Vamos a descargar estas transcripciones de procesos judiciales para analizarlas más a fondo.
Por supuesto, puedes descargar cada uno de los 13 registros manualmente.
Sin embargo, a medida queb más datos están disponibles en línea, será necesario manejar descargas de 1,300 o incluso 130,000 registros.
La descarga de registros individuales resulta poco práctica y saber cómo automatizar el proceso es una herramienta muy valiosa.
Para automatizar el proceso de descarga debemos retroceder y aprender cómo se crean las URLs de búsqueda en el sitio web del <emph>OBO</emph>, un método común en muchas bases de datos y sitios web en línea.</p>
            </div>
            <div type="2">
                <head>Comprender las consultas en URLs</head>
                <p>Echa un vistazo a la URL producida con la última página de resultados de búsqueda. Debe tener un aspecto como este:</p>
                <ab>
                    <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_0" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_0.txt" lang="language-xml" rend="block"/>
                </ab>
                <p>Ya hemos estudiado las URLs en la lección <ref target="/es/lecciones/ver-archivos-html">Para entender páginas web y HTML</ref>
y este parece mucho más complicado.
Pero, aunque es más largo, en realidad <emph>no</emph> es mucho más complejo.
Es sencillo entenderlo al observar cómo se representan nuestros criterios de búsqueda en la URL:</p>
                <ab>
                    <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_1" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_1.txt" lang="language-xml" rend="block"/>
                </ab>
                <p>Aquí observamos más claramente los 12 datos que necesitamos para realizar nuestra búsqueda (uno en cada línea).
Tenemos la URL del sitio web del <emph>OBO</emph> seguido de una consulta (introducida por el carácter <code rend="inline">?</code>),
seguida de 11 <emph>pares nombre/valor</emph> acompañados cada uno del carácter <code rend="inline">&amp;</code>.
Cada par contiene el nombre de una variable de servidor (por ejemplo, <code rend="inline">toYear</code>),<ref type="footnotemark" target="#note_4"/>
unido con el signo de asignación <code rend="inline">=</code>
al valor de dicha variable (en nuestro ejemplo, <code rend="inline">1750</code>).
Finalmente, el carácter '&amp;' le indica al servidor que a continuación siguen más pares nombre/valor en la URL.
Todo esto forma la cadena de consulta que le dice al motor de búsqueda qué variables utilizar en etapas específicas de la búsqueda.</p>
                <p>En nuestro caso, la variable de servidor más importante de la cadena de consulta es <code rend="inline">_divs_fulltext</code>, a la que se le ha dado el valor <code rend="inline">mulatto*+negro*</code>.
Este valor contiene el término de consulta que hemos escrito en el cuadro de búsqueda.
(La aplicación web ha agregado automáticamente un signo <code rend="inline">+</code> en lugar de un espacio en blanco ya que las URLs no pueden contener espacios.)
Esto es exactamente lo que le hemos pedido al buscador del <emph>OBO</emph> que nos encuentre.</p>
                <p>Las otras variables de servidor tienen valores que también establecimos en la caja de búsqueda.
<code rend="inline">fromYear</code> y <code rend="inline">toYear</code> contienen nuestro intervalo de fechas.
Nota que en nuestro ejemplo el valor de <code rend="inline">toMonth</code> es 99.
Como ningún año tiene 99 meses,
podemos conjeturar que así es como el algoritmo de búsqueda garantiza que se incluyan todos los registros de un mismo año.
No hay reglas estrictas para determinar qué hace cada variable porque las personas que construyeron el sitio les han asignado un nombre arbitrario.
A menudo podemos hacer una conjetura basada en nuestra experiencia y conocimiento.</p>
                <p>Todos los campos de búsqueda posibles en la página de búsqueda avanzada tienen su propio par de nombre/valor.
Si deseas averiguar el nombre de la variable de servidor para poder usarla, busca de nuevo y asegúrate de poner un valor en el campo de tu interés.
Después de enviar tu búsqueda, verás el valor y el nombre asociado a él como parte de la URL de la página de resultados.
Con el <emph>OBO</emph>, al igual que con muchos otros sitios web, el formulario de búsqueda te ayuda esencialmente a construir URLs que le indiquen a la base de datos qué debe buscar.
Si comprendes cómo se representan los campos de búsqueda en la URL, lo que a menudo es bastante sencillo, entonces es relativamente fácil construir las URLs mediante programación y, por lo tanto, automatizar el proceso de descarga de registros.</p>
                <p>Entre las variables de servidor hay una que será importante en nuestra búsqueda programática.
La variable <code rend="inline">start</code> le indica al servidor en cuál número de registro debe iniciar la página de resultados.
Por ejemplo, si cambias <code rend="inline">start=0</code> por <code rend="inline">start=10</code> en la URL y presionas enter,
deberás obtener los resultados del 11 al 13.
Y si la cambias por <code rend="inline">start=5</code>, obtendrás del 6 al 13.
Sería ideal que pudiéramos elegir mostrar todos los resultados en una sola página,
pues ello facilitará su procesamiento;
pero la aplicación web del <emph>OBO</emph> despliega los resultados en páginas de 10 registros cada una.</p>
                <p>Ahora aprovecharemos este conocimiento para crear una serie de URLs que nos permitirá descargar los 13 archivos.</p>
            </div>
            <div type="2">
                <head>Descarga sistemática de archivos</head>
                <p>En <ref target="/es/lecciones/trabajar-con-paginas-web">Descargar páginas web con Python</ref> aprendimos que Python puede descargar una página web siempre que tengamos la URL.
En dicha lección usamos la URL para descargar la <ref target="https://www.oldbaileyonline.org/browse.jsp?id=t17800628-33&amp;div=t17800628-33">transcripción del proceso de Benjamin Bowsey</ref>.
En la presente lección estamos intentando descargar varias transcripciones de procesos judiciales que cumplan con los criterios de búsqueda que describimos anteriormente, sin tener que volver a ejecutar el programa repetidamente.
Así pues, queremos un programa que descargue todo lo que necesitamos de una sola vez.
En este punto, tenemos la URL de una página de resultados de búsqueda que contiene las diez primeras entradas de nuestra consulta.
También sabemos que al modificar el valor de la variable <code rend="inline">start</code> en la URL, podemos llamar secuencialmente cada página de resultados de búsqueda y así al fin recuperar todos los registros de procesos judiciales.
Por supuesto, las páginas de resultados no nos dan los los registros de los procesos judiciales sino enlaces a ellos.
Así que necesitamos extraer el enlace a los registros contenidos en los resultados de búsqueda.
En el sitio web del <emph>OBO</emph>, los de los registros individuales (los archivos de transcripción de los procesos judiciales) se pueden encontrar como enlaces en las páginas de resultados de búsqueda.
Sabemos que todas las URLs de transcripciones contienen una identificación formada por una <code rend="inline">t</code> seguida de al menos 8 números (por ejemplo, <code rend="inline">t17800628-33</code>).
Al buscar los enlaces que contengan ese patrón, podemos identificar las URLs de las transcripciones de los procesos judiciales.
Al igual que en las lecciones anteriores, desarrollaremos un algoritmo para abordar el problema de tal manera que el computador lo pueda manejar.
Al parecer, esta tarea se puede lograr en cuatro pasos.
Necesitaremos:</p>
                <list type="ordered">
                    <item>Generar las URLs para cada página de resultados de búsqueda incrementando en una cantidad fija la variable de servidor <code rend="inline">start</code> por un número apropiado de veces.</item>
                    <item>Descargar cada página de resultados de búsqueda como un archivo HTML.</item>
                    <item>Extraer las URLs de cada procesos judiciales (utilizando la ID de proceso, como se describió anteriormente) contenidos en los archivos HTML de los resultados de la consulta.</item>
                    <item>Recorrer esos URLs extraídos para descargar cada transcripción de prueba y guardarlas en una carpeta en nuestro computador.</item>
                </list>
                <p>Recordarás que esto es bastante similar a las tareas que realizamos en <ref target="/es/lecciones/trabajar-con-paginas-web">Descargar páginas web con Python</ref> y <ref target="/es/lecciones/de-html-a-lista-de-palabras-2">De HTML a lista de palabras (parte 2)</ref>.
Primero descargamos y luego analizamos la información que buscamos;
y, en el presente caso, descargamos un poco más.</p>
                <div type="3">
                    <head>Descargar las páginas de resultados de consulta</head>
                    <p>Primero necesitamos generar las URLs para descargar cada página de resultados de consulta.
Ya tenemos el primero utilizando el formulario en el sitio web:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_2" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_2.txt" lang="language-xml" rend="block"/>
                    </ab>
                    <p>Escribamos un programa que funcione sin importar cuántas páginas de resultados de búsqueda o registros tengamos que descargar, y sin importar qué decidamos buscar.
Estudia el siguiente código y luego agrega esta función a un módulo llamado <code rend="inline">obo.py</code> (crea un archivo con ese nombre y guárdalo en el directorio donde deseas hacer tu trabajo).
Los comentarios en el código (las líneas que empiezan con un <code rend="inline">#</code>) están destinados a ayudarte a descifrar las distintas partes.</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_3" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_3.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>En esta función hemos dividido los diversos componentes de la <emph>cadena de consulta</emph> y hemos utilizado <emph>argumentos de función</emph> para que pueda reutilizarse más allá de nuestras necesidades específicas del momento.
Cuando llamamos esta función, reemplazamos los argumentos con los valores que queremos buscar.
Luego, descargamos la página de resultados de búsqueda de una manera similar a como se hace en <ref target="/es/lecciones/trabajar-con-paginas-web">Descargar páginas web con Python</ref>.
La línea que hemos marcado con ① crea el archivo <code rend="inline">resultado_consulta.html</code>, asegurándonos de estar usando la codificación de caracteres <ref target="https://es.wikipedia.org/wiki/UTF-8">UTF-8</ref>.
Y la línea ② guarda en dicho archivo el valor de la variable <code rend="inline">contenido_web</code>, también asegurándose de usar esa misma codificación.
(No necesitas cerrar explícitamente el archivo con la instrucción <code rend="inline">close</code>, ya que el bloque <code rend="inline">with</code> se encarga de ello.)</p>
                    <p>Ahora crea un nuevo programa de Python llamado <code rend="inline">descarga_consultas.py</code>
y copia en él el siguiente código.
Ten en cuenta que los valores que hemos utilizado como argumentos son exactamente los mismos del ejemplo anterior.
Siéntete libre de jugar con estos para obtener diferentes resultados o ver cómo funcionan.</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_4" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_4.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Cuando ejecutes este programa
(con <code rend="inline">python3 descarga_consultas.py</code> desde el terminal, o desde tu editor de código preferido),
encontrarás un nuevo archivo llamado <code rend="inline">resultado_consulta.html</code> en tu carpeta de trabajo.
Este archivo contiene la primera página de los resultados de búsqueda.
Comprueba que se haya descargado correctamente y luego bórralo, pues ya no lo necesitaremos.
Vamos a adaptar nuestro programa para descargar la otra página que contiene las otras 3 entradas al mismo tiempo, por lo que debemos asegurarnos de obtener ambas.</p>
                    <p>Refinemos ahora nuestra función de Python <code rend="inline">obtener_resultados_consulta</code>.
Primero agregaremos otro argumento de función llamado <code rend="inline">entradas</code>
para que podamos decirle al programa cuántas páginas de resultados necesitamos descargar.
Usaremos el valor de las entradas y algunos cálculos matemáticos simples para determinar cuántas páginas de resultados de búsqueda hay.
Esto es bastante sencillo ya que sabemos que en el <emph>OBO</emph> hay 10 transcripciones enumeradas por página.
Podemos calcular el número de páginas de resultados dividiendo el valor de las entradas por 10.
Guardaremos este resultado en una variable entera llamada <code rend="inline">contar_paginas</code>.
Será algo como lo siguiente:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_5" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_5.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Debido a que en Python 3 el operador <code rend="inline">//</code> es de división entera, y por lo tanto redondea hacia el menor número entero el resultado de la división, el valor de <code rend="inline">contar_palabras</code> siempre será un número entero.
Prueba lo siguiente ejecutando el siguiente código en <ref target="https://docs.python.org/es/3/tutorial/interpreter.html">el intérprete REPL de Python</ref> en tu terminal (en Mac y Linux),
o en cmd o PowerShell (en Windows).
(Nota, de aquí en adelante, usaremos la palabra "terminal" para referirnos al intérprete de línea de comandos.)</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_6" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_6.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Ahora bien, lo que queremos obtener es "2":
una página que contiene las entradas 1 a 10, y otra que contiene las entradas 11 a 13.
Pero dado que hay un residuo en esta operación (de 3 en este caso, aunque no importa cuál sea), los últimos 3 resultados no se descargarán ya que solo capturaremos 1 página de 10 resultados.
Para solucionar este problema utilizaremos el operador <ref target="https://docs.python.org/3.10/library/operator.html?highlight=modulo">modulo</ref> (<code rend="inline">%</code>), que divide el primer valor por el segundo y nos devuelve el residuo.
Así, si el residuo es mayor que 0, sabemos que hay una página adicional de resultados y necesitamos aumentar el valor de la variable de Python <code rend="inline">contar_paginas</code> en una unidad.
El código ahora debería verse así:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_7" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_7.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Si agregamos este código a nuestra función <code rend="inline">obtener_resultados_consulta</code>, justo debajo de la línea <code rend="inline">start_value = 0</code>, nuestro programa podrá calcular el número de páginas que deben descargarse.
Sin embargo, en esta etapa solo se descargará la primera página, ya que hemos indicado, en la sección de la función de descarga, que se ejecute solamente una vez.
Para corregirlo, debemos encerrar en un bucle <code rend="inline">for</code> el código de descarga que trabajará una vez por cada número que se indique en la variable de Python <code rend="inline">contar_paginas</code>.
Si el valor de dicha variable es 1, entonces descargará una vez; si obtiene 5 descargará cinco veces, y así sucesivamente.
(El valor de <code rend="inline">pagina</code> irá aumentando en cada iteración de bucle <code rend="inline">for</code>: 1, 2, 3, etc. hasta una unidad menos que el valor de <code rend="inline">contar_páginas</code>)
Inmediatamente después de la línea que contiene la expresión <code rend="inline">contar_paginas += 1</code>, que acabas de escribir, agrega la siguiente línea y todo lo que está debajo de la línea que contiene <code rend="inline">f.write(contenido_web.decode('utf-8'))</code> (cuida de sangrar a la derecha todo el código para que este se incluya en el bucle <code rend="inline">for</code>):</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_8" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_8.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Dado que este es un bucle <code rend="inline">for</code>, debemos planear bien todo el código que queremos ejecutar repetidamente ahí.
Puedes saber si lo has hecho correctamente al ver el ejemplo del código terminado a continuación.
Este bucle aprovecha la función <ref target="https://docs.python.org/3.10/library/stdtypes.html">range</ref> ("rango") de Python.
Para entender esto, es mejor pensar que la variable de Python <code rend="inline">contar_paginas</code> es igual a 2 como se muestra en el ejemplo.
Estas dos líneas de código significan:
"Comienza a ejecutarlo con un valor de bucle inicial de 0, y cada vez que ejecutes agrega 1 más a ese valor. Cuando el valor del bucle es el mismo que <code rend="inline">contar_paginas</code>, ejecuta una vez más y luego para."<ref type="footnotemark" target="#note_5"/>
Esto es particularmente valioso en nuestro caso, porque podemos decirle a nuestro programa que se ejecute exactamente una vez para cada página de resultados, lo que proporciona una nueva habilidad flexible para controlar cuántas veces se ejecuta el bucle <code rend="inline">for</code>.
Si deseas practicar con esta nueva y poderosa forma de escribir bucles, puedes abrir tu terminal y jugar con el REPL de Python:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_9" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_9.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Ahora bien, antes de agregar todo este código a nuestra función <code rend="inline">obtener_resultados_consulta</code>, tenemos que hacer dos ajustes.
Primero, al final del bucle <code rend="inline">for</code> (pero aún dentro del bucle) y después de que se haya ejecutado nuestro código de descarga, necesitaremos modificar la variable de servidor <code rend="inline">startValue</code> en la URL de la página que queremos descargar.
(Esto lo hacemos modificando la variable de Python correspondiente <code rend="inline">start_value</code>, que es la que nuestro programa usa para general el valor de la variable de servidor <code rend="inline">startValue</code> en la URL.)
Si no lo hacemos, nuestro programa descargará repetidamente la primera página de resultados pues no estamos cambiando nada en la URL inicial.<br/>
Por lo tanto, podemos solicitar la siguiente página de resultados de búsqueda aumentando su valor en 10, una vez que se haya completado la descarga inicial.
Si no sabes exactamente dónde colocar esta línea, puedes echar un vistazo al ejemplo de código terminado, más abajo.</p>
                    <p>Segundo, debemos asegurarnos de que el nombre del archivo con los datos que hemos descargado sea diferente para cada página registrada.
De lo contrario, cada descarga se guardará sobrescribiendo la descarga anterior, lo que nos dejará con un solo archivo de resultados.
Para resolver esto, debemos ajustar el contenido de la variable <code rend="inline">nombre_archivo</code> para incluir el valor contenido en la variable <code rend="inline">pagina</code>.
Así, cada vez que descarguemos una nueva página, obtendremos un nombre diferente:
<code rend="inline">resultado_consulta0.html</code>, <code rend="inline">resultado_consulta1.html</code>, <code rend="inline">resultado_consulta2.html</code> y así sucesivamente.
Como <code rend="inline">pagina</code> contiene un número entero, tendremos que convertir su valor en una cadena (con la función <code rend="inline">str()</code> de Python) antes de poder agregarlo a la variable de cadena <code rend="inline">nombre_archivo</code>.
(De lo contrario obtendremos un error, pues el operador <code rend="inline">+</code>, usado como concatenador, requiere necesariamente datos de tipo de cadena, no de tipo numérico.)
Ajusta la línea en tu programa que pertenece a la variable <code rend="inline">nombre_archivo</code> para que se vea así:<ref type="footnotemark" target="#note_6"/>
                    </p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_10" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_10.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Ahora ya puedes agregar estas nuevas líneas de código a tu función <code rend="inline">obtener_resultados_consulta</code>.
Recordemos que hasta el momento hemos añadido lo siguiente:</p>
                    <list type="ordered">
                        <item>agregamos la variable de Python <code rend="inline">entradas</code> como un argumento de función adicional justo después de <code rend="inline">to_month</code>;</item>
                        <item>calculamos el número de páginas de resultados e incluimos esto inmediatamente después de la línea que comienza con <code rend="inline">start_value = 0</code> (antes de crear la URL y comenzar a descargar);</item>
                        <item>inmediatamente después de esto añadimos un bucle <code rend="inline">for</code>, que le indicará al programa que se ejecute una vez para cada página de resultados de búsqueda (es importante sangrar a la derecha el resto del código de la función para que quede dentro del nuevo bucle);</item>
                        <item>ajustamos la variable <code rend="inline">nombre_archivo</code> existente para que cada vez que se descargue una página de resultados se le dé un nombre único al archivo; y</item>
                        <item>finalmente, en la última línea del bloque de <code rend="inline">for</code> aumentamos el valor de la variable de Python <code rend="inline">start_value</code> (en 10 unidades) cada vez que se ejecute el bucle.</item>
                    </list>
                    <p>Ahora bien, antes de proseguir, hagamos una última cosa.
Nota que en el código de la función <code rend="inline">obtener_resultados_consulta</code> la variable de Python <code rend="inline">entradas</code>, que contiene el número de registros que han de ser obtenidos, está predefinida con un valor fijo (13 en nuestro ejemplo).
Como queremos que nuestra función sea más flexible y no esté necesariamente atada a un número predeterminado de registros, vamos incluir un argumento o parámetro adicional en nuestra definición de función: <code rend="inline">entradas</code>. Lo añadiremos al final de la lista de argumentos: <code rend="inline">def obtener_resultados_consulta(..., entradas)</code>.
Así las cosas, el código de la función terminada en el archivo <code rend="inline">obo.py</code> deberá verse de la siguiente manera:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_11" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_11.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Como hemos añadido la variable <code rend="inline">entradas</code> en la definición de la función, debemos añadir un argumento adicional cuando la llamemos en el programa <code rend="inline">descarga_consultas.py</code>:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_12" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_12.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>¡Estupendo!
Corre el programa y verás que ahora tenemos dos páginas de resultados de búsqueda:
<code rend="inline">resultado_consulta0.html</code> y <code rend="inline">resultado_consulta1.html</code>.
Pero antes de avanzar al siguiente paso en el algoritmo, vamos a ocuparnos de algunas tareas de limpieza. Nuestra carpeta de trabajo se volverá difícil de manejar si descargamos varias páginas de resultados y transcripciones de procesos judiciales en ella.
Por lo tanto, con Python crearemos un nuevo directorio con el nombre de nuestros términos de búsqueda.</p>
                    <p>Queremos añadir esta nueva funcionalidad en <code rend="inline">obtener_resultados_consulta</code>, para que nuestras páginas de resultados de búsqueda se descarguen en un directorio con el mismo nombre que nuestra consulta de búsqueda.
Esto mantendrá nuestro directorio de trabajo más organizado.
Para ello crearemos un nuevo directorio utilizando el módulo de Python <code rend="inline">os</code>, (abreviatura de <emph>operating system</emph>, "sistema operativo").
Esa biblioteca contiene una función llamada <code rend="inline">makedirs</code> cuya función es crear un nuevo directorio.
Puedes probar esto usando el REPL de Python.</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_13" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_13.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Este código verifica si tu computador ya tiene un directorio con este nombre.
Si no lo tenías, ahora deberás tener un directorio llamado <code rend="inline">mi_directorio_nuevo</code>.
(El directorio se creará como subdirectorio del directorio donde hayas llamado originalmente al REPL de Python.)
Si esto funciona, puedes eliminar el directorio de tu disco duro, ya que esto fue solo para practicar.
Como queremos crear un nuevo directorio con el nombre de la consulta que ingresamos en el sitio web del <emph>OBO</emph>, haremos uso directamente del argumento de función <code rend="inline">consulta</code> en la función <code rend="inline">obtener_resultados_consulta</code>.
Para hacer esto, importa el módulo <code rend="inline">os</code> (debajo de las otra instrucción de importación, <code rend="inline">from urllib.request import urlopen</code>).</p>
                    <p>Ahora bien, como estamos usando los caracteres <code rend="inline">*</code> y <code rend="inline">+</code> en nuestra búsqueda en el <emph>OBO</emph>, y como estos tienen una significación importante en el modo como los sistemas operativos navegan los directorios, es conveniente que los reemplacemos por otros más seguros antes de crear nuestro directorio.
Usaremos <ref target="https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular">expresiones regulares</ref> en <ref target="https://docs.python.org/3.10/library/re.html">Python</ref> para excluir del nombre de directorio todos los caracteres que no sean alfanuméricos.
Python dispone del potente módulo <code rend="inline">re</code> (que deberemos importar al inicio del archivo <code rend="inline">obo.py</code>, debajo de las otras instrucciones de importación) para ello.
Nuestro código "seguro" será entonces el siguiente:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_14" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_14.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>En la primera línea, la función <code rend="inline">re.sub</code> busca la expresión regular <code rend="inline">\W</code> (que significa: "cualquier carácter <emph>no</emph> alfanumérico") en el valor de la variable <code rend="inline">consulta</code> y lo reemplaza por la cadena vacía <code rend="inline">''</code>, es decir, lo elimina.<ref type="footnotemark" target="#note_7"/>
El resultado de este reemplazo se almacena en la variable <code rend="inline">directorio</code>.
(Es importante que recordemos, en todo caso, que el valor que nuestro programa pasará a la variable de servidor en la URL aún contiene los caracteres <code rend="inline">*</code> y <code rend="inline">+</code>.
Este reemplazo solo es para el nombre del directorio.)</p>
                    <p>Así las cosas, la función <code rend="inline">obtener_resultados_consulta</code> deberá quedar así:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_15" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_15.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Muy bien.
Ahora debemos asegurarnos de que guardemos nuestras páginas de resultados de búsqueda en este nuevo directorio.
Podemos hacerlo de muchas maneras, pero la más sencilla es agregar el nuevo nombre del directorio más una barra al nombre del archivo (en la variable <code rend="inline">nombre_archivo</code>):</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_16" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_16.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Nota, sin embargo, que este código solo funcionará adecuadamente en MacOS y en Linux,
no en Windows, pues este usa la barra invertida <code rend="inline">\</code> para demarcar rutas de directorio.
Para asegurarnos de que funcione también en Windows, usaremos la función <code rend="inline">os.path.join</code> de Python.
Esta función une adecuadamente las rutas, teniendo en cuenta el sistema operativo donde se corre el programa.
Arriba en <code rend="inline">obo.py</code> la importaremos así:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_17" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_17.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>(la importaremos como <code rend="inline">pjoin</code> porque de lo contrario habría una colisión con la función de concatenación <code rend="inline">join</code>, que es más fundamental en Python).</p>
                    <p>La línea modificada será entonces esta:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_18" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_18.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Así pues, el código completo del programa <code rend="inline">obo.py</code> deberá quedar así:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_19" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_19.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Ejecuta el programa <code rend="inline">descarga_consultas.py</code> una vez más para asegurarte de que funcione
y entiendas cómo guardar archivos en un directorio particular usando Python.</p>
                </div>
                <div type="3">
                    <head>Descargar las entradas individuales de los procesos judiciales</head>
                    <p>A estas alturas hemos creado una función capaz de descargar todos los archivos HTML con los resultados de consulta del sitio web del <emph>OBO</emph>, para realizar la búsqueda avanzada que hemos definido.
Todo esto lo hemos hecho usando Python.
Para el siguiente paso del algoritmo, debemos extraer las URLs de cada proceso judicial de los archivos HTML.
En las lecciones que preceden a esta (por ejemplo, <ref target="/es/lecciones/trabajar-con-paginas-web">Descargar páginas web con Python</ref>),
hemos trabajado con versiones para impresión (<emph>printer friendly</emph>) de los procesos judiciales,
por lo que continuaremos haciéndolo así aquí.
Sabemos que la versión para impresión del proceso judicial contra Benjamin Bowsey se encuentra en la URL:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_20" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_20.txt" lang="language-xml" rend="block"/>
                    </ab>
                    <p>Así como al cambiar las cadenas de consulta en las URLs se producen resultados de búsqueda diferentes, así también al cambiar la URL por registros de procesos judiciales —es decir, sustituyendo la ID de un proceso judicial por otra—, obtendremos la transcripción de otro proceso.
(En este caso, la ID del proceso judicial se pasa con la variable de servidor <code rend="inline">div</code>, cuyo valor en el caso del ejemplo es <code rend="inline">t17800628-33</code>.)
Esto significa que para descargar los 13 archivos coincidentes, todo lo que necesitamos son las IDs de los procesos judiciales.
Como sabemos que las páginas de resultados de búsqueda en los sitios web generalmente contienen un enlace a las páginas descritas, es muy probable que podamos encontrar estos enlaces, incrustados en el código HTML.
Si en otras lecciones pudimos eliminar esta información de la página que descargamos, ahora podemos usar esa misma información para generar una URL que nos permita descargar cada transcripción del proceso judicial.
Esta técnica de <ref target="https://es.wikipedia.org/wiki/Web_scraping">
                            <emph>web scraping</emph>
                        </ref> se puede usar en la mayoría de las páginas de resultados de búsqueda, no solo la del <emph>OBO</emph>.
Para hacerlo, primero deberemos encontrar dónde están las IDs de cada proceso judicial en medio del código HTML de los archivos descargados.
Luego determinaremos una forma de aislarlos consistentemente usando Python,
de modo que siempre podamos encontrar las transcripciones de los procesos judiciales,
sin importar qué página de resultados de búsqueda descarguemos del sitio.</p>
                    <p>Abre el documento <code rend="inline">resultado_consulta0.html</code> en tu editor de código y dale un vistazo a la lista de los procesos judiciales.
La primera entrada comenzará con las palabras "Anne Smith", por lo que puedes usar la herramienta de búsqueda de texto de tu editor de código para ir inmediatamente al lugar correcto.
Fíjate que el nombre "Anne" está en el contenido de un enlace (un elemento de <code rend="inline">&lt;a&gt;</code> de HTML):</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_21" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_21.txt" lang="language-html" rend="block"/>
                    </ab>
                    <p>En el lenguaje HTML, el destino de un enlace (el <ref target="https://es.wikipedia.org/wiki/Elemento_HTML">elemento</ref>
                        <code rend="inline">&lt;a&gt;</code>) se especifica en el valor del <ref target="https://es.wikipedia.org/wiki/Atributo_HTML">atributo</ref>
                        <code rend="inline">href</code>,
que en este caso es:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_22" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_22.txt" lang="language-html" rend="block"/>
                    </ab>
                    <p>Saber esto es magnífico, pues podemos ver que el enlace contiene la ID del proceso judicial: <code rend="inline">t17160113-18</code>.
¡Excelente!
Desplázate por las entradas restantes y encontrarás lo mismo en todas ellas.
Por suerte para nosotros, el sitio está bien construido y parece que cada enlace comienza con <code rend="inline">browse.jsp?id=</code>,
seguido de la ID del proceso judicial, luego un <code rend="inline">&amp;</code> y luego el resto de variables de servidor.
En el caso de Anne Smith: <code rend="inline">browse.jsp?id=t17160113-18&amp;</code>.</p>
                    <p>Vamos entonces a escribir unas líneas de código que capturen estas IDs.
Las pondremos al final de nuestro programa de Python <code rend="inline">obo.py</code>.
Echa un vistazo al código de la función <code rend="inline">obtener_procesos_individuales</code> a continuación.
Esta función también utiliza el módulo <ref target="https://docs.python.org/es/3/library/os.path.html">os</ref> de Python, en este caso para enumerar el contenido del directorio que creamos en la sección anterior.
(Este módulo contiene una gama de funciones útiles que reflejan los tipos de tareas que podrías realizar con tu ratón en el Finder de Mac o el Explorador de Windows, como abrir, cerrar, crear, eliminar y mover archivos y directorios.
Es un módulo magnífico que deberíamos dominar o, al menos, familiarizarnos con él.)</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_23" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_23.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Ahora crea y ejecuta un nuevo programa de Python llamado <code rend="inline">extraer_id_proceso.py</code> con el siguiente código:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_24" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_24.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Asegúrate de introducir el mismo valor en el argumento de consulta como en el ejemplo anterior (<code rend="inline">mulatto*+negro*</code>).
Si todo sale bien, Python imprimirá una lista con los nombres de todos los archivos que están en la nueva carpeta, algo como:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_25" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_25.txt" lang="language-sh" rend="block"/>
                    </ab>
                    <p>Por ahora deberán ser solamente las dos páginas con los resultados de búsqueda.
Asegúrate de que esto funcione antes de seguir adelante.
Dado que hemos guardado todas las páginas de resultados usando nombres de archivo que contienen la expresión <code rend="inline">resultado_consulta</code>, podemos abrir cada uno de ellos y extraer todas las IDs de los procesos judiciales que se encuentran en él.
En este caso, sabemos que solo hay dos, aunque queremos que nuestro código sea lo más flexible posible, desde luego.
Al restringir esta acción exclusivamente a los archivos cuyos nombres contienen la expresión <code rend="inline">resultado_consulta</code>, nuestro programa funcionará como lo esperamos, incluso si el directorio contiene muchos otros archivos no relacionados porque el programa saltará cualquier cosa con un nombre diferente.</p>
                    <p>Agrega el siguiente código a la función <code rend="inline">obtener_procesos_individuales</code> (en el programa <code rend="inline">obo.py</code>).
El código pasará por cada archivo contenido en el directorio creado anteriormente
y comprobará si su nombre contiene la expresión <code rend="inline">resultado_consulta</code>.
En caso positivo, el archivo se abrirá y los contenidos se guardarán en una variable llamada <code rend="inline">texto</code>.
El contenido de dicha variable se analizará luego para aislar la ID del proceso judicial,
que sabemos que siempre está ubicada a la derecha de la expresión <code rend="inline">browse.jsp?id=</code> en la URL.
Cuando el programa encuentre la ID del proceso judicial, se guardará en una lista de Python y se imprimirá en pantalla.</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_26" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_26.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Este código puede parecer algo complicado a primera vista, pero vamos a desmenuzarlo y verás que no es tan difícil.
Las líneas ① y ④ usan el operador de continencia <code rend="inline">in</code> de Python, en este caso entre cadenas.
La expresión:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_27" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_27.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>es verdadera solo si <code rend="inline">&lt;cadena1&gt;</code> es una subcadena de <code rend="inline">&lt;cadena2&gt;</code>,
es decir, si los caracteres de la primera cadena están contenidos, en el mismo orden, en la segunda cadena.
Por ejemplo, lo siguiente es verdadero:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_28" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_28.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>pero esto es falso:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_29" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_29.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>En ese sentido, lo que las líneas ① y ④ hace es verificar que estemos seleccionando el archivo apropiado (según nuestra convención de denominación), en el primer caso; y si la "palabra" que estamos procesando contiene la expresión <code rend="inline">browse.jsp?id=</code>, en el segundo.</p>
                    <p>Veamos ahora la importancia de esa expresión, para lo cual pasemos al bucle <code rend="inline">for</code> en ③.
Este bucle iterará por cada una de las "palabras" del documento HTML que estamos procesando.
La línea ② ha guardado una lista enorme de palabras en la variable <code rend="inline">texto</code>.
Python ha partido todo el archivo con la función <code rend="inline">split</code>, cuyo argumento es un espacio en blanco (<code rend="inline">' '</code>).
Esto quiere decir que Python separará todo el documento donde haya espacios.
Estas serán nuestras "palabras", si se nos permite la expresión:
<code rend="inline">Anne</code>, <code rend="inline">Smith</code>, <code rend="inline">href="browse.jsp?id=t17160113-18&amp;amp;div=t17160113-18&amp;amp;terms=mulatto*_negro*#highlight"&gt;</code>, etc.
Nuestro <code rend="inline">for</code> pasará por cada una de ellas.
Como vimos, la línea ④ examinará si la expresión <code rend="inline">browse.jsp?id=</code> está contenida en la "palabra".
Es decir, determinará si ahí es donde está guardada la ID del proceso judicial que estamos buscando.</p>
                    <p>Si esto es el caso, en la línea ⑤ aislaremos la parte de la expresión capturada en la palabra, la ID.
Para esto usamos un grupo de captura de expresiones regulares, que se indican entre paréntesis.
Miremos en el documento HTML una de estas "palabras" que nos interesan:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_30" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_30.txt" lang="language-xml" rend="block"/>
                    </ab>
                    <p>Subrayemos la parte que nos interesa únicamente:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_31" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_31.txt" lang="language-xml" rend="block"/>
                    </ab>
                    <p>Nuestro grupo de captura tomará el texto que va desde <code rend="inline">id=</code> hasta el primer <code rend="inline">&amp;</code> (excluyéndolos en el texto capturado).
Eso es justo lo que significa la expresión regular <code rend="inline">id=(.+?)&amp;</code>.
En efecto, <code rend="inline">.+?</code> significa:
captura cualquier carácter (<code rend="inline">.</code>) una o más veces (<code rend="inline">+</code>),
pero hazlo <ref target="https://docs.python.org/es/3/howto/regex.html#repeating-things">sin codicia</ref> (<code rend="inline">?</code>),
es decir, detén la búsqueda apenas encuentres el primer <code rend="inline">&amp;</code>;
y finalmente guarda el texto hallado en un grupo de captura (<code rend="inline">(</code>, <code rend="inline">)</code>).
Python enumera secuencialmente los grupos de captura.
En nuestra expresión regular solo hay un grupo; por lo tanto, será el grupo 1.
La línea ⑥ guarda el contenido de ese grupo —nuestra ID— en la variable <code rend="inline">url</code>.
Finalmente, la línea ⑦ la añade como un ítem adicional en nuestra lista <code rend="inline">urls</code>, que luego aprovecharemos.</p>
                    <p>Cuando vuelvas a ejecutar el programa <code rend="inline">extraer_id_procesos.py</code>, verás una lista de todas las ID de los procesos judiciales.
Podemos agregar un par de líneas adicionales para convertirlas en URLs adecuadas y descargar la lista completa en nuestro nuevo directorio.
Asimismo, usaremos el módulo <code rend="inline">time</code> de Python para pausar nuestro programa durante tres segundos entre las descargas.
Esta técnica es llamada "regulación" o "limitación" (<emph>throttling</emph>, en inglés).
Se considera una buena forma de no golpear el servidor de alguien con muchas solicitudes por segundo;
y el ligero retraso hace que sea más probable que todos los archivos se descarguen antes de agotar nuestro tiempo de conexión (véase <ref target="https://www.checkupdown.com/status/E408.html">time out</ref>).
Elimina la línea que dice <code rend="inline">print(urls)</code> y pon en su lugar el código de abajo (ten en cuenta que quede sangrado exactamente donde estaba esa línea).
Agrega el siguiente código al final de la función <code rend="inline">obtener_procesos_individuales</code>, luego de la línea que tiene <code rend="inline">urls.append(url)</code>.
Este código generará la URL de cada página individual, la descargará en tu computador en directorio ya creado,
guardará el archivo y se detendrá durante 3 segundos antes de pasar al siguiente proceso judicial.
Todo lo siguiente está contenido en un bucle <code rend="inline">for</code> que se ejecutará una vez por cada proceso en tu lista de URLs.</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_32" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_32.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>(Nota que en la instrucción <code rend="inline">with open</code> usamos la variable <code rend="inline">f2</code> en lugar de <code rend="inline">f</code>.
Eso es porque todo este código está incluido en bloque <code rend="inline">with open</code> abierto,
que ya ha definido la variable <code rend="inline">f</code>.)</p>
                    <p>Si juntamos todo en una sola función, debería verse algo como lo que sigue.
Hemos añadido también un par de <code rend="inline">print</code>s para ir viendo cómo avanza nuestro programa:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_33" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_33.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Ahora agreguemos la misma pausa de tres segundos a nuestra función <code rend="inline">obtener_resultados_consulta</code> para ser amables con los servidores del <emph>OBO</emph>:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_34" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_34.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Finalmente, llama a la función desde el programa <code rend="inline">descarga_consultas.py</code>.</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_35" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_35.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Has creado un programa que puede solicitar y descargar archivos del sitio web del <emph>OBO</emph>,
según los parámetros de búsqueda que definiste, ¡todo sin visitar manualmente el sitio!</p>
                </div>
                <div type="3">
                    <head>Si los archivos no se descargan</head>
                    <p>Comprueba que los 13 archivos se hayan descargado correctamente.
Ábrelos en tu navegador web y verifica que estén bien.
Si es así, ¡genial!
Sin embargo, existe la posibilidad de que el programa se atore en el proceso.
Esto se debe a que, aunque el programa se ejecute en nuestra propia máquina, se basa en dos factores que están fuera de nuestro control inmediato:
la velocidad de Internet y el tiempo de respuesta del servidor del <emph>OBO</emph> en ese momento.
Una cosa es pedirle a Python que descargue un solo archivo;
pero cuando le pedimos que descargue un archivo cada 3 segundos,
existe una gran probabilidad de que el servidor agote el tiempo de conexión o no nos envíe el archivo que buscamos.</p>
                    <p>Si estuviéramos usando un navegador web para hacer estas solicitudes, eventualmente recibiríamos un mensaje diciendo:
"La conexión se ha agotado" o algo por el estilo.
Todos vemos esto de vez en cuando.
Sin embargo, nuestro programa no está diseñado para manejar o transmitir dichos mensajes de error.
En su lugar, te darás cuenta de que algo malo pasa, cuando descubras que el programa no ha devuelto el número esperado de archivos o que simplemente no hace nada.
Para evitar la frustración y la incertidumbre, queremos un programa a prueba de fallas que intente descargar cada proceso judicial.
Si por alguna razón falla, lo anotaremos y pasaremos al siguiente proceso.</p>
                    <p>Para hacer esto, haremos uso del mecanismo de manejo de errores y excepciones (<emph>try/except</emph>) de Python (ver <ref target="https://docs.python.org/es/3/tutorial/errors.html">errores y excepciones</ref>),
así como otro módulo de Python <code rend="inline">socket</code>.
<code rend="inline">try/except</code> se parece mucho a una declaración <code rend="inline">if/else</code>.
Cuando le pides a Python que <emph>pruebe</emph> algo (<code rend="inline">try</code>), intentará ejecutar el código.
Si el código no logra hacer lo que se ha definido, ejecutará el código <code rend="inline">except</code>.
Esto se conoce como <emph>manejo de errores</emph> y se usa con mucha frecuencia.
Podemos tomar ventaja de esto diciéndole a nuestro programa que intente descargar una página.
Si esto falla, le pediremos que nos informe qué archivo no se pudo descartar y luego seguiremos adelante.
Para esto necesitamos usar el módulo <code rend="inline">socket</code>, que nos permitirá poner un límite de tiempo en un intento de descarga antes de continuar. Esto implica alterar la función <code rend="inline">obtener_procesos_individuales</code>.</p>
                    <p>Primero debemos importar el módulo <code rend="inline">socket</code>, lo que debe hacerse de la misma manera que todas nuestras importaciones de módulos anteriores.
También tendremos que establecer la duración predeterminada del tiempo de espera de <code rend="inline">socket</code>:
cuánto tiempo intentaremos descargar una página antes de darnos por vencidos.
Esto debe escribirse inmediatamente después del comentario <code rend="inline"># descarga la página</code>
                    </p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_36" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_36.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>A continuación, agregaremos la declaración <code rend="inline">try/except</code>.
En este caso, pondremos todo el código diseñado para descargar y guardar los procesos judiciales en la declaración <code rend="inline">try</code>, y en la declaración <code rend="inline">except</code> le diremos al programa lo que queremos que haga si eso falla.
Aunque podríamos dejar la línea de la excepción de manera genérica (simplemente con un <code rend="inline">except:</code>),
<ref target="https://peps.python.org/pep-0008/#programming-recommendations">Python recomienda</ref>
especificar el tipo de excepción ocurrida.
Para ello usamos <code rend="inline">except OSError as msg:</code>.
Esto nos dice que la excepción es de tipo <ref target="https://docs.python.org/es/3/library/exceptions.html#OSError">
                            <code rend="inline">OSError</code>
                        </ref> y guardará los detalles en la variable <code rend="inline">msg</code>.</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_37" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_37.txt" lang="language-python" rend="block"/>
                    </ab>
                    <p>Si surge un problema al descargar un determinado archivo, recibirás un mensaje en el terminal.
Si solo hay uno o dos archivos no descargados, probablemente sea más rápido visitar las páginas manualmente y usar la función "Guardar como..." de tu navegador.
Pero si tienes espíritu de aventura puedes modificar el programa para descargar automáticamente los archivos restantes.</p>
                    <p>El archivo <code rend="inline">obo.py</code> terminado deberá verse como esto:</p>
                    <ab>
                        <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_38" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_38.txt" lang="language-python" rend="block"/>
                    </ab>
                </div>
            </div>
            <div type="2">
                <head>Próximos pasos: usar una interfaz de programación de aplicaciones (API)</head>
                <p>Para usuarias/os más avanzadas/os, o para adquirir más destreza, vale la pena leer acerca de cómo lograr este mismo proceso utilizando las <ref target="https://es.wikipedia.org/wiki/Interfaz_de_programaci%C3%B3n_de_aplicaciones">interfaces de programación de aplicaciones (API)</ref>.
Un sitio web con una API generalmente proporcionará instrucciones sobre cómo solicitar ciertos documentos.
Es un proceso muy similar al que acabamos de hacer interpretando las cadenas de consulta de URL, pero sin el trabajo adicional de detective que hicimos para descifrar el comportamiento de cada variable.
Si tienes interés en el <emph>OBO</emph>, el sitio cuenta con <ref target="https://www.oldbaileyonline.org/static/DocAPI.jsp">una buena API y su documentación es muy útil</ref>.</p>
            </div>
            <div type="2">
                <head>Notas</head>
                <p>
                    <ref type="footnotemark" target="#note_1"/> : El <ref target="https://es.wikipedia.org/wiki/Old_Bailey">Tribunal Penal Central de Inglaterra y Gales</ref> es conocido también como el <emph>OBO</emph>, por la calle en la que está ubicada en Londres. El sitio web del <ref target="https://www.oldbaileyonline.org">
                        <emph>OBO</emph>
                    </ref> contiene los registros judiciales de dicho tribunal desde 1674 hasta* 1913. (N. de T.)</p>
                <p>
                    <ref type="footnotemark" target="#note_2"/> : Hemos dejado los términos de búsqueda en inglés, ya que son los que arrojan resultados en la página web de <emph>Old Bailey Online</emph>. (N. de T.)</p>
                <p>
                    <ref type="footnotemark" target="#note_3"/> : El eufemismo "n-word" se refiere a una de las palabras más ofensivas que existe en lengua inglesa para designar a los afrodescendientes. Puede verse una explicación [aquí]<ref target="https://www.wordreference.com/es/translation.asp?tranword=nigger">aquí</ref>. (N. de T.)</p>
                <p>
                    <ref type="footnotemark" target="#note_4"/> : Aquí usaremos el término "<hi rend="bold">variable de servidor</hi>" para <emph>las variables que se asignan en un URL</emph> y que son procesados por el servidor (PhP, Ruby on Rails, Flask, etc.).
En el caso del <emph>OBO</emph>, los nombres de estas siguen la convención del <ref target="https://es.wikipedia.org/wiki/Camel_case">camelCase o letra de caja camello</ref>; por ejemplo: <code rend="inline">fromYear</code>, <code rend="inline">toYear</code>, <code rend="inline">fromMonth</code>, <code rend="inline">toMonth</code>, etc.
Por el contrario, llamaremos simplemente "<hi rend="bold">variables</hi>" a las variables de Python.
<ref target="https://peps.python.org/pep-0008/">La convención de Python</ref> es <emph>no</emph> usar camelCase para sus nombres sino usar guiones bajos <code rend="inline">_</code> para mejorar la legibilidad; en nuestro caso, <code rend="inline">from_year</code>, <code rend="inline">to_year</code>, <code rend="inline">from_month</code>, <code rend="inline">to_month</code>, etc.</p>
                <p>
                    <ref type="footnotemark" target="#note_5"/> : La función <code rend="inline">range</code> de Python crea una <ref target="https://docs.python.org/3/library/stdtypes.html#typesseq-range">secuencia inmutable de números</ref> que puede ser usada como iterador en un bucle <code rend="inline">for</code>.
<code rend="inline">range</code> toma un argumento obligatorio: el valor de parada. Este valor siempre es <emph>una unidad menor que</emph> el valor de parada.
El valor inicial de la secuencia es por defecto 0.
Así, por ejemplo, <code rend="inline">range(3)</code> creará la siguiente secuencia inmutable: <code rend="inline">0, 1, 2</code>, puesto que 2 es una unidad menor que el valor de parada 3.
<code rend="inline">range</code> también puede tomar un valor inicial distinto como <emph>primer</emph> argumento de función (aunque es opcional).
Por ejemplo, <code rend="inline">range(1, 3)</code> creará la secuencia: <code rend="inline">1, 2</code>.
Es por esto que en el ejemplo del código de la lección necesitamos la expresión <code rend="inline">range(1, contar_paginas + 1)</code>.
Esta expresión crea una secuencia que empieza en 1 y se detiene <emph>e incluye</emph> el valor de la variable <code rend="inline">contar_paginas</code>.
Por ejemplo, si <code rend="inline">contar_paginas</code> es 3, la expresión <code rend="inline">range(1, contar_paginas + 1)</code> equivaldrá a <code rend="inline">range(1, 4)</code>, que en efecto creará la secuencia <code rend="inline">1, 2, 3</code>.
Por lo tanto, el bucle <code rend="inline">for pagina in range(1, contar_paginas + 1)</code> iterará tres veces: una vez por cada página de resultados.</p>
                <p>
                    <ref type="footnotemark" target="#note_6"/> : Más adelante, en la función <code rend="inline">obtener_procesos_individuales</code>, procesaremos una a una las páginas descargadas, buscando las URLs de los procesos judiciales en la <emph>OBO</emph>.
Será importante que los procesemos en el mismo orden en que los descargamos: <code rend="inline">resultado_consulta0.html</code>, <code rend="inline">resultado_consulta1.html</code>, <code rend="inline">resultado_consulta2.html</code>, etc.
Cuando lleguemos a <code rend="inline">resultado_consulta10.html</code> nos encontraremos con un problema.
Como el orden de procesamiento de archivos ocurre por orden alfabético (pues así se ordenan por defecto en los directorios),
<code rend="inline">resultado_consulta10.html</code> será procesado luego de <code rend="inline">resultado_consulta1.html</code> y antes de <code rend="inline">resultado_consulta2.html</code>.
Para el ejemplo de esta lección eso no será un problema, porque solo tenemos dos páginas de consulta (dado que hay 13 registros).
Si quisiéramos blindar nuestro código para búsquedas con más de 99 registros, debemos asegurarnos de que el orden de procesamiento sea el correcto.
Una forma sencilla de hacerlo así:</p>
                <ab>
                    <code xml:id="code_descarga-multiples-registros-usando-cadenas-de-consulta_39" corresp="code_descarga-multiples-registros-usando-cadenas-de-consulta_39.txt" rend="block"/>
                </ab>
                <p>
                    <ref type="footnotemark" target="#note_7"/> : La <code rend="inline">r</code> en la expresión <code rend="inline">r'\W'</code> establece que <code rend="inline">'\W'</code> es una "cadena cruda" (<emph>raw string</emph>), lo que facilita en general el trabajo con expresiones regulares. Al respecto véasen <ref target="https://docs.python.org/3/library/re.html">https://docs.python.org/3/library/re.html</ref> y <ref target="https://blog.devgenius.io/beauty-of-raw-strings-in-python-fa627d674cbf">https://blog.devgenius.io/beauty-of-raw-strings-in-python-fa627d674cbf</ref>
                </p>
            </div>
        </body>
    </text>
</TEI>
